{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python API client for NeuroIO Read Latest Documentation - Browse GitHub Code Repository This library strives to be a complete mirror of official NeuroIO API in terms of methods and interfaces. Official latest API documentation can be found here . For your convenience, you can make API calls using sync or async (asyncio) interface. Installation pip install neuroio Note that it is always recommended pinning version of your installed packages. Usage example (sync) An example of how to create a source: from neuroio import Client if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to create source client . sources . create ( name = \"test_name\" ) Now that we have our source created, we can create person inside that source: from neuroio import Client def create_persons_example ( client : Client ): source_name = \"test_name\" with open ( \"image.png\" , \"rb\" ) as f : response = client . persons . create ( image = f , source = source_name , facesize = 1000 , create_on_ha = True , create_on_junk = True , identify_asm = True ) print ( \"Persons Create Response: \\n \" , response . json (), flush = True ) if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to create a person create_persons_example ( client ) Now that we have our source & person created, we can search for persons: from neuroio import Client def search_persons_example ( client : Client ): with open ( \"image.png\" , \"rb\" ) as f : response = client . persons . search ( image = f , identify_asm = True ) print ( \"Persons Search Response: \\n \" , response . json (), flush = True ) if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to search persons search_persons_example ( client ) For more examples and usage, please refer to the docs . Development setup To install all the development requirements: pip install --upgrade pip pip install poetry poetry install To run linters & test suite: ./scripts/test.sh Release History 0.0.6 Updated library to latest API version (at the time of this release - 1.2.1) Updated README & docs 0.0.5 Fixed persistent connection problems Updated requirements Codebase cleanup 0.0.4 Changed the way how we treat httpx connection - now we don't close it after every request (which was supposedly right way in httpx docs) 0.0.3 Updated httpx version, disabled cruft check since it just messes up project files License Distributed under the MIT license. See LICENSE for more information. Contributing Fork it ( https://github.com/yourname/yourproject/fork ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Home"},{"location":"#python-api-client-for-neuroio","text":"Read Latest Documentation - Browse GitHub Code Repository This library strives to be a complete mirror of official NeuroIO API in terms of methods and interfaces. Official latest API documentation can be found here . For your convenience, you can make API calls using sync or async (asyncio) interface.","title":"Python API client for NeuroIO"},{"location":"#installation","text":"pip install neuroio Note that it is always recommended pinning version of your installed packages.","title":"Installation"},{"location":"#usage-example-sync","text":"An example of how to create a source: from neuroio import Client if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to create source client . sources . create ( name = \"test_name\" ) Now that we have our source created, we can create person inside that source: from neuroio import Client def create_persons_example ( client : Client ): source_name = \"test_name\" with open ( \"image.png\" , \"rb\" ) as f : response = client . persons . create ( image = f , source = source_name , facesize = 1000 , create_on_ha = True , create_on_junk = True , identify_asm = True ) print ( \"Persons Create Response: \\n \" , response . json (), flush = True ) if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to create a person create_persons_example ( client ) Now that we have our source & person created, we can search for persons: from neuroio import Client def search_persons_example ( client : Client ): with open ( \"image.png\" , \"rb\" ) as f : response = client . persons . search ( image = f , identify_asm = True ) print ( \"Persons Search Response: \\n \" , response . json (), flush = True ) if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to search persons search_persons_example ( client ) For more examples and usage, please refer to the docs .","title":"Usage example (sync)"},{"location":"#development-setup","text":"To install all the development requirements: pip install --upgrade pip pip install poetry poetry install To run linters & test suite: ./scripts/test.sh","title":"Development setup"},{"location":"#release-history","text":"0.0.6 Updated library to latest API version (at the time of this release - 1.2.1) Updated README & docs 0.0.5 Fixed persistent connection problems Updated requirements Codebase cleanup 0.0.4 Changed the way how we treat httpx connection - now we don't close it after every request (which was supposedly right way in httpx docs) 0.0.3 Updated httpx version, disabled cruft check since it just messes up project files","title":"Release History"},{"location":"#license","text":"Distributed under the MIT license. See LICENSE for more information.","title":"License"},{"location":"#contributing","text":"Fork it ( https://github.com/yourname/yourproject/fork ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Contributing"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of neuroio simply run: pip3 install neuroio OR poetry add neuroio OR pipenv install neuroio Changelog 0.0.6 Updated library to latest API version (at the time of this release - 1.2.1) Updated README & docs 0.0.5 Fixed persistent connection problems Updated requirements Codebase cleanup 0.0.4 Changed the way how we treat httpx connection - now we don't close it after every request (which was supposedly right way in httpx docs) 0.0.3 Updated httpx version, disabled cruft check since it just messes up project files","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of neuroio simply run: pip3 install neuroio OR poetry add neuroio OR pipenv install neuroio","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"0.0.6 Updated library to latest API version (at the time of this release - 1.2.1) Updated README & docs 0.0.5 Fixed persistent connection problems Updated requirements Codebase cleanup 0.0.4 Changed the way how we treat httpx connection - now we don't close it after every request (which was supposedly right way in httpx docs) 0.0.3 Updated httpx version, disabled cruft check since it just messes up project files","title":"Changelog"},{"location":"docs/authentication/","text":"Authentication Basic concepts There are two main namespaces in NeuroIO: IAM & API. IAM (identity & access management) allows you to follow authentication flow using username/password, create API access tokens for your application, manage Spaces and many more. API (application programming interface) allows you to interact with database of people, create sources of data, manage notifications settings and many more. Some things to note about access tokens: In order to access NeuroIO API, you need valid token. Valid token is the one, that is currently active & not expired. Tokens could be temporary & permanent (those do not expire automatically). As of now, all temporary tokens have the same TTL of 24 hours since creation time. Login This method creates new temporary token for user if username/password pair is correct. from neuroio import Client c = Client () login_response = c . auth . login ( username = \"usr\" , password = \"pwd\" ) json_login_response = login_response . json () if login_response . status_code == 200 : print ( \"Login Successful.\" ) print ( json_login_response ) # { # 'user': { # 'username': 'usr' # }, # 'token': { # 'id': 1, # 'key': 'abcd', # 'is_active': True, # 'created': '2021-05-28T10:37:51.433760+00:00', # 'expires': '2021-05-29T10:37:51.433563+00:00' # } # } else : print ( \"Login failed.\" ) print ( json_login_response ) # { # 'error_codes': [602], # 'message': 'Username and password do not match.', # 'fields': [] # } After that you need to re-create Client instance with as so: from neuroio import Client client = Client ( api_token = json_login_response [ \"token\" ][ \"key\" ]) # From now on, use this new client instance whenever you access API Change password Given correct current password, this method allows you to specify new password & optionally reset all tokens that were previously created. from neuroio import Client c = Client ( api_token = \"abcd\" ) login_response = c . auth . password_change ( old_password = \"pwd\" , new_password = \"newpwd\" , reset_tokens = False ) json_response = login_response . json () if login_response . status_code == 204 : print ( \"Password change successful.\" ) else : print ( \"Password change failed.\" ) print ( json_response ) # { # 'error_codes': [400], # 'message': 'Validation error.', # 'fields': [ # { # 'name': 'old_password', # 'message': 'Incorrect password.', # 'error_code': 400 # } # ] # }","title":"Authentication"},{"location":"docs/authentication/#authentication","text":"","title":"Authentication"},{"location":"docs/authentication/#basic-concepts","text":"There are two main namespaces in NeuroIO: IAM & API. IAM (identity & access management) allows you to follow authentication flow using username/password, create API access tokens for your application, manage Spaces and many more. API (application programming interface) allows you to interact with database of people, create sources of data, manage notifications settings and many more. Some things to note about access tokens: In order to access NeuroIO API, you need valid token. Valid token is the one, that is currently active & not expired. Tokens could be temporary & permanent (those do not expire automatically). As of now, all temporary tokens have the same TTL of 24 hours since creation time.","title":"Basic concepts"},{"location":"docs/authentication/#login","text":"This method creates new temporary token for user if username/password pair is correct. from neuroio import Client c = Client () login_response = c . auth . login ( username = \"usr\" , password = \"pwd\" ) json_login_response = login_response . json () if login_response . status_code == 200 : print ( \"Login Successful.\" ) print ( json_login_response ) # { # 'user': { # 'username': 'usr' # }, # 'token': { # 'id': 1, # 'key': 'abcd', # 'is_active': True, # 'created': '2021-05-28T10:37:51.433760+00:00', # 'expires': '2021-05-29T10:37:51.433563+00:00' # } # } else : print ( \"Login failed.\" ) print ( json_login_response ) # { # 'error_codes': [602], # 'message': 'Username and password do not match.', # 'fields': [] # } After that you need to re-create Client instance with as so: from neuroio import Client client = Client ( api_token = json_login_response [ \"token\" ][ \"key\" ]) # From now on, use this new client instance whenever you access API","title":"Login"},{"location":"docs/authentication/#change-password","text":"Given correct current password, this method allows you to specify new password & optionally reset all tokens that were previously created. from neuroio import Client c = Client ( api_token = \"abcd\" ) login_response = c . auth . password_change ( old_password = \"pwd\" , new_password = \"newpwd\" , reset_tokens = False ) json_response = login_response . json () if login_response . status_code == 204 : print ( \"Password change successful.\" ) else : print ( \"Password change failed.\" ) print ( json_response ) # { # 'error_codes': [400], # 'message': 'Validation error.', # 'fields': [ # { # 'name': 'old_password', # 'message': 'Incorrect password.', # 'error_code': 400 # } # ] # }","title":"Change password"},{"location":"docs/basics/","text":"Common usage patterns Basic concepts For any call you do, in response you'll get httpx response object. So you can do anything with it as per httpx docs . You can parse response as json, read http status code, response headers and all that good stuff. Note that responses are only of two kinds - successes (< 400) & errors (>= 400). Please refer to the documentation of NeuroIO API for response format in each individual case. Unlike successful responses, errors are always the same format which can be easily parsed on client's side like so: from neuroio import Client class NeuroIOFieldError : def __init__ ( self , name : str , message : str , error_code : int ): self . name = name self . message = message self . error_code = error_code class NeuroIOException ( Exception ): def __init__ ( self , json_response : dict ): self . error_codes = json_response [ \"error_codes\" ] self . message = json_response [ \"message\" ] self . fields = [ NeuroIOFieldError ( ** f ) for f in json_response [ \"fields\" ]] if __name__ == '__main__' : c = Client () response = c . spaces . create ( name = \"test\" ) if response . status_code >= 400 : exc = NeuroIOException ( json_response = response . json ()) raise exc","title":"Basics"},{"location":"docs/basics/#common-usage-patterns","text":"","title":"Common usage patterns"},{"location":"docs/basics/#basic-concepts","text":"For any call you do, in response you'll get httpx response object. So you can do anything with it as per httpx docs . You can parse response as json, read http status code, response headers and all that good stuff. Note that responses are only of two kinds - successes (< 400) & errors (>= 400). Please refer to the documentation of NeuroIO API for response format in each individual case. Unlike successful responses, errors are always the same format which can be easily parsed on client's side like so: from neuroio import Client class NeuroIOFieldError : def __init__ ( self , name : str , message : str , error_code : int ): self . name = name self . message = message self . error_code = error_code class NeuroIOException ( Exception ): def __init__ ( self , json_response : dict ): self . error_codes = json_response [ \"error_codes\" ] self . message = json_response [ \"message\" ] self . fields = [ NeuroIOFieldError ( ** f ) for f in json_response [ \"fields\" ]] if __name__ == '__main__' : c = Client () response = c . spaces . create ( name = \"test\" ) if response . status_code >= 400 : exc = NeuroIOException ( json_response = response . json ()) raise exc","title":"Basic concepts"},{"location":"docs/entries/","text":"Entries Basic concepts Entries are containers which store the results of the processing of a photo that was uploaded to the platform. The source of the photo can be either the user (when they create or re-initialize a persona) or a surveillance camera that is connected to the platform via the preprocessing server. When a user uploads a photo, two types of entries may appear in the platform: new and reinit. When video streams from network cameras are processed, all types of entries can appear in the platform: new, reinit, exact, ha, junk, nm and det. List Entries Authorized Client() required. This method returns paginated list of entries. All the filtering parameters in this call are optional, this example just shows every single option. For sex : 0 - male, 1 - female. import datetime from neuroio import Client from neuroio.constants import EntryLiveness , EntryMood , EntryResult c = Client ( api_token = \"abcd\" ) response = c . entries . list ( pid = [ \"abcdef01-abcd-abcd01-abcdef01\" ], result = [ EntryResult . NEW ], age_from = 1 , age_to = 100 , sex = 0 , mood = [ EntryMood . FEAR ], liveness = [ EntryLiveness . PASSED ], sources_ids = [ 1 ], spaces_ids = [ 1 ], date_from = datetime . datetime ( year = 2020 , month = 1 , day = 31 ), date_to = datetime . datetime . utcnow (), limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response ) Get the statistics for a persona\u2019s id Authorized Client() required. This method returns statistics for a person, if found by its pid. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . entries . get ( pid = \"abcdef01-abcd-abcd01-abcdef01\" ) json_response = response . json () print ( json_response ) Delete Entry by id Authorized Client() required. This method deletes entry, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . entries . delete ( id = 1 ) if response . status_code == 204 : print ( \"Entry deleted successfully.\" )","title":"Entries"},{"location":"docs/entries/#entries","text":"","title":"Entries"},{"location":"docs/entries/#basic-concepts","text":"Entries are containers which store the results of the processing of a photo that was uploaded to the platform. The source of the photo can be either the user (when they create or re-initialize a persona) or a surveillance camera that is connected to the platform via the preprocessing server. When a user uploads a photo, two types of entries may appear in the platform: new and reinit. When video streams from network cameras are processed, all types of entries can appear in the platform: new, reinit, exact, ha, junk, nm and det.","title":"Basic concepts"},{"location":"docs/entries/#list-entries","text":"Authorized Client() required. This method returns paginated list of entries. All the filtering parameters in this call are optional, this example just shows every single option. For sex : 0 - male, 1 - female. import datetime from neuroio import Client from neuroio.constants import EntryLiveness , EntryMood , EntryResult c = Client ( api_token = \"abcd\" ) response = c . entries . list ( pid = [ \"abcdef01-abcd-abcd01-abcdef01\" ], result = [ EntryResult . NEW ], age_from = 1 , age_to = 100 , sex = 0 , mood = [ EntryMood . FEAR ], liveness = [ EntryLiveness . PASSED ], sources_ids = [ 1 ], spaces_ids = [ 1 ], date_from = datetime . datetime ( year = 2020 , month = 1 , day = 31 ), date_to = datetime . datetime . utcnow (), limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response )","title":"List Entries"},{"location":"docs/entries/#get-the-statistics-for-a-personas-id","text":"Authorized Client() required. This method returns statistics for a person, if found by its pid. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . entries . get ( pid = \"abcdef01-abcd-abcd01-abcdef01\" ) json_response = response . json () print ( json_response )","title":"Get the statistics for a persona\u2019s id"},{"location":"docs/entries/#delete-entry-by-id","text":"Authorized Client() required. This method deletes entry, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . entries . delete ( id = 1 ) if response . status_code == 204 : print ( \"Entry deleted successfully.\" )","title":"Delete Entry by id"},{"location":"docs/groups/","text":"Person Groups Basic concepts You can group persons into arbitrary lists. If the identified person is included in any group or groups, then notifications from the platform will contain not only the person's identifier, but also the names of all groups in which user is included. Each person can be added to any number of groups. Each group can contain a maximum of 100,000 persons. Create Person Group Authorized Client() required. This method creates new person group. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . create ( name = \"test\" ) json_response = response . json () print ( json_response ) List Person Groups Authorized Client() required. This method returns paginated list of groups. Can be filtered by name using q . All the filtering parameters in this call are optional, this example just shows every single option. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . list ( q = \"te\" , pids_include = [ \"abcdef01-abcd-abcd01-abcdef01\" ], pids_exclude = [ \"fedcab10-dcba-dcba10-fedcab10\" ], groups_ids = [ 1 , 2 , 3 ], spaces_ids = [ 4 , 5 , 6 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response ) Get Person Group by id Authorized Client() required. This method returns group info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . get ( id = 1 ) json_response = response . json () print ( json_response ) Update Person Group by id Authorized Client() required. This method updates group info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . update ( id = 1 , name = \"newname\" ) json_response = response . json () print ( json_response ) Delete Person Group by id Authorized Client() required. This method deletes group, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . groups . delete ( id = 1 ) if response . status_code == 204 : print ( \"Person Group deleted successfully.\" ) Get a list of persons in a group Authorized Client() required. This method returns paginated results of persons that are in a group, if found by id. You can filter out list by specifying exact list of PIDs. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . persons ( id = 1 , pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], limit = 5 , offset = 0 ) json_response = response . json () print ( json_response ) Add persons to groups Authorized Client() required. This method allows you to add many persons to many groups in one request. Max PIDs in request - 100. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . add ( pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], groups_ids = [ 1 , 2 , 3 , 4 , 5 ] ) Remove persons to groups Authorized Client() required. This method allows you to remove many persons from many groups in one request. Max PIDs in request - 100. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . remove ( pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], groups_ids = [ 1 , 2 , 3 , 4 , 5 ] )","title":"Groups"},{"location":"docs/groups/#person-groups","text":"","title":"Person Groups"},{"location":"docs/groups/#basic-concepts","text":"You can group persons into arbitrary lists. If the identified person is included in any group or groups, then notifications from the platform will contain not only the person's identifier, but also the names of all groups in which user is included. Each person can be added to any number of groups. Each group can contain a maximum of 100,000 persons.","title":"Basic concepts"},{"location":"docs/groups/#create-person-group","text":"Authorized Client() required. This method creates new person group. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . create ( name = \"test\" ) json_response = response . json () print ( json_response )","title":"Create Person Group"},{"location":"docs/groups/#list-person-groups","text":"Authorized Client() required. This method returns paginated list of groups. Can be filtered by name using q . All the filtering parameters in this call are optional, this example just shows every single option. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . list ( q = \"te\" , pids_include = [ \"abcdef01-abcd-abcd01-abcdef01\" ], pids_exclude = [ \"fedcab10-dcba-dcba10-fedcab10\" ], groups_ids = [ 1 , 2 , 3 ], spaces_ids = [ 4 , 5 , 6 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response )","title":"List Person Groups"},{"location":"docs/groups/#get-person-group-by-id","text":"Authorized Client() required. This method returns group info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . get ( id = 1 ) json_response = response . json () print ( json_response )","title":"Get Person Group by id"},{"location":"docs/groups/#update-person-group-by-id","text":"Authorized Client() required. This method updates group info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . update ( id = 1 , name = \"newname\" ) json_response = response . json () print ( json_response )","title":"Update Person Group by id"},{"location":"docs/groups/#delete-person-group-by-id","text":"Authorized Client() required. This method deletes group, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . groups . delete ( id = 1 ) if response . status_code == 204 : print ( \"Person Group deleted successfully.\" )","title":"Delete Person Group by id"},{"location":"docs/groups/#get-a-list-of-persons-in-a-group","text":"Authorized Client() required. This method returns paginated results of persons that are in a group, if found by id. You can filter out list by specifying exact list of PIDs. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . persons ( id = 1 , pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], limit = 5 , offset = 0 ) json_response = response . json () print ( json_response )","title":"Get a list of persons in a group"},{"location":"docs/groups/#add-persons-to-groups","text":"Authorized Client() required. This method allows you to add many persons to many groups in one request. Max PIDs in request - 100. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . add ( pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], groups_ids = [ 1 , 2 , 3 , 4 , 5 ] )","title":"Add persons to groups"},{"location":"docs/groups/#remove-persons-to-groups","text":"Authorized Client() required. This method allows you to remove many persons from many groups in one request. Max PIDs in request - 100. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . remove ( pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], groups_ids = [ 1 , 2 , 3 , 4 , 5 ] )","title":"Remove persons to groups"},{"location":"docs/notifications/","text":"Notifications Basic concepts The notification service allows you to receive filtered data about events as soon as they happened, and without the need to constantly query the platform. The platform supports the following types of transport: webhook - when an event occurs, a POST or GET request with a fixed syntax is sent to the specified url; websocket - the client application itself initiates a connection to the service and receives a notification on it in the format of websocket messages. For applications in which the speed of informing about events that have occurred in the platform is important, it is recommended to use a websocket connection. This type of transport is always on, no pre-filtering is provided. For client applications operating in gray networks and receiving data directly from the platform, only websocket transport is suitable for use. Folliwing sections only apply to webhooks! Create Notification Authorized Client() required. This method creates new notification with specified parameters. from neuroio import Client from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , ) c = Client ( api_token = \"abcd\" ) response = c . notifications . create ( name = \"test\" , http_method = HttpMethod . POST , destination_url = \"https://neuroio.com/\" , is_active = True , moods = [ EntryMood . FEAR ], results = [ EntryResult . NEW ], liveness = [ EntryLiveness . PASSED ], age_from = 1 , age_to = 100 , sex = Sex . MALE , sources = [ 1 , 2 , 3 ], persons_groups = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response ) List Notifications Authorized Client() required. This method returns paginated list of notifications. Can be filtered by name using q , also, by list of Spaces IDs. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . notifications . list ( q = \"te\" , spaces_ids = [ 1 , 2 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response ) Get Notification by id Authorized Client() required. This method returns notification info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . notifications . get ( id = 1 ) json_response = response . json () print ( json_response ) Update Notification by id Authorized Client() required. This method updates notification info, if found by its id. from neuroio import Client from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , ) c = Client ( api_token = \"abcd\" ) response = c . notifications . update ( name = \"test\" , http_method = HttpMethod . POST , destination_url = \"https://neuroio.com/\" , is_active = True , moods = [ EntryMood . FEAR ], results = [ EntryResult . NEW ], liveness = [ EntryLiveness . PASSED ], age_from = 1 , age_to = 100 , sex = Sex . MALE , sources = [ 1 , 2 , 3 ], persons_groups = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response ) Delete Notification by id Authorized Client() required. This method deletes notification, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . notifications . delete ( id = 1 ) if response . status_code == 204 : print ( \"Notification deleted successfully.\" )","title":"Notifications"},{"location":"docs/notifications/#notifications","text":"","title":"Notifications"},{"location":"docs/notifications/#basic-concepts","text":"The notification service allows you to receive filtered data about events as soon as they happened, and without the need to constantly query the platform. The platform supports the following types of transport: webhook - when an event occurs, a POST or GET request with a fixed syntax is sent to the specified url; websocket - the client application itself initiates a connection to the service and receives a notification on it in the format of websocket messages. For applications in which the speed of informing about events that have occurred in the platform is important, it is recommended to use a websocket connection. This type of transport is always on, no pre-filtering is provided. For client applications operating in gray networks and receiving data directly from the platform, only websocket transport is suitable for use. Folliwing sections only apply to webhooks!","title":"Basic concepts"},{"location":"docs/notifications/#create-notification","text":"Authorized Client() required. This method creates new notification with specified parameters. from neuroio import Client from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , ) c = Client ( api_token = \"abcd\" ) response = c . notifications . create ( name = \"test\" , http_method = HttpMethod . POST , destination_url = \"https://neuroio.com/\" , is_active = True , moods = [ EntryMood . FEAR ], results = [ EntryResult . NEW ], liveness = [ EntryLiveness . PASSED ], age_from = 1 , age_to = 100 , sex = Sex . MALE , sources = [ 1 , 2 , 3 ], persons_groups = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response )","title":"Create Notification"},{"location":"docs/notifications/#list-notifications","text":"Authorized Client() required. This method returns paginated list of notifications. Can be filtered by name using q , also, by list of Spaces IDs. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . notifications . list ( q = \"te\" , spaces_ids = [ 1 , 2 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response )","title":"List Notifications"},{"location":"docs/notifications/#get-notification-by-id","text":"Authorized Client() required. This method returns notification info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . notifications . get ( id = 1 ) json_response = response . json () print ( json_response )","title":"Get Notification by id"},{"location":"docs/notifications/#update-notification-by-id","text":"Authorized Client() required. This method updates notification info, if found by its id. from neuroio import Client from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , ) c = Client ( api_token = \"abcd\" ) response = c . notifications . update ( name = \"test\" , http_method = HttpMethod . POST , destination_url = \"https://neuroio.com/\" , is_active = True , moods = [ EntryMood . FEAR ], results = [ EntryResult . NEW ], liveness = [ EntryLiveness . PASSED ], age_from = 1 , age_to = 100 , sex = Sex . MALE , sources = [ 1 , 2 , 3 ], persons_groups = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response )","title":"Update Notification by id"},{"location":"docs/notifications/#delete-notification-by-id","text":"Authorized Client() required. This method deletes notification, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . notifications . delete ( id = 1 ) if response . status_code == 204 : print ( \"Notification deleted successfully.\" )","title":"Delete Notification by id"},{"location":"docs/persons/","text":"Persons Basic concepts Persons are wrapped face embeddings that come through user uploads or automatically from connected cameras. In fact, this is the similar \"tag\" as sources, but if the sources indicate where the photo came from, then the person is a tag indicating who is on it. Entry types that are always associated with persons: new, reinit, exact, ha, junk. The types of records nm, det cannot be associated with persons, since in this case the platform does not know who is in the photo. Any work with persons implies the automatic scope of the token with which the request is made. When created, created from id, upon reinit, Entries and Persons fall into the same space where the source specified in the request is located (again, provided that this source is visible from the current token space). Create Person Authorized Client() required. This method creates (or finds, to avoid duplicates) person using provided photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . create ( image = f , source = \"test\" , facesize = 1000 , create_on_ha = True , create_on_junk = False , identify_asm = True ) json_response = response . json () print ( json_response ) Create Person from Entry Authorized Client() required. This method creates new persons from photo on specified Entry ID. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . persons . create_by_entry ( id = 1 , create_on_ha = False , create_on_junk = False ) json_response = response . json () print ( json_response ) Re-init Person from photo in specified Entry ID. Authorized Client() required. This method changes face embedding for a specified persons to the one, extracted from photo in Entry. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . persons . reinit ( id = 1 ) # NOTE: There is empty response in case of successful operation Re-init Person from provided photo Authorized Client() required. This method changes face embedding for a specified persons to the one, extracted from provided photo. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . reinit_by_photo ( pid = \"abcdef01-abcd-abcd01-abcdef01\" , image = f , source = \"test\" , facesize = 1000 , identify_asm = True , result = EntryResult . HA , ) # NOTE: There is empty response in case of successful operation Search Person by provided photo Authorized Client() required. This method searches for a person in database, comparing face embedding from provided photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . search ( image = f , identify_asm = True ) json_response = response . json () print ( json_response ) Delete Person by PID Authorized Client() required. This method deletes person, if found by its pid. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . persons . delete ( pid = \"abcdef01-abcd-abcd01-abcdef01\" ) if response . status_code == 204 : print ( \"Person deleted successfully.\" )","title":"Persons"},{"location":"docs/persons/#persons","text":"","title":"Persons"},{"location":"docs/persons/#basic-concepts","text":"Persons are wrapped face embeddings that come through user uploads or automatically from connected cameras. In fact, this is the similar \"tag\" as sources, but if the sources indicate where the photo came from, then the person is a tag indicating who is on it. Entry types that are always associated with persons: new, reinit, exact, ha, junk. The types of records nm, det cannot be associated with persons, since in this case the platform does not know who is in the photo. Any work with persons implies the automatic scope of the token with which the request is made. When created, created from id, upon reinit, Entries and Persons fall into the same space where the source specified in the request is located (again, provided that this source is visible from the current token space).","title":"Basic concepts"},{"location":"docs/persons/#create-person","text":"Authorized Client() required. This method creates (or finds, to avoid duplicates) person using provided photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . create ( image = f , source = \"test\" , facesize = 1000 , create_on_ha = True , create_on_junk = False , identify_asm = True ) json_response = response . json () print ( json_response )","title":"Create Person"},{"location":"docs/persons/#create-person-from-entry","text":"Authorized Client() required. This method creates new persons from photo on specified Entry ID. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . persons . create_by_entry ( id = 1 , create_on_ha = False , create_on_junk = False ) json_response = response . json () print ( json_response )","title":"Create Person from Entry"},{"location":"docs/persons/#re-init-person-from-photo-in-specified-entry-id","text":"Authorized Client() required. This method changes face embedding for a specified persons to the one, extracted from photo in Entry. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . persons . reinit ( id = 1 ) # NOTE: There is empty response in case of successful operation","title":"Re-init Person from photo in specified Entry ID."},{"location":"docs/persons/#re-init-person-from-provided-photo","text":"Authorized Client() required. This method changes face embedding for a specified persons to the one, extracted from provided photo. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . reinit_by_photo ( pid = \"abcdef01-abcd-abcd01-abcdef01\" , image = f , source = \"test\" , facesize = 1000 , identify_asm = True , result = EntryResult . HA , ) # NOTE: There is empty response in case of successful operation","title":"Re-init Person from provided photo"},{"location":"docs/persons/#search-person-by-provided-photo","text":"Authorized Client() required. This method searches for a person in database, comparing face embedding from provided photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . search ( image = f , identify_asm = True ) json_response = response . json () print ( json_response )","title":"Search Person by provided photo"},{"location":"docs/persons/#delete-person-by-pid","text":"Authorized Client() required. This method deletes person, if found by its pid. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . persons . delete ( pid = \"abcdef01-abcd-abcd01-abcdef01\" ) if response . status_code == 204 : print ( \"Person deleted successfully.\" )","title":"Delete Person by PID"},{"location":"docs/settings/","text":"Threshold Settings Basic concepts The platform operates with events that have several types of results. The results have predefined thresholds, but the threshold values can be changed if necessary using settings. New threshold values will be applied only for the classification of future Entries, the classification of previous Entries cannot be changed. You can have different threshold settings for different spaces (very useful in some security scenarios). Get current thresholds Authorized Client() required. This method get the info about current threshold settings. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . get () json_response = response . json () print ( json_response ) Update threshold settings Authorized Client() required. This method updates the values of threshold settings. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . update ( exact = 90.0 , ha = 80.0 , junk = 70.0 , ) json_response = response . json () print ( json_response ) Reset current thresholds to defaults Authorized Client() required. This method sets all threshold settings to default ones. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . reset () json_response = response . json () print ( json_response )","title":"Settings"},{"location":"docs/settings/#threshold-settings","text":"","title":"Threshold Settings"},{"location":"docs/settings/#basic-concepts","text":"The platform operates with events that have several types of results. The results have predefined thresholds, but the threshold values can be changed if necessary using settings. New threshold values will be applied only for the classification of future Entries, the classification of previous Entries cannot be changed. You can have different threshold settings for different spaces (very useful in some security scenarios).","title":"Basic concepts"},{"location":"docs/settings/#get-current-thresholds","text":"Authorized Client() required. This method get the info about current threshold settings. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . get () json_response = response . json () print ( json_response )","title":"Get current thresholds"},{"location":"docs/settings/#update-threshold-settings","text":"Authorized Client() required. This method updates the values of threshold settings. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . update ( exact = 90.0 , ha = 80.0 , junk = 70.0 , ) json_response = response . json () print ( json_response )","title":"Update threshold settings"},{"location":"docs/settings/#reset-current-thresholds-to-defaults","text":"Authorized Client() required. This method sets all threshold settings to default ones. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . reset () json_response = response . json () print ( json_response )","title":"Reset current thresholds to defaults"},{"location":"docs/sources/","text":"Sources Basic concepts A source in the platform is a tag for the correct cataloging and correlation of incoming data, as well as a container with user settings which indicate how this data should be processed. All data stored in the platform must have as one of its attributes the name of its source, because only then can the platform accurately identify where the data has come from into the platform, and, as a result, correctly catalog it and execute custom logic. Before you begin uploading data to the platform, make sure to create a source with the same name that you will then specify in your API request or when connecting a camera to the preprocessing server. All data that is intended for cataloging and storage in the platform cannot be saved in the platform if when it is uploaded no source is specified or a source that does not exist is specified. An error message will appear each time this happens. Create Source Authorized Client() required. This method creates new source with specified name. All of the parameters, except name , are optional. from neuroio import Client from neuroio.constants import EntryResult , SourceLicense c = Client ( api_token = \"abcd\" ) response = c . sources . create ( name = \"test\" , license_type = SourceLicense . BASIC , identify_facesize_threshold = 1000 , use_pps_time = True , manual_create_facesize_threshold = 1000 , manual_create_on_ha = True , manual_create_on_junk = True , manual_identify_asm = False , auto_create_persons = True , auto_create_facesize_threshold = 1000 , auto_create_check_blur = True , auto_create_check_exposure = True , auto_create_on_ha = False , auto_create_on_junk = False , auto_check_face_angle = False , auto_check_liveness = False , auto_create_liveness_only = False , auto_identify_asm = False , store_images_for_results = [ EntryResult . DET ] ) json_response = response . json () print ( json_response ) List Sources Authorized Client() required. This method returns paginated list of sources. Can be filtered by name using q & by list of space ids. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . sources . list ( q = \"te\" , spaces_ids = [ 1 , 2 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response ) Get Source by id Authorized Client() required. This method returns source info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . sources . get ( id = 1 ) json_response = response . json () print ( json_response ) Update Source by id Authorized Client() required. This method updates source info, if found by its id. from neuroio import Client from neuroio.constants import EntryResult , SourceLicense c = Client ( api_token = \"abcd\" ) response = c . sources . update ( id = 1 , name = \"test\" , license_type = SourceLicense . BASIC , identify_facesize_threshold = 1000 , use_pps_time = True , manual_create_facesize_threshold = 1000 , manual_create_on_ha = True , manual_create_on_junk = True , manual_identify_asm = False , auto_create_persons = True , auto_create_facesize_threshold = 1000 , auto_create_check_blur = True , auto_create_check_exposure = True , auto_create_on_ha = False , auto_create_on_junk = False , auto_check_face_angle = False , auto_check_liveness = False , auto_create_liveness_only = False , auto_identify_asm = False , store_images_for_results = [ EntryResult . DET ] ) json_response = response . json () print ( json_response ) Delete Source by id Authorized Client() required. This method deletes source, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . sources . delete ( id = 1 ) if response . status_code == 202 : print ( \"Source deleted successfully.\" )","title":"Sources"},{"location":"docs/sources/#sources","text":"","title":"Sources"},{"location":"docs/sources/#basic-concepts","text":"A source in the platform is a tag for the correct cataloging and correlation of incoming data, as well as a container with user settings which indicate how this data should be processed. All data stored in the platform must have as one of its attributes the name of its source, because only then can the platform accurately identify where the data has come from into the platform, and, as a result, correctly catalog it and execute custom logic. Before you begin uploading data to the platform, make sure to create a source with the same name that you will then specify in your API request or when connecting a camera to the preprocessing server. All data that is intended for cataloging and storage in the platform cannot be saved in the platform if when it is uploaded no source is specified or a source that does not exist is specified. An error message will appear each time this happens.","title":"Basic concepts"},{"location":"docs/sources/#create-source","text":"Authorized Client() required. This method creates new source with specified name. All of the parameters, except name , are optional. from neuroio import Client from neuroio.constants import EntryResult , SourceLicense c = Client ( api_token = \"abcd\" ) response = c . sources . create ( name = \"test\" , license_type = SourceLicense . BASIC , identify_facesize_threshold = 1000 , use_pps_time = True , manual_create_facesize_threshold = 1000 , manual_create_on_ha = True , manual_create_on_junk = True , manual_identify_asm = False , auto_create_persons = True , auto_create_facesize_threshold = 1000 , auto_create_check_blur = True , auto_create_check_exposure = True , auto_create_on_ha = False , auto_create_on_junk = False , auto_check_face_angle = False , auto_check_liveness = False , auto_create_liveness_only = False , auto_identify_asm = False , store_images_for_results = [ EntryResult . DET ] ) json_response = response . json () print ( json_response )","title":"Create Source"},{"location":"docs/sources/#list-sources","text":"Authorized Client() required. This method returns paginated list of sources. Can be filtered by name using q & by list of space ids. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . sources . list ( q = \"te\" , spaces_ids = [ 1 , 2 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response )","title":"List Sources"},{"location":"docs/sources/#get-source-by-id","text":"Authorized Client() required. This method returns source info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . sources . get ( id = 1 ) json_response = response . json () print ( json_response )","title":"Get Source by id"},{"location":"docs/sources/#update-source-by-id","text":"Authorized Client() required. This method updates source info, if found by its id. from neuroio import Client from neuroio.constants import EntryResult , SourceLicense c = Client ( api_token = \"abcd\" ) response = c . sources . update ( id = 1 , name = \"test\" , license_type = SourceLicense . BASIC , identify_facesize_threshold = 1000 , use_pps_time = True , manual_create_facesize_threshold = 1000 , manual_create_on_ha = True , manual_create_on_junk = True , manual_identify_asm = False , auto_create_persons = True , auto_create_facesize_threshold = 1000 , auto_create_check_blur = True , auto_create_check_exposure = True , auto_create_on_ha = False , auto_create_on_junk = False , auto_check_face_angle = False , auto_check_liveness = False , auto_create_liveness_only = False , auto_identify_asm = False , store_images_for_results = [ EntryResult . DET ] ) json_response = response . json () print ( json_response )","title":"Update Source by id"},{"location":"docs/sources/#delete-source-by-id","text":"Authorized Client() required. This method deletes source, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . sources . delete ( id = 1 ) if response . status_code == 202 : print ( \"Source deleted successfully.\" )","title":"Delete Source by id"},{"location":"docs/spaces/","text":"Spaces Basic concepts Spaces are a way of having multiple databases of people inside your single account. Sources, Persons and any other entities are only visible (created & searched, for example) inside particular space you're in. To be precise, you can't have any data in your account that isn't attached to a space. You always have space named \"default\", and even if you use account tokens (not space tokens), you're still using spaces (well, that \"default\" space). Create Space Authorized Client() required. This method creates new space with specified name. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . create ( name = \"test\" ) json_response = response . json () print ( json_response ) List Spaces Authorized Client() required. This method returns paginated list of spaces. Can be filtered by name using q . from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . list ( q = \"te\" , limit = 10 , offset = 5 ) json_response = response . json () print ( json_response ) Get Space by id Authorized Client() required. This method returns space info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . get ( id = 1 ) json_response = response . json () print ( json_response ) Update Space by id Authorized Client() required. This method updates space info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . update ( id = 1 , name = \"newname\" ) json_response = response . json () print ( json_response ) Delete Space by id Authorized Client() required. This method deletes space, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . spaces . delete ( id = 1 ) if response . status_code == 204 : print ( \"Space deleted successfully.\" ) Create Token for specified Space Authorized Client() required. This method creates new token for space, if found by its id. You can create temporary or permanent token as with any other type of tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . token ( id = 1 , permanent = True ) json_response = response . json () print ( json_response )","title":"Spaces"},{"location":"docs/spaces/#spaces","text":"","title":"Spaces"},{"location":"docs/spaces/#basic-concepts","text":"Spaces are a way of having multiple databases of people inside your single account. Sources, Persons and any other entities are only visible (created & searched, for example) inside particular space you're in. To be precise, you can't have any data in your account that isn't attached to a space. You always have space named \"default\", and even if you use account tokens (not space tokens), you're still using spaces (well, that \"default\" space).","title":"Basic concepts"},{"location":"docs/spaces/#create-space","text":"Authorized Client() required. This method creates new space with specified name. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . create ( name = \"test\" ) json_response = response . json () print ( json_response )","title":"Create Space"},{"location":"docs/spaces/#list-spaces","text":"Authorized Client() required. This method returns paginated list of spaces. Can be filtered by name using q . from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . list ( q = \"te\" , limit = 10 , offset = 5 ) json_response = response . json () print ( json_response )","title":"List Spaces"},{"location":"docs/spaces/#get-space-by-id","text":"Authorized Client() required. This method returns space info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . get ( id = 1 ) json_response = response . json () print ( json_response )","title":"Get Space by id"},{"location":"docs/spaces/#update-space-by-id","text":"Authorized Client() required. This method updates space info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . update ( id = 1 , name = \"newname\" ) json_response = response . json () print ( json_response )","title":"Update Space by id"},{"location":"docs/spaces/#delete-space-by-id","text":"Authorized Client() required. This method deletes space, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . spaces . delete ( id = 1 ) if response . status_code == 204 : print ( \"Space deleted successfully.\" )","title":"Delete Space by id"},{"location":"docs/spaces/#create-token-for-specified-space","text":"Authorized Client() required. This method creates new token for space, if found by its id. You can create temporary or permanent token as with any other type of tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . token ( id = 1 , permanent = True ) json_response = response . json () print ( json_response )","title":"Create Token for specified Space"},{"location":"docs/tokens/","text":"Tokens Basic concepts Tokens are used to authorize API calls from clients. There are account, space & manager tokens: Account tokens are used to access most of the API as \"default\" Space Space tokens are just restricted for using with data inside that Space Manager tokens are restricted for using only in IAM management API Although, there are 3 types of tokens, you can use this same API for managing any of them. Platform will know which type of token you're referring to by looking at api_token that is in your Client() instance. You can have temporary (24 hours) or permanent token. Recommended way is to always use temporary tokens inside your applications and rotate them periodically. In order to help enforcing this practice, permanent tokens are restricted to maximum 5 of them per account/space. Create Token Authorized Client() required. This method creates new temporary or permanent token. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . create ( permanent = True ) json_response = response . json () print ( json_response ) List Tokens Authorized Client() required. This method returns paginated list of tokens. Can be filtered by permanence of tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . list ( permanent = False , limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response ) Get Token by id Authorized Client() required. This method returns token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . get ( token_id_or_key = 1 ) json_response = response . json () print ( json_response ) Update Token by id Authorized Client() required. This method updates token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . update ( token_id_or_key = 1 , is_active = False ) json_response = response . json () print ( json_response ) Delete Token by id Authorized Client() required. This method deletes token, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . tokens . delete ( token_id_or_key = 1 ) if response . status_code == 204 : print ( \"Token deleted successfully.\" ) Delete List of Tokens Authorized Client() required. This method deletes many tokens, if found by permanent filter. Rules of this filter are: * False - deletes only temporary tokens * True - deletes only permanent tokens * None - deletes all tokens from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . tokens . delete_list ( permanent = False ) if response . status_code == 204 : print ( \"Tokens deleted successfully.\" )","title":"Tokens"},{"location":"docs/tokens/#tokens","text":"","title":"Tokens"},{"location":"docs/tokens/#basic-concepts","text":"Tokens are used to authorize API calls from clients. There are account, space & manager tokens: Account tokens are used to access most of the API as \"default\" Space Space tokens are just restricted for using with data inside that Space Manager tokens are restricted for using only in IAM management API Although, there are 3 types of tokens, you can use this same API for managing any of them. Platform will know which type of token you're referring to by looking at api_token that is in your Client() instance. You can have temporary (24 hours) or permanent token. Recommended way is to always use temporary tokens inside your applications and rotate them periodically. In order to help enforcing this practice, permanent tokens are restricted to maximum 5 of them per account/space.","title":"Basic concepts"},{"location":"docs/tokens/#create-token","text":"Authorized Client() required. This method creates new temporary or permanent token. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . create ( permanent = True ) json_response = response . json () print ( json_response )","title":"Create Token"},{"location":"docs/tokens/#list-tokens","text":"Authorized Client() required. This method returns paginated list of tokens. Can be filtered by permanence of tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . list ( permanent = False , limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response )","title":"List Tokens"},{"location":"docs/tokens/#get-token-by-id","text":"Authorized Client() required. This method returns token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . get ( token_id_or_key = 1 ) json_response = response . json () print ( json_response )","title":"Get Token by id"},{"location":"docs/tokens/#update-token-by-id","text":"Authorized Client() required. This method updates token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . update ( token_id_or_key = 1 , is_active = False ) json_response = response . json () print ( json_response )","title":"Update Token by id"},{"location":"docs/tokens/#delete-token-by-id","text":"Authorized Client() required. This method deletes token, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . tokens . delete ( token_id_or_key = 1 ) if response . status_code == 204 : print ( \"Token deleted successfully.\" )","title":"Delete Token by id"},{"location":"docs/tokens/#delete-list-of-tokens","text":"Authorized Client() required. This method deletes many tokens, if found by permanent filter. Rules of this filter are: * False - deletes only temporary tokens * True - deletes only permanent tokens * None - deletes all tokens from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . tokens . delete_list ( permanent = False ) if response . status_code == 204 : print ( \"Tokens deleted successfully.\" )","title":"Delete List of Tokens"},{"location":"docs/utility/","text":"Utility Basic concepts This section indicates those functions that are not directly related to the logic of the platform, but help in certain user scenarios. Compare two photos Authorized Client() required. This function compares images of faces in uploaded photos for belonging to the same person. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) with open ( \"image1.png\" , \"rb\" ) as f1 : with open ( \"image2.png\" , \"rb\" ) as f2 : response = c . utility . compare ( image1 = f1 , image2 = f2 , result = EntryResult . HA ) json_response = response . json () print ( json_response ) Age/Sex/Mood Authorized Client() required. This function returns age / gender / mood for the person on a given photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . utility . asm ( image = f ) json_response = response . json () print ( json_response )","title":"Utility"},{"location":"docs/utility/#utility","text":"","title":"Utility"},{"location":"docs/utility/#basic-concepts","text":"This section indicates those functions that are not directly related to the logic of the platform, but help in certain user scenarios.","title":"Basic concepts"},{"location":"docs/utility/#compare-two-photos","text":"Authorized Client() required. This function compares images of faces in uploaded photos for belonging to the same person. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) with open ( \"image1.png\" , \"rb\" ) as f1 : with open ( \"image2.png\" , \"rb\" ) as f2 : response = c . utility . compare ( image1 = f1 , image2 = f2 , result = EntryResult . HA ) json_response = response . json () print ( json_response )","title":"Compare two photos"},{"location":"docs/utility/#agesexmood","text":"Authorized Client() required. This function returns age / gender / mood for the person on a given photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . utility . asm ( image = f ) json_response = response . json () print ( json_response )","title":"Age/Sex/Mood"},{"location":"docs/whoami/","text":"Who Am I Basic concepts If you want to know which type of account (and info on that account) you're using, use me method with some token. Get current account info Authorized Client() required. This method gets information about current user and space (or just space, if you're using space token). from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . whoami . me () json_response = response . json () print ( json_response )","title":"Whoami"},{"location":"docs/whoami/#who-am-i","text":"","title":"Who Am I"},{"location":"docs/whoami/#basic-concepts","text":"If you want to know which type of account (and info on that account) you're using, use me method with some token.","title":"Basic concepts"},{"location":"docs/whoami/#get-current-account-info","text":"Authorized Client() required. This method gets information about current user and space (or just space, if you're using space token). from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . whoami . me () json_response = response . json () print ( json_response )","title":"Get current account info"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to neuroio-python Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting neuroio-python set up for local development The first step when contributing to any project is getting it set up on your local machine. neuroio-python aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/neuroio-python.git cd neuroio-python poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the coding standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by neuroio-python contributors like you . Thank you!","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-neuroio-python","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to neuroio-python"},{"location":"docs/contributing/1.-contributing-guide/#getting-neuroio-python-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. neuroio-python aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/neuroio-python.git cd neuroio-python poetry install","title":"Getting neuroio-python set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the coding standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by neuroio-python contributors like you . Thank you!","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"Introduction This document gives coding conventions for the code in this repository. Optionally, projects that use this package are encouraged to follow this document and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. Descriptive Variable names Naming things is hard. This project has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to this project should be formatted using Black and isort. Black should be run with the line length set to 79, and isort with Black compatible settings in place. Automated Code Linting All code submitted should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the code in this repository. Optionally, projects that use this package are encouraged to follow this document and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. This project has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to this project should be formatted using Black and isort. Black should be run with the line length set to 79, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"Abstract Defines the Code of Conduct for this and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here For answers to common questions about this code of conduct, see","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for this and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here For answers to common questions about this code of conduct, see","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Lev Rubel (@levchik) Notable Bug Reporters - Code Contributors - Documenters - A sincere thanks to everyone who helps make neuroio-python into a great project! ~Lev Rubel","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Lev Rubel (@levchik)","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"-","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"- A sincere thanks to everyone who helps make neuroio-python into a great project! ~Lev Rubel","title":"Documenters"},{"location":"reference/neuroio/","text":"Module neuroio neuroio-python A Python package for interacting with the NeuroIO API View Source \"\"\"**neuroio-python** A Python package for interacting with the NeuroIO API \"\"\" from .clients import AsyncClient , Client __version__ : str = \"0.0.1\" __all__ = [ \"__version__\" , \"Client\" , \"AsyncClient\" ] Sub-modules neuroio.api neuroio.auth neuroio.clients neuroio.constants neuroio.iam neuroio.utils Variables __version__ Classes AsyncClient class AsyncClient ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class AsyncClient ( Client ) : @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM ) Ancestors (in MRO) neuroio.Client Instance variables auth common_headers entries groups notifications persons settings sources spaces tokens utility whoami Methods client_settings def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] View Source def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings get_api_class_instance def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings ) Client class Client ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_settings = self . client_settings ( timeout = timeout , base_url = constants . API_BASE_URL ) self . iam_settings = self . client_settings ( timeout = timeout , base_url = constants . IAM_BASE_URL ) @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any, Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM ) Descendants neuroio.AsyncClient Instance variables auth common_headers entries groups notifications persons settings sources spaces tokens utility whoami Methods client_settings def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] View Source def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings get_api_class_instance def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings )","title":"Index"},{"location":"reference/neuroio/#module-neuroio","text":"neuroio-python A Python package for interacting with the NeuroIO API View Source \"\"\"**neuroio-python** A Python package for interacting with the NeuroIO API \"\"\" from .clients import AsyncClient , Client __version__ : str = \"0.0.1\" __all__ = [ \"__version__\" , \"Client\" , \"AsyncClient\" ]","title":"Module neuroio"},{"location":"reference/neuroio/#sub-modules","text":"neuroio.api neuroio.auth neuroio.clients neuroio.constants neuroio.iam neuroio.utils","title":"Sub-modules"},{"location":"reference/neuroio/#variables","text":"__version__","title":"Variables"},{"location":"reference/neuroio/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/#asyncclient","text":"class AsyncClient ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class AsyncClient ( Client ) : @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM )","title":"AsyncClient"},{"location":"reference/neuroio/#ancestors-in-mro","text":"neuroio.Client","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/#instance-variables","text":"auth common_headers entries groups notifications persons settings sources spaces tokens utility whoami","title":"Instance variables"},{"location":"reference/neuroio/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/#client_settings","text":"def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] View Source def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings","title":"client_settings"},{"location":"reference/neuroio/#get_api_class_instance","text":"def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings )","title":"get_api_class_instance"},{"location":"reference/neuroio/#client","text":"class Client ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_settings = self . client_settings ( timeout = timeout , base_url = constants . API_BASE_URL ) self . iam_settings = self . client_settings ( timeout = timeout , base_url = constants . IAM_BASE_URL ) @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any, Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM )","title":"Client"},{"location":"reference/neuroio/#descendants","text":"neuroio.AsyncClient","title":"Descendants"},{"location":"reference/neuroio/#instance-variables_1","text":"auth common_headers entries groups notifications persons settings sources spaces tokens utility whoami","title":"Instance variables"},{"location":"reference/neuroio/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/#client_settings_1","text":"def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] View Source def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings","title":"client_settings"},{"location":"reference/neuroio/#get_api_class_instance_1","text":"def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings )","title":"get_api_class_instance"},{"location":"reference/neuroio/auth/","text":"Module neuroio.auth View Source import typing from httpx import Auth , Request , Response class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token : str , header_name : str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token { self . api_token } \" yield request Classes AuthorizationTokenAuth class AuthorizationTokenAuth ( api_token : str , header_name : str = None ) Describes an API Token requests authentication. View Source class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token: str , header_name: str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request: Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request Ancestors (in MRO) httpx.Auth Class variables requires_request_body requires_response_body Methods async_auth_flow def async_auth_flow ( self , request : httpx . Request ) -> AsyncGenerator [ httpx . Request , httpx . Response ] Execute the authentication flow asynchronously. By default, this defers to .auth_flow() . You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. View Source async def async_auth_flow ( self , request : Request ) -> typing . AsyncGenerator [ Request , Response ] : \"\"\" Execute the authentication flow asynchronously. By default, this defers to `.auth_flow()`. You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. \"\"\" if self . requires_request_body : await request . aread () flow = self . auth_flow ( request ) request = next ( flow ) while True : response = yield request if self . requires_response_body : await response . aread () try : request = flow . send ( response ) except StopIteration : break auth_flow def auth_flow ( self , request : httpx . Request ) -> Generator [ httpx . Request , httpx . Response , NoneType ] Execute the authentication flow. To dispatch a request, yield it: yield request The client will .send() the response back into the flow generator. You can access it like so: response = yield request A return (or reaching the end of the generator) will result in the client returning the last response obtained from the server. You can dispatch as many requests as is necessary. View Source def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ] : request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request sync_auth_flow def sync_auth_flow ( self , request : httpx . Request ) -> Generator [ httpx . Request , httpx . Response , NoneType ] Execute the authentication flow synchronously. By default, this defers to .auth_flow() . You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. View Source def sync_auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ] : \"\"\" Execute the authentication flow synchronously. By default, this defers to `.auth_flow()`. You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. \"\"\" if self . requires_request_body : request . read () flow = self . auth_flow ( request ) request = next ( flow ) while True : response = yield request if self . requires_response_body : response . read () try : request = flow . send ( response ) except StopIteration : break","title":"Auth"},{"location":"reference/neuroio/auth/#module-neuroioauth","text":"View Source import typing from httpx import Auth , Request , Response class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token : str , header_name : str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token { self . api_token } \" yield request","title":"Module neuroio.auth"},{"location":"reference/neuroio/auth/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/auth/#authorizationtokenauth","text":"class AuthorizationTokenAuth ( api_token : str , header_name : str = None ) Describes an API Token requests authentication. View Source class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token: str , header_name: str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request: Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request","title":"AuthorizationTokenAuth"},{"location":"reference/neuroio/auth/#ancestors-in-mro","text":"httpx.Auth","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/auth/#class-variables","text":"requires_request_body requires_response_body","title":"Class variables"},{"location":"reference/neuroio/auth/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/auth/#async_auth_flow","text":"def async_auth_flow ( self , request : httpx . Request ) -> AsyncGenerator [ httpx . Request , httpx . Response ] Execute the authentication flow asynchronously. By default, this defers to .auth_flow() . You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. View Source async def async_auth_flow ( self , request : Request ) -> typing . AsyncGenerator [ Request , Response ] : \"\"\" Execute the authentication flow asynchronously. By default, this defers to `.auth_flow()`. You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. \"\"\" if self . requires_request_body : await request . aread () flow = self . auth_flow ( request ) request = next ( flow ) while True : response = yield request if self . requires_response_body : await response . aread () try : request = flow . send ( response ) except StopIteration : break","title":"async_auth_flow"},{"location":"reference/neuroio/auth/#auth_flow","text":"def auth_flow ( self , request : httpx . Request ) -> Generator [ httpx . Request , httpx . Response , NoneType ] Execute the authentication flow. To dispatch a request, yield it: yield request The client will .send() the response back into the flow generator. You can access it like so: response = yield request A return (or reaching the end of the generator) will result in the client returning the last response obtained from the server. You can dispatch as many requests as is necessary. View Source def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ] : request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request","title":"auth_flow"},{"location":"reference/neuroio/auth/#sync_auth_flow","text":"def sync_auth_flow ( self , request : httpx . Request ) -> Generator [ httpx . Request , httpx . Response , NoneType ] Execute the authentication flow synchronously. By default, this defers to .auth_flow() . You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. View Source def sync_auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ] : \"\"\" Execute the authentication flow synchronously. By default, this defers to `.auth_flow()`. You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. \"\"\" if self . requires_request_body : request . read () flow = self . auth_flow ( request ) request = next ( flow ) while True : response = yield request if self . requires_response_body : response . read () try : request = flow . send ( response ) except StopIteration : break","title":"sync_auth_flow"},{"location":"reference/neuroio/clients/","text":"Module neuroio.clients View Source import enum from typing import Any , Dict , Optional from neuroio import constants from neuroio.api.base import APIBase from neuroio.auth import AuthorizationTokenAuth from neuroio.utils import cached_property , dynamic_import , get_package_version class Service ( str , enum . Enum ): API = \"api\" IAM = \"iam\" class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ): \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_settings = self . client_settings ( timeout = timeout , base_url = constants . API_BASE_URL ) self . iam_settings = self . client_settings ( timeout = timeout , base_url = constants . IAM_BASE_URL ) @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/ { get_package_version () } \" } def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ]: settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio. { service } . { namespace } .v { self . api_version } \" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM ) class AsyncClient ( Client ): @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/ { get_package_version () } \" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM ) Classes AsyncClient class AsyncClient ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class AsyncClient ( Client ) : @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM ) Ancestors (in MRO) neuroio.clients.Client Instance variables auth common_headers entries groups notifications persons settings sources spaces tokens utility whoami Methods client_settings def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] View Source def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings get_api_class_instance def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings ) Client class Client ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_settings = self . client_settings ( timeout = timeout , base_url = constants . API_BASE_URL ) self . iam_settings = self . client_settings ( timeout = timeout , base_url = constants . IAM_BASE_URL ) @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any, Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM ) Descendants neuroio.clients.AsyncClient Instance variables auth common_headers entries groups notifications persons settings sources spaces tokens utility whoami Methods client_settings def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] View Source def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings get_api_class_instance def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings ) Service class Service ( / , * args , ** kwargs ) An enumeration. View Source class Service ( str , enum . Enum ): API = \"api\" IAM = \"iam\" Ancestors (in MRO) builtins.str enum.Enum Class variables API IAM name value","title":"Clients"},{"location":"reference/neuroio/clients/#module-neuroioclients","text":"View Source import enum from typing import Any , Dict , Optional from neuroio import constants from neuroio.api.base import APIBase from neuroio.auth import AuthorizationTokenAuth from neuroio.utils import cached_property , dynamic_import , get_package_version class Service ( str , enum . Enum ): API = \"api\" IAM = \"iam\" class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ): \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_settings = self . client_settings ( timeout = timeout , base_url = constants . API_BASE_URL ) self . iam_settings = self . client_settings ( timeout = timeout , base_url = constants . IAM_BASE_URL ) @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/ { get_package_version () } \" } def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ]: settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio. { service } . { namespace } .v { self . api_version } \" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM ) class AsyncClient ( Client ): @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/ { get_package_version () } \" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM )","title":"Module neuroio.clients"},{"location":"reference/neuroio/clients/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/clients/#asyncclient","text":"class AsyncClient ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class AsyncClient ( Client ) : @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM )","title":"AsyncClient"},{"location":"reference/neuroio/clients/#ancestors-in-mro","text":"neuroio.clients.Client","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/clients/#instance-variables","text":"auth common_headers entries groups notifications persons settings sources spaces tokens utility whoami","title":"Instance variables"},{"location":"reference/neuroio/clients/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/clients/#client_settings","text":"def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] View Source def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings","title":"client_settings"},{"location":"reference/neuroio/clients/#get_api_class_instance","text":"def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings )","title":"get_api_class_instance"},{"location":"reference/neuroio/clients/#client","text":"class Client ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_settings = self . client_settings ( timeout = timeout , base_url = constants . API_BASE_URL ) self . iam_settings = self . client_settings ( timeout = timeout , base_url = constants . IAM_BASE_URL ) @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any, Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM )","title":"Client"},{"location":"reference/neuroio/clients/#descendants","text":"neuroio.clients.AsyncClient","title":"Descendants"},{"location":"reference/neuroio/clients/#instance-variables_1","text":"auth common_headers entries groups notifications persons settings sources spaces tokens utility whoami","title":"Instance variables"},{"location":"reference/neuroio/clients/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/clients/#client_settings_1","text":"def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] View Source def client_settings ( self , base_url : str , timeout : float ) -> Dict [ Any , Any ] : settings = { \"base_url\" : base_url , \"timeout\" : timeout , \"headers\" : self . common_headers , } if self . api_token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = self . api_token ) return settings","title":"client_settings"},{"location":"reference/neuroio/clients/#get_api_class_instance_1","text":"def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( settings = self . api_settings ) return cls ( settings = self . iam_settings )","title":"get_api_class_instance"},{"location":"reference/neuroio/clients/#service","text":"class Service ( / , * args , ** kwargs ) An enumeration. View Source class Service ( str , enum . Enum ): API = \"api\" IAM = \"iam\"","title":"Service"},{"location":"reference/neuroio/clients/#ancestors-in-mro_1","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/clients/#class-variables","text":"API IAM name value","title":"Class variables"},{"location":"reference/neuroio/constants/","text":"Module neuroio.constants View Source from enum import Enum API_BASE_URL : str = \"https://api.neuroio.com\" IAM_BASE_URL : str = \"https://iam.neuroio.com\" HTTP_CLIENT_TIMEOUT : float = 4.0 sentinel = object () class SourceLicense ( str , Enum ): BASIC = \"basic\" STANDARD = \"standard\" STANDARD_PLUS = \"standard+\" ADVANCED = \"advanced\" class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\" class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\" class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\" class Sex ( int , Enum ): MALE = 0 FEMALE = 1 class HttpMethod ( int , Enum ): POST = 0 GET = 1 DEFAULT_EXACT_THRESHOLD = 79.3 DEFAULT_HA_THRESHOLD = 75.5 DEFAULT_JUNK_THRESHOLD = 68.84 Variables API_BASE_URL DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD HTTP_CLIENT_TIMEOUT IAM_BASE_URL sentinel Classes EntryLiveness class EntryLiveness ( / , * args , ** kwargs ) An enumeration. View Source class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\" Ancestors (in MRO) builtins.str enum.Enum Class variables FAILED PASSED UNDETERMINED name value EntryMood class EntryMood ( / , * args , ** kwargs ) An enumeration. View Source class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\" Ancestors (in MRO) builtins.str enum.Enum Class variables ANGER CONTEMPT DET DISGUST FEAR HAPPINESS NEUTRAL NM SADNESS SURPRISE name value EntryResult class EntryResult ( / , * args , ** kwargs ) An enumeration. View Source class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\" Ancestors (in MRO) builtins.str enum.Enum Class variables DET EXACT HA JUNK NEW NM REINIT name value HttpMethod class HttpMethod ( / , * args , ** kwargs ) An enumeration. View Source class HttpMethod ( int , Enum ): POST = 0 GET = 1 Ancestors (in MRO) builtins.int enum.Enum Class variables GET POST name value Sex class Sex ( / , * args , ** kwargs ) An enumeration. View Source class Sex ( int , Enum ): MALE = 0 FEMALE = 1 Ancestors (in MRO) builtins.int enum.Enum Class variables FEMALE MALE name value SourceLicense class SourceLicense ( / , * args , ** kwargs ) An enumeration. View Source class SourceLicense ( str , Enum ): BASIC = \"basic\" STANDARD = \"standard\" STANDARD_PLUS = \"standard+\" ADVANCED = \"advanced\" Ancestors (in MRO) builtins.str enum.Enum Class variables ADVANCED BASIC STANDARD STANDARD_PLUS name value","title":"Constants"},{"location":"reference/neuroio/constants/#module-neuroioconstants","text":"View Source from enum import Enum API_BASE_URL : str = \"https://api.neuroio.com\" IAM_BASE_URL : str = \"https://iam.neuroio.com\" HTTP_CLIENT_TIMEOUT : float = 4.0 sentinel = object () class SourceLicense ( str , Enum ): BASIC = \"basic\" STANDARD = \"standard\" STANDARD_PLUS = \"standard+\" ADVANCED = \"advanced\" class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\" class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\" class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\" class Sex ( int , Enum ): MALE = 0 FEMALE = 1 class HttpMethod ( int , Enum ): POST = 0 GET = 1 DEFAULT_EXACT_THRESHOLD = 79.3 DEFAULT_HA_THRESHOLD = 75.5 DEFAULT_JUNK_THRESHOLD = 68.84","title":"Module neuroio.constants"},{"location":"reference/neuroio/constants/#variables","text":"API_BASE_URL DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD HTTP_CLIENT_TIMEOUT IAM_BASE_URL sentinel","title":"Variables"},{"location":"reference/neuroio/constants/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/constants/#entryliveness","text":"class EntryLiveness ( / , * args , ** kwargs ) An enumeration. View Source class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\"","title":"EntryLiveness"},{"location":"reference/neuroio/constants/#ancestors-in-mro","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables","text":"FAILED PASSED UNDETERMINED name value","title":"Class variables"},{"location":"reference/neuroio/constants/#entrymood","text":"class EntryMood ( / , * args , ** kwargs ) An enumeration. View Source class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\"","title":"EntryMood"},{"location":"reference/neuroio/constants/#ancestors-in-mro_1","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_1","text":"ANGER CONTEMPT DET DISGUST FEAR HAPPINESS NEUTRAL NM SADNESS SURPRISE name value","title":"Class variables"},{"location":"reference/neuroio/constants/#entryresult","text":"class EntryResult ( / , * args , ** kwargs ) An enumeration. View Source class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\"","title":"EntryResult"},{"location":"reference/neuroio/constants/#ancestors-in-mro_2","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_2","text":"DET EXACT HA JUNK NEW NM REINIT name value","title":"Class variables"},{"location":"reference/neuroio/constants/#httpmethod","text":"class HttpMethod ( / , * args , ** kwargs ) An enumeration. View Source class HttpMethod ( int , Enum ): POST = 0 GET = 1","title":"HttpMethod"},{"location":"reference/neuroio/constants/#ancestors-in-mro_3","text":"builtins.int enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_3","text":"GET POST name value","title":"Class variables"},{"location":"reference/neuroio/constants/#sex","text":"class Sex ( / , * args , ** kwargs ) An enumeration. View Source class Sex ( int , Enum ): MALE = 0 FEMALE = 1","title":"Sex"},{"location":"reference/neuroio/constants/#ancestors-in-mro_4","text":"builtins.int enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_4","text":"FEMALE MALE name value","title":"Class variables"},{"location":"reference/neuroio/constants/#sourcelicense","text":"class SourceLicense ( / , * args , ** kwargs ) An enumeration. View Source class SourceLicense ( str , Enum ): BASIC = \"basic\" STANDARD = \"standard\" STANDARD_PLUS = \"standard+\" ADVANCED = \"advanced\"","title":"SourceLicense"},{"location":"reference/neuroio/constants/#ancestors-in-mro_5","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_5","text":"ADVANCED BASIC STANDARD STANDARD_PLUS name value","title":"Class variables"},{"location":"reference/neuroio/utils/","text":"Module neuroio.utils View Source import functools from importlib import import_module from typing import Any , Callable , List , Optional , TypeVar , Union from neuroio.constants import sentinel def get_package_version () -> str : from neuroio import __version__ return __version__ def dynamic_import ( abs_path : str , attribute : str ) -> Any : \"\"\" Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute \"\"\" module_object = import_module ( abs_path ) return getattr ( module_object , attribute ) F = TypeVar ( \"F\" , bound = Callable [ ... , Any ]) def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f )) def process_query_params ( params : dict ) -> dict : for key , item in params . items (): if isinstance ( item , list ): params [ key ] = \",\" . join ( map ( str , item )) return params def request_dict_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict : inner_exclude : List [ str ] = [ \"self\" ] if exclude is not None : inner_exclude . extend ( exclude ) return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in inner_exclude , local_items . items (), ) ) def request_query_processing ( local_items : dict , exclude : Union [ List [ str ], None ] = None ) -> dict : if exclude is None : exclude = [] return process_query_params ( request_dict_processing ( local_items , exclude )) def request_form_processing ( local_items : dict , exclude : Union [ List [ str ], None ] = None ) -> dict : if exclude is None : exclude = [] return { key : str ( value ) for key , value in request_dict_processing ( local_items , exclude ) . items () } Variables F sentinel Functions cached_property def cached_property ( f : ~ F ) -> property View Source def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f )) dynamic_import def dynamic_import ( abs_path : str , attribute : str ) -> Any Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute View Source def dynamic_import ( abs_path : str , attribute : str ) -> Any : \"\"\" Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute \"\"\" module_object = import_module ( abs_path ) return getattr ( module_object , attribute ) get_package_version def get_package_version ( ) -> str View Source def get_package_version () -> str : from neuroio import __version__ return __version__ process_query_params def process_query_params ( params : dict ) -> dict View Source def process_query_params ( params : dict ) -> dict : for key , item in params . items () : if isinstance ( item , list ) : params [ key ] = \",\" . join ( map ( str , item )) return params request_dict_processing def request_dict_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_dict_processing ( local_items : dict , exclude : Optional [ List[str ] ] = None ) -> dict : inner_exclude : List [ str ] = [ \"self\" ] if exclude is not None : inner_exclude . extend ( exclude ) return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in inner_exclude , local_items . items (), ) ) request_form_processing def request_form_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_form_processing ( local_items : dict , exclude : Union [ List[str ] , None ] = None ) -> dict : if exclude is None : exclude = [] return { key : str ( value ) for key , value in request_dict_processing ( local_items , exclude ). items () } request_query_processing def request_query_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_query_processing ( local_items : dict , exclude : Union [ List[str ] , None ] = None ) -> dict : if exclude is None : exclude = [] return process_query_params ( request_dict_processing ( local_items , exclude ))","title":"Utils"},{"location":"reference/neuroio/utils/#module-neuroioutils","text":"View Source import functools from importlib import import_module from typing import Any , Callable , List , Optional , TypeVar , Union from neuroio.constants import sentinel def get_package_version () -> str : from neuroio import __version__ return __version__ def dynamic_import ( abs_path : str , attribute : str ) -> Any : \"\"\" Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute \"\"\" module_object = import_module ( abs_path ) return getattr ( module_object , attribute ) F = TypeVar ( \"F\" , bound = Callable [ ... , Any ]) def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f )) def process_query_params ( params : dict ) -> dict : for key , item in params . items (): if isinstance ( item , list ): params [ key ] = \",\" . join ( map ( str , item )) return params def request_dict_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict : inner_exclude : List [ str ] = [ \"self\" ] if exclude is not None : inner_exclude . extend ( exclude ) return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in inner_exclude , local_items . items (), ) ) def request_query_processing ( local_items : dict , exclude : Union [ List [ str ], None ] = None ) -> dict : if exclude is None : exclude = [] return process_query_params ( request_dict_processing ( local_items , exclude )) def request_form_processing ( local_items : dict , exclude : Union [ List [ str ], None ] = None ) -> dict : if exclude is None : exclude = [] return { key : str ( value ) for key , value in request_dict_processing ( local_items , exclude ) . items () }","title":"Module neuroio.utils"},{"location":"reference/neuroio/utils/#variables","text":"F sentinel","title":"Variables"},{"location":"reference/neuroio/utils/#functions","text":"","title":"Functions"},{"location":"reference/neuroio/utils/#cached_property","text":"def cached_property ( f : ~ F ) -> property View Source def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f ))","title":"cached_property"},{"location":"reference/neuroio/utils/#dynamic_import","text":"def dynamic_import ( abs_path : str , attribute : str ) -> Any Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute View Source def dynamic_import ( abs_path : str , attribute : str ) -> Any : \"\"\" Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute \"\"\" module_object = import_module ( abs_path ) return getattr ( module_object , attribute )","title":"dynamic_import"},{"location":"reference/neuroio/utils/#get_package_version","text":"def get_package_version ( ) -> str View Source def get_package_version () -> str : from neuroio import __version__ return __version__","title":"get_package_version"},{"location":"reference/neuroio/utils/#process_query_params","text":"def process_query_params ( params : dict ) -> dict View Source def process_query_params ( params : dict ) -> dict : for key , item in params . items () : if isinstance ( item , list ) : params [ key ] = \",\" . join ( map ( str , item )) return params","title":"process_query_params"},{"location":"reference/neuroio/utils/#request_dict_processing","text":"def request_dict_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_dict_processing ( local_items : dict , exclude : Optional [ List[str ] ] = None ) -> dict : inner_exclude : List [ str ] = [ \"self\" ] if exclude is not None : inner_exclude . extend ( exclude ) return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in inner_exclude , local_items . items (), ) )","title":"request_dict_processing"},{"location":"reference/neuroio/utils/#request_form_processing","text":"def request_form_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_form_processing ( local_items : dict , exclude : Union [ List[str ] , None ] = None ) -> dict : if exclude is None : exclude = [] return { key : str ( value ) for key , value in request_dict_processing ( local_items , exclude ). items () }","title":"request_form_processing"},{"location":"reference/neuroio/utils/#request_query_processing","text":"def request_query_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_query_processing ( local_items : dict , exclude : Union [ List[str ] , None ] = None ) -> dict : if exclude is None : exclude = [] return process_query_params ( request_dict_processing ( local_items , exclude ))","title":"request_query_processing"},{"location":"reference/neuroio/api/","text":"Module neuroio.api Sub-modules neuroio.api.base neuroio.api.entries neuroio.api.groups neuroio.api.notifications neuroio.api.persons neuroio.api.settings neuroio.api.sources neuroio.api.utility","title":"Index"},{"location":"reference/neuroio/api/#module-neuroioapi","text":"","title":"Module neuroio.api"},{"location":"reference/neuroio/api/#sub-modules","text":"neuroio.api.base neuroio.api.entries neuroio.api.groups neuroio.api.notifications neuroio.api.persons neuroio.api.settings neuroio.api.sources neuroio.api.utility","title":"Sub-modules"},{"location":"reference/neuroio/api/base/","text":"Module neuroio.api.base View Source import abc from httpx import AsyncClient , Client class APIBase ( abc . ABC ): def __init__ ( self , settings : dict ) -> None : self . settings = settings def get_client ( self ) -> Client : return Client ( ** self . settings ) class APIBaseAsync ( abc . ABC ): def __init__ ( self , settings : dict ) -> None : self . settings = settings def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) Classes APIBase class APIBase ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class APIBase ( abc . ABC ): def __init__ ( self , settings: dict ) -> None: self . settings = settings def get_client ( self ) -> Client: return Client (** self . settings ) Ancestors (in MRO) abc.ABC Descendants neuroio.api.entries.v1.Entries neuroio.api.groups.v1.Groups neuroio.api.notifications.v1.Notifications neuroio.api.persons.v1.Persons neuroio.api.settings.v1.Settings neuroio.api.sources.v1.Sources neuroio.api.utility.v1.Utility neuroio.iam.auth.v1.Auth neuroio.iam.spaces.v1.Spaces neuroio.iam.tokens.v1.Tokens neuroio.iam.whoami.v1.Whoami Methods get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) APIBaseAsync class APIBaseAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class APIBaseAsync ( abc . ABC ): def __init__ ( self , settings: dict ) -> None: self . settings = settings def get_client ( self ) -> AsyncClient: return AsyncClient (** self . settings ) Ancestors (in MRO) abc.ABC Descendants neuroio.api.entries.v1.EntriesAsync neuroio.api.groups.v1.GroupsAsync neuroio.api.notifications.v1.NotificationsAsync neuroio.api.persons.v1.PersonsAsync neuroio.api.settings.v1.SettingsAsync neuroio.api.sources.v1.SourcesAsync neuroio.api.utility.v1.UtilityAsync neuroio.iam.auth.v1.AuthAsync neuroio.iam.spaces.v1.SpacesAsync neuroio.iam.tokens.v1.TokensAsync neuroio.iam.whoami.v1.WhoamiAsync Methods get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"Base"},{"location":"reference/neuroio/api/base/#module-neuroioapibase","text":"View Source import abc from httpx import AsyncClient , Client class APIBase ( abc . ABC ): def __init__ ( self , settings : dict ) -> None : self . settings = settings def get_client ( self ) -> Client : return Client ( ** self . settings ) class APIBaseAsync ( abc . ABC ): def __init__ ( self , settings : dict ) -> None : self . settings = settings def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"Module neuroio.api.base"},{"location":"reference/neuroio/api/base/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/base/#apibase","text":"class APIBase ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class APIBase ( abc . ABC ): def __init__ ( self , settings: dict ) -> None: self . settings = settings def get_client ( self ) -> Client: return Client (** self . settings )","title":"APIBase"},{"location":"reference/neuroio/api/base/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/base/#descendants","text":"neuroio.api.entries.v1.Entries neuroio.api.groups.v1.Groups neuroio.api.notifications.v1.Notifications neuroio.api.persons.v1.Persons neuroio.api.settings.v1.Settings neuroio.api.sources.v1.Sources neuroio.api.utility.v1.Utility neuroio.iam.auth.v1.Auth neuroio.iam.spaces.v1.Spaces neuroio.iam.tokens.v1.Tokens neuroio.iam.whoami.v1.Whoami","title":"Descendants"},{"location":"reference/neuroio/api/base/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/base/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/base/#apibaseasync","text":"class APIBaseAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class APIBaseAsync ( abc . ABC ): def __init__ ( self , settings: dict ) -> None: self . settings = settings def get_client ( self ) -> AsyncClient: return AsyncClient (** self . settings )","title":"APIBaseAsync"},{"location":"reference/neuroio/api/base/#ancestors-in-mro_1","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/base/#descendants_1","text":"neuroio.api.entries.v1.EntriesAsync neuroio.api.groups.v1.GroupsAsync neuroio.api.notifications.v1.NotificationsAsync neuroio.api.persons.v1.PersonsAsync neuroio.api.settings.v1.SettingsAsync neuroio.api.sources.v1.SourcesAsync neuroio.api.utility.v1.UtilityAsync neuroio.iam.auth.v1.AuthAsync neuroio.iam.spaces.v1.SpacesAsync neuroio.iam.tokens.v1.TokensAsync neuroio.iam.whoami.v1.WhoamiAsync","title":"Descendants"},{"location":"reference/neuroio/api/base/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/base/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/entries/","text":"Module neuroio.api.entries Sub-modules neuroio.api.entries.v1","title":"Index"},{"location":"reference/neuroio/api/entries/#module-neuroioapientries","text":"","title":"Module neuroio.api.entries"},{"location":"reference/neuroio/api/entries/#sub-modules","text":"neuroio.api.entries.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/entries/v1/","text":"Module neuroio.api.entries.v1 View Source from datetime import datetime from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryLiveness , EntryMood , EntryResult , sentinel from neuroio.utils import request_query_processing class Entries ( APIBase ): def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = \"/v1/entries/\" , params = data ) def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/entries/stats/pid/ { pid } /\" ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/entries/ { id } /\" ) class EntriesAsync ( APIBaseAsync ): async def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = \"/v1/entries/\" , params = data ) async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/entries/stats/pid/ { pid } /\" ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/entries/ { id } /\" ) Variables sentinel Classes Entries class Entries ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Entries ( APIBase ) : def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/entries/\" , params = data ) def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/entries/{id}/\" ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/entries/{id}/\" ) get def get ( self , pid : str ) -> httpx . Response View Source def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) list def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ int , object ] = < object object at 0x1027fdd60 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x1027fdd60 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/entries/\" , params = data ) EntriesAsync class EntriesAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class EntriesAsync ( APIBaseAsync ) : async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/entries/\" , params = data ) async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/entries/{id}/\" ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/entries/{id}/\" ) get def get ( self , pid : str ) -> httpx . Response View Source async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) list def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ int , object ] = < object object at 0x1027fdd60 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x1027fdd60 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/entries/\" , params = data )","title":"V1"},{"location":"reference/neuroio/api/entries/v1/#module-neuroioapientriesv1","text":"View Source from datetime import datetime from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryLiveness , EntryMood , EntryResult , sentinel from neuroio.utils import request_query_processing class Entries ( APIBase ): def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = \"/v1/entries/\" , params = data ) def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/entries/stats/pid/ { pid } /\" ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/entries/ { id } /\" ) class EntriesAsync ( APIBaseAsync ): async def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = \"/v1/entries/\" , params = data ) async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/entries/stats/pid/ { pid } /\" ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/entries/ { id } /\" )","title":"Module neuroio.api.entries.v1"},{"location":"reference/neuroio/api/entries/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/api/entries/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/entries/v1/#entries","text":"class Entries ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Entries ( APIBase ) : def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/entries/\" , params = data ) def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/entries/{id}/\" )","title":"Entries"},{"location":"reference/neuroio/api/entries/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/entries/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/entries/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/entries/{id}/\" )","title":"delete"},{"location":"reference/neuroio/api/entries/v1/#get","text":"def get ( self , pid : str ) -> httpx . Response View Source def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" )","title":"get"},{"location":"reference/neuroio/api/entries/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/entries/v1/#list","text":"def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ int , object ] = < object object at 0x1027fdd60 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x1027fdd60 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/entries/\" , params = data )","title":"list"},{"location":"reference/neuroio/api/entries/v1/#entriesasync","text":"class EntriesAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class EntriesAsync ( APIBaseAsync ) : async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/entries/\" , params = data ) async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/entries/{id}/\" )","title":"EntriesAsync"},{"location":"reference/neuroio/api/entries/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/entries/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/entries/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/entries/{id}/\" )","title":"delete"},{"location":"reference/neuroio/api/entries/v1/#get_1","text":"def get ( self , pid : str ) -> httpx . Response View Source async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" )","title":"get"},{"location":"reference/neuroio/api/entries/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/entries/v1/#list_1","text":"def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ int , object ] = < object object at 0x1027fdd60 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x1027fdd60 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/entries/\" , params = data )","title":"list"},{"location":"reference/neuroio/api/groups/","text":"Module neuroio.api.groups Sub-modules neuroio.api.groups.v1","title":"Index"},{"location":"reference/neuroio/api/groups/#module-neuroioapigroups","text":"","title":"Module neuroio.api.groups"},{"location":"reference/neuroio/api/groups/#sub-modules","text":"neuroio.api.groups.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/groups/v1/","text":"Module neuroio.api.groups.v1 View Source from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import sentinel from neuroio.utils import request_query_processing class Groups ( APIBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/\" , json = data ) def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = \"/v1/groups/persons/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/ { id } /\" ) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/groups/persons/ { id } /\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/groups/persons/ { id } /\" ) def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/ { id } /pids/\" , params = data ) def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) class GroupsAsync ( APIBaseAsync ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/\" , json = data ) async def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = \"/v1/groups/persons/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/ { id } /\" ) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/groups/persons/ { id } /\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/groups/persons/ { id } /\" ) async def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/ { id } /pids/\" , params = data ) async def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) async def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) Variables sentinel Classes Groups class Groups ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Groups ( APIBase ) : def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/\" , json = data ) def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/groups/persons/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/{id}/\" ) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/groups/persons/{id}/\" ) def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods add def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) create def create ( self , name : str ) -> httpx . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/\" , json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/groups/persons/{id}/\" ) get def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/{id}/\" ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) list def list ( self , q : Union [ str , object ] = < object object at 0x1027fdd60 > , pids_include : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/groups/persons/\" , params = data ) persons def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) remove def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) update def update ( self , id : int , name : str ) -> httpx . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) GroupsAsync class GroupsAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class GroupsAsync ( APIBaseAsync ) : async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/\" , json = data ) async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/groups/persons/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/{id}/\" ) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/groups/persons/{id}/\" ) async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods add def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) create def create ( self , name : str ) -> httpx . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/\" , json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/groups/persons/{id}/\" ) get def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/{id}/\" ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) list def list ( self , q : Union [ str , object ] = < object object at 0x1027fdd60 > , pids_include : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/groups/persons/\" , params = data ) persons def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) remove def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) update def update ( self , id : int , name : str ) -> httpx . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data )","title":"V1"},{"location":"reference/neuroio/api/groups/v1/#module-neuroioapigroupsv1","text":"View Source from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import sentinel from neuroio.utils import request_query_processing class Groups ( APIBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/\" , json = data ) def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = \"/v1/groups/persons/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/ { id } /\" ) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/groups/persons/ { id } /\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/groups/persons/ { id } /\" ) def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/ { id } /pids/\" , params = data ) def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) class GroupsAsync ( APIBaseAsync ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/\" , json = data ) async def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = \"/v1/groups/persons/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/ { id } /\" ) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/groups/persons/ { id } /\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/groups/persons/ { id } /\" ) async def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/ { id } /pids/\" , params = data ) async def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) async def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data )","title":"Module neuroio.api.groups.v1"},{"location":"reference/neuroio/api/groups/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/api/groups/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/groups/v1/#groups","text":"class Groups ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Groups ( APIBase ) : def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/\" , json = data ) def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/groups/persons/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/{id}/\" ) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/groups/persons/{id}/\" ) def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data )","title":"Groups"},{"location":"reference/neuroio/api/groups/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/groups/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/groups/v1/#add","text":"def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/pids/\" , json = data )","title":"add"},{"location":"reference/neuroio/api/groups/v1/#create","text":"def create ( self , name : str ) -> httpx . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/groups/persons/\" , json = data )","title":"create"},{"location":"reference/neuroio/api/groups/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/groups/persons/{id}/\" )","title":"delete"},{"location":"reference/neuroio/api/groups/v1/#get","text":"def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/{id}/\" )","title":"get"},{"location":"reference/neuroio/api/groups/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/groups/v1/#list","text":"def list ( self , q : Union [ str , object ] = < object object at 0x1027fdd60 > , pids_include : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/groups/persons/\" , params = data )","title":"list"},{"location":"reference/neuroio/api/groups/v1/#persons","text":"def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data )","title":"persons"},{"location":"reference/neuroio/api/groups/v1/#remove","text":"def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data )","title":"remove"},{"location":"reference/neuroio/api/groups/v1/#update","text":"def update ( self , id : int , name : str ) -> httpx . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data )","title":"update"},{"location":"reference/neuroio/api/groups/v1/#groupsasync","text":"class GroupsAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class GroupsAsync ( APIBaseAsync ) : async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/\" , json = data ) async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/groups/persons/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/{id}/\" ) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/groups/persons/{id}/\" ) async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data )","title":"GroupsAsync"},{"location":"reference/neuroio/api/groups/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/groups/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/groups/v1/#add_1","text":"def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/pids/\" , json = data )","title":"add"},{"location":"reference/neuroio/api/groups/v1/#create_1","text":"def create ( self , name : str ) -> httpx . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/groups/persons/\" , json = data )","title":"create"},{"location":"reference/neuroio/api/groups/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/groups/persons/{id}/\" )","title":"delete"},{"location":"reference/neuroio/api/groups/v1/#get_1","text":"def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/{id}/\" )","title":"get"},{"location":"reference/neuroio/api/groups/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/groups/v1/#list_1","text":"def list ( self , q : Union [ str , object ] = < object object at 0x1027fdd60 > , pids_include : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/groups/persons/\" , params = data )","title":"list"},{"location":"reference/neuroio/api/groups/v1/#persons_1","text":"def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data )","title":"persons"},{"location":"reference/neuroio/api/groups/v1/#remove_1","text":"def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data )","title":"remove"},{"location":"reference/neuroio/api/groups/v1/#update_1","text":"def update ( self , id : int , name : str ) -> httpx . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data )","title":"update"},{"location":"reference/neuroio/api/notifications/","text":"Module neuroio.api.notifications Sub-modules neuroio.api.notifications.v1","title":"Index"},{"location":"reference/neuroio/api/notifications/#module-neuroioapinotifications","text":"","title":"Module neuroio.api.notifications"},{"location":"reference/neuroio/api/notifications/#sub-modules","text":"neuroio.api.notifications.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/notifications/v1/","text":"Module neuroio.api.notifications.v1 View Source from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , sentinel , ) from neuroio.utils import request_dict_processing , request_query_processing class Notifications ( APIBase ): def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = \"/v1/notifications/\" , json = data ) def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = \"/v1/notifications/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/notifications/ { id } /\" ) def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . patch ( url = f \"/v1/notifications/ { id } /\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/notifications/ { id } /\" ) class NotificationsAsync ( APIBaseAsync ): async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = \"/v1/notifications/\" , json = data ) async def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = \"/v1/notifications/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/notifications/ { id } /\" ) async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . patch ( url = f \"/v1/notifications/ { id } /\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/notifications/ { id } /\" ) Variables sentinel Classes Notifications class Notifications ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Notifications ( APIBase ) : def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = \"/v1/notifications/\" , json = data ) def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/notifications/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/notifications/{id}/\" ) def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/notifications/{id}/\" ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x1027fdd60 > , sources : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = \"/v1/notifications/\" , json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/notifications/{id}/\" ) get def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/notifications/{id}/\" ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) list def list ( self , q : Union [ str , object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/notifications/\" , params = data ) update def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x1027fdd60 > , sources : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) NotificationsAsync class NotificationsAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class NotificationsAsync ( APIBaseAsync ) : async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = \"/v1/notifications/\" , json = data ) async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/notifications/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/notifications/{id}/\" ) async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/notifications/{id}/\" ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x1027fdd60 > , sources : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = \"/v1/notifications/\" , json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/notifications/{id}/\" ) get def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/notifications/{id}/\" ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) list def list ( self , q : Union [ str , object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/notifications/\" , params = data ) update def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x1027fdd60 > , sources : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . patch ( url = f \"/v1/notifications/{id}/\" , json = data )","title":"V1"},{"location":"reference/neuroio/api/notifications/v1/#module-neuroioapinotificationsv1","text":"View Source from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , sentinel , ) from neuroio.utils import request_dict_processing , request_query_processing class Notifications ( APIBase ): def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = \"/v1/notifications/\" , json = data ) def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = \"/v1/notifications/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/notifications/ { id } /\" ) def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . patch ( url = f \"/v1/notifications/ { id } /\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/notifications/ { id } /\" ) class NotificationsAsync ( APIBaseAsync ): async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = \"/v1/notifications/\" , json = data ) async def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = \"/v1/notifications/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/notifications/ { id } /\" ) async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . patch ( url = f \"/v1/notifications/ { id } /\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/notifications/ { id } /\" )","title":"Module neuroio.api.notifications.v1"},{"location":"reference/neuroio/api/notifications/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/api/notifications/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/notifications/v1/#notifications","text":"class Notifications ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Notifications ( APIBase ) : def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = \"/v1/notifications/\" , json = data ) def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/notifications/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/notifications/{id}/\" ) def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/notifications/{id}/\" )","title":"Notifications"},{"location":"reference/neuroio/api/notifications/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/notifications/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/notifications/v1/#create","text":"def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x1027fdd60 > , sources : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = \"/v1/notifications/\" , json = data )","title":"create"},{"location":"reference/neuroio/api/notifications/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/notifications/{id}/\" )","title":"delete"},{"location":"reference/neuroio/api/notifications/v1/#get","text":"def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/notifications/{id}/\" )","title":"get"},{"location":"reference/neuroio/api/notifications/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/notifications/v1/#list","text":"def list ( self , q : Union [ str , object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/notifications/\" , params = data )","title":"list"},{"location":"reference/neuroio/api/notifications/v1/#update","text":"def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x1027fdd60 > , sources : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . patch ( url = f \"/v1/notifications/{id}/\" , json = data )","title":"update"},{"location":"reference/neuroio/api/notifications/v1/#notificationsasync","text":"class NotificationsAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class NotificationsAsync ( APIBaseAsync ) : async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = \"/v1/notifications/\" , json = data ) async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/notifications/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/notifications/{id}/\" ) async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/notifications/{id}/\" )","title":"NotificationsAsync"},{"location":"reference/neuroio/api/notifications/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/notifications/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/notifications/v1/#create_1","text":"def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x1027fdd60 > , sources : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = \"/v1/notifications/\" , json = data )","title":"create"},{"location":"reference/neuroio/api/notifications/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/notifications/{id}/\" )","title":"delete"},{"location":"reference/neuroio/api/notifications/v1/#get_1","text":"def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/notifications/{id}/\" )","title":"get"},{"location":"reference/neuroio/api/notifications/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/notifications/v1/#list_1","text":"def list ( self , q : Union [ str , object ] = < object object at 0x1027fdd60 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/notifications/\" , params = data )","title":"list"},{"location":"reference/neuroio/api/notifications/v1/#update_1","text":"def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x1027fdd60 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x1027fdd60 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x1027fdd60 > , age_from : Union [ int , object ] = < object object at 0x1027fdd60 > , age_to : Union [ int , object ] = < object object at 0x1027fdd60 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x1027fdd60 > , sources : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . patch ( url = f \"/v1/notifications/{id}/\" , json = data )","title":"update"},{"location":"reference/neuroio/api/persons/","text":"Module neuroio.api.persons Sub-modules neuroio.api.persons.v1","title":"Index"},{"location":"reference/neuroio/api/persons/#module-neuroioapipersons","text":"","title":"Module neuroio.api.persons"},{"location":"reference/neuroio/api/persons/#sub-modules","text":"neuroio.api.persons.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/persons/v1/","text":"Module neuroio.api.persons.v1 View Source from typing import BinaryIO , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryResult , sentinel from neuroio.utils import request_dict_processing , request_form_processing class Persons ( APIBase ): def create ( self , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } with self . get_client () as client : return client . post ( url = \"/v1/persons/\" , data = data , files = files ) def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = \"/v1/persons/entry/\" , json = data ) def reinit ( self , id : int ) -> Response : with self . get_client () as client : return client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id }) def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals ()) files = { \"image\" : image } with self . get_client () as client : return client . post ( url = f \"/v1/persons/reinit/ { pid } /\" , data = data , files = files ) def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client : return client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) def delete ( self , pid : str ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/persons/ { pid } /\" ) class PersonsAsync ( APIBaseAsync ): async def create ( self , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = \"/v1/persons/\" , data = data , files = files ) async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = \"/v1/persons/entry/\" , json = data ) async def reinit ( self , id : int ) -> Response : async with self . get_client () as client : return await client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } ) async def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = f \"/v1/persons/reinit/ { pid } /\" , data = data , files = files ) async def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client : return await client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) async def delete ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/persons/ { pid } /\" ) Variables sentinel Classes Persons class Persons ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Persons ( APIBase ): def create ( self , image: BinaryIO , source: str , facesize: Union [ int , object ] = sentinel , create_on_ha: Union [ bool , object ] = sentinel , create_on_junk: Union [ bool , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } with self . get_client () as client: return client . post ( url = \"/v1/persons/\" , data = data , files = files ) def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . post ( url = \"/v1/persons/entry/\" , json = data ) def reinit ( self , id: int ) -> Response: with self . get_client () as client: return client . post ( url = \"/v1/persons/reinit/\" , json ={ \"id\" : id }) def reinit_by_photo ( self , pid: str , image: BinaryIO , source: str , facesize: Union [ int , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , result: str = EntryResult . HA , ) -> Response: data = request_form_processing ( locals ()) files = { \"image\" : image } with self . get_client () as client: return client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) def search ( self , image: BinaryIO , identify_asm: bool = False ) -> Response: files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client: return client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) def delete ( self , pid: str ) -> Response: with self . get_client () as client: return client . delete ( url = f \"/v1/persons/{pid}/\" ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , image : < class ' BinaryIO '>, source : str , facesize : Union [ int , object ] = < object object at 0x1027fdd60 > , create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def create ( self , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } with self . get_client () as client : return client . post ( url = \"/v1/persons/\" , data = data , files = files ) create_by_entry def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . Response View Source def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = \"/v1/persons/entry/\" , json = data ) delete def delete ( self , pid : str ) -> httpx . Response View Source def delete ( self , pid : str ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/persons/{pid}/\" ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) reinit def reinit ( self , id : int ) -> httpx . Response View Source def reinit ( self , id : int ) -> Response : with self . get_client () as client : return client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id }) reinit_by_photo def reinit_by_photo ( self , pid : str , image : < class ' BinaryIO '>, source : str , facesize : Union [ int , object ] = < object object at 0x1027fdd60 > , identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals ()) files = { \"image\" : image } with self . get_client () as client : return client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) search def search ( self , image : < class ' BinaryIO '>, identify_asm : bool = False ) -> httpx . Response View Source def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client : return client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) PersonsAsync class PersonsAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class PersonsAsync ( APIBaseAsync ): async def create ( self , image: BinaryIO , source: str , facesize: Union [ int , object ] = sentinel , create_on_ha: Union [ bool , object ] = sentinel , create_on_junk: Union [ bool , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } async with self . get_client () as client: return await client . post ( url = \"/v1/persons/\" , data = data , files = files ) async def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . post ( url = \"/v1/persons/entry/\" , json = data ) async def reinit ( self , id: int ) -> Response: async with self . get_client () as client: return await client . post ( url = \"/v1/persons/reinit/\" , json ={ \"id\" : id } ) async def reinit_by_photo ( self , pid: str , image: BinaryIO , source: str , facesize: Union [ int , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , result: str = EntryResult . HA , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = { \"image\" : image } async with self . get_client () as client: return await client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) async def search ( self , image: BinaryIO , identify_asm: bool = False ) -> Response: files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client: return await client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) async def delete ( self , pid: str ) -> Response: async with self . get_client () as client: return await client . delete ( url = f \"/v1/persons/{pid}/\" ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , image : < class ' BinaryIO '>, source : str , facesize : Union [ int , object ] = < object object at 0x1027fdd60 > , create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def create ( self , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = \"/v1/persons/\" , data = data , files = files ) create_by_entry def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . Response View Source async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = \"/v1/persons/entry/\" , json = data ) delete def delete ( self , pid : str ) -> httpx . Response View Source async def delete ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/persons/{pid}/\" ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) reinit def reinit ( self , id : int ) -> httpx . Response View Source async def reinit ( self , id : int ) -> Response : async with self . get_client () as client : return await client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } ) reinit_by_photo def reinit_by_photo ( self , pid : str , image : < class ' BinaryIO '>, source : str , facesize : Union [ int , object ] = < object object at 0x1027fdd60 > , identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source async def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) search def search ( self , image : < class ' BinaryIO '>, identify_asm : bool = False ) -> httpx . Response View Source async def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client : return await client . post ( url = \"/v1/persons/search/\" , data = data , files = files )","title":"V1"},{"location":"reference/neuroio/api/persons/v1/#module-neuroioapipersonsv1","text":"View Source from typing import BinaryIO , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryResult , sentinel from neuroio.utils import request_dict_processing , request_form_processing class Persons ( APIBase ): def create ( self , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } with self . get_client () as client : return client . post ( url = \"/v1/persons/\" , data = data , files = files ) def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = \"/v1/persons/entry/\" , json = data ) def reinit ( self , id : int ) -> Response : with self . get_client () as client : return client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id }) def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals ()) files = { \"image\" : image } with self . get_client () as client : return client . post ( url = f \"/v1/persons/reinit/ { pid } /\" , data = data , files = files ) def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client : return client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) def delete ( self , pid : str ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/persons/ { pid } /\" ) class PersonsAsync ( APIBaseAsync ): async def create ( self , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = \"/v1/persons/\" , data = data , files = files ) async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = \"/v1/persons/entry/\" , json = data ) async def reinit ( self , id : int ) -> Response : async with self . get_client () as client : return await client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } ) async def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = f \"/v1/persons/reinit/ { pid } /\" , data = data , files = files ) async def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client : return await client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) async def delete ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/persons/ { pid } /\" )","title":"Module neuroio.api.persons.v1"},{"location":"reference/neuroio/api/persons/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/api/persons/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/persons/v1/#persons","text":"class Persons ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Persons ( APIBase ): def create ( self , image: BinaryIO , source: str , facesize: Union [ int , object ] = sentinel , create_on_ha: Union [ bool , object ] = sentinel , create_on_junk: Union [ bool , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } with self . get_client () as client: return client . post ( url = \"/v1/persons/\" , data = data , files = files ) def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . post ( url = \"/v1/persons/entry/\" , json = data ) def reinit ( self , id: int ) -> Response: with self . get_client () as client: return client . post ( url = \"/v1/persons/reinit/\" , json ={ \"id\" : id }) def reinit_by_photo ( self , pid: str , image: BinaryIO , source: str , facesize: Union [ int , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , result: str = EntryResult . HA , ) -> Response: data = request_form_processing ( locals ()) files = { \"image\" : image } with self . get_client () as client: return client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) def search ( self , image: BinaryIO , identify_asm: bool = False ) -> Response: files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client: return client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) def delete ( self , pid: str ) -> Response: with self . get_client () as client: return client . delete ( url = f \"/v1/persons/{pid}/\" )","title":"Persons"},{"location":"reference/neuroio/api/persons/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/persons/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/persons/v1/#create","text":"def create ( self , image : < class ' BinaryIO '>, source : str , facesize : Union [ int , object ] = < object object at 0x1027fdd60 > , create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def create ( self , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } with self . get_client () as client : return client . post ( url = \"/v1/persons/\" , data = data , files = files )","title":"create"},{"location":"reference/neuroio/api/persons/v1/#create_by_entry","text":"def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . Response View Source def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = \"/v1/persons/entry/\" , json = data )","title":"create_by_entry"},{"location":"reference/neuroio/api/persons/v1/#delete","text":"def delete ( self , pid : str ) -> httpx . Response View Source def delete ( self , pid : str ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/persons/{pid}/\" )","title":"delete"},{"location":"reference/neuroio/api/persons/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/persons/v1/#reinit","text":"def reinit ( self , id : int ) -> httpx . Response View Source def reinit ( self , id : int ) -> Response : with self . get_client () as client : return client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id })","title":"reinit"},{"location":"reference/neuroio/api/persons/v1/#reinit_by_photo","text":"def reinit_by_photo ( self , pid : str , image : < class ' BinaryIO '>, source : str , facesize : Union [ int , object ] = < object object at 0x1027fdd60 > , identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals ()) files = { \"image\" : image } with self . get_client () as client : return client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files )","title":"reinit_by_photo"},{"location":"reference/neuroio/api/persons/v1/#search","text":"def search ( self , image : < class ' BinaryIO '>, identify_asm : bool = False ) -> httpx . Response View Source def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client : return client . post ( url = \"/v1/persons/search/\" , data = data , files = files )","title":"search"},{"location":"reference/neuroio/api/persons/v1/#personsasync","text":"class PersonsAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class PersonsAsync ( APIBaseAsync ): async def create ( self , image: BinaryIO , source: str , facesize: Union [ int , object ] = sentinel , create_on_ha: Union [ bool , object ] = sentinel , create_on_junk: Union [ bool , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } async with self . get_client () as client: return await client . post ( url = \"/v1/persons/\" , data = data , files = files ) async def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . post ( url = \"/v1/persons/entry/\" , json = data ) async def reinit ( self , id: int ) -> Response: async with self . get_client () as client: return await client . post ( url = \"/v1/persons/reinit/\" , json ={ \"id\" : id } ) async def reinit_by_photo ( self , pid: str , image: BinaryIO , source: str , facesize: Union [ int , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , result: str = EntryResult . HA , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = { \"image\" : image } async with self . get_client () as client: return await client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) async def search ( self , image: BinaryIO , identify_asm: bool = False ) -> Response: files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client: return await client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) async def delete ( self , pid: str ) -> Response: async with self . get_client () as client: return await client . delete ( url = f \"/v1/persons/{pid}/\" )","title":"PersonsAsync"},{"location":"reference/neuroio/api/persons/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/persons/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/persons/v1/#create_1","text":"def create ( self , image : < class ' BinaryIO '>, source : str , facesize : Union [ int , object ] = < object object at 0x1027fdd60 > , create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def create ( self , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = \"/v1/persons/\" , data = data , files = files )","title":"create"},{"location":"reference/neuroio/api/persons/v1/#create_by_entry_1","text":"def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . Response View Source async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = \"/v1/persons/entry/\" , json = data )","title":"create_by_entry"},{"location":"reference/neuroio/api/persons/v1/#delete_1","text":"def delete ( self , pid : str ) -> httpx . Response View Source async def delete ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/persons/{pid}/\" )","title":"delete"},{"location":"reference/neuroio/api/persons/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/persons/v1/#reinit_1","text":"def reinit ( self , id : int ) -> httpx . Response View Source async def reinit ( self , id : int ) -> Response : async with self . get_client () as client : return await client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } )","title":"reinit"},{"location":"reference/neuroio/api/persons/v1/#reinit_by_photo_1","text":"def reinit_by_photo ( self , pid : str , image : < class ' BinaryIO '>, source : str , facesize : Union [ int , object ] = < object object at 0x1027fdd60 > , identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source async def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files )","title":"reinit_by_photo"},{"location":"reference/neuroio/api/persons/v1/#search_1","text":"def search ( self , image : < class ' BinaryIO '>, identify_asm : bool = False ) -> httpx . Response View Source async def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client : return await client . post ( url = \"/v1/persons/search/\" , data = data , files = files )","title":"search"},{"location":"reference/neuroio/api/settings/","text":"Module neuroio.api.settings Sub-modules neuroio.api.settings.v1","title":"Index"},{"location":"reference/neuroio/api/settings/#module-neuroioapisettings","text":"","title":"Module neuroio.api.settings"},{"location":"reference/neuroio/api/settings/#sub-modules","text":"neuroio.api.settings.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/settings/v1/","text":"Module neuroio.api.settings.v1 View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import ( DEFAULT_EXACT_THRESHOLD , DEFAULT_HA_THRESHOLD , DEFAULT_JUNK_THRESHOLD , ) from neuroio.utils import request_dict_processing class Settings ( APIBase ): def get ( self ) -> Response : with self . get_client () as client : return client . get ( url = \"/v1/settings/thresholds/\" ) def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) def reset ( self ) -> Response : with self . get_client () as client : return client . post ( url = \"/v1/settings/thresholds/reset/\" ) class SettingsAsync ( APIBaseAsync ): async def get ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = \"/v1/settings/thresholds/\" ) async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) async def reset ( self ) -> Response : async with self . get_client () as client : return await client . post ( url = \"/v1/settings/thresholds/reset/\" ) Variables DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD Classes Settings class Settings ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Settings ( APIBase ): def get ( self ) -> Response: with self . get_client () as client: return client . get ( url = \"/v1/settings/thresholds/\" ) def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) def reset ( self ) -> Response: with self . get_client () as client: return client . post ( url = \"/v1/settings/thresholds/reset/\" ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods get def get ( self ) -> httpx . Response View Source def get ( self ) -> Response : with self . get_client () as client : return client . get ( url = \"/v1/settings/thresholds/\" ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) reset def reset ( self ) -> httpx . Response View Source def reset ( self ) -> Response : with self . get_client () as client : return client . post ( url = \"/v1/settings/thresholds/reset/\" ) update def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . Response View Source def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) SettingsAsync class SettingsAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SettingsAsync ( APIBaseAsync ): async def get ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = \"/v1/settings/thresholds/\" ) async def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) async def reset ( self ) -> Response: async with self . get_client () as client: return await client . post ( url = \"/v1/settings/thresholds/reset/\" ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods get def get ( self ) -> httpx . Response View Source async def get ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = \"/v1/settings/thresholds/\" ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) reset def reset ( self ) -> httpx . Response View Source async def reset ( self ) -> Response : async with self . get_client () as client : return await client . post ( url = \"/v1/settings/thresholds/reset/\" ) update def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . Response View Source async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . patch ( url = \"/v1/settings/thresholds/\" , data = data )","title":"V1"},{"location":"reference/neuroio/api/settings/v1/#module-neuroioapisettingsv1","text":"View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import ( DEFAULT_EXACT_THRESHOLD , DEFAULT_HA_THRESHOLD , DEFAULT_JUNK_THRESHOLD , ) from neuroio.utils import request_dict_processing class Settings ( APIBase ): def get ( self ) -> Response : with self . get_client () as client : return client . get ( url = \"/v1/settings/thresholds/\" ) def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) def reset ( self ) -> Response : with self . get_client () as client : return client . post ( url = \"/v1/settings/thresholds/reset/\" ) class SettingsAsync ( APIBaseAsync ): async def get ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = \"/v1/settings/thresholds/\" ) async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) async def reset ( self ) -> Response : async with self . get_client () as client : return await client . post ( url = \"/v1/settings/thresholds/reset/\" )","title":"Module neuroio.api.settings.v1"},{"location":"reference/neuroio/api/settings/v1/#variables","text":"DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD","title":"Variables"},{"location":"reference/neuroio/api/settings/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/settings/v1/#settings","text":"class Settings ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Settings ( APIBase ): def get ( self ) -> Response: with self . get_client () as client: return client . get ( url = \"/v1/settings/thresholds/\" ) def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) def reset ( self ) -> Response: with self . get_client () as client: return client . post ( url = \"/v1/settings/thresholds/reset/\" )","title":"Settings"},{"location":"reference/neuroio/api/settings/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/settings/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/settings/v1/#get","text":"def get ( self ) -> httpx . Response View Source def get ( self ) -> Response : with self . get_client () as client : return client . get ( url = \"/v1/settings/thresholds/\" )","title":"get"},{"location":"reference/neuroio/api/settings/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/settings/v1/#reset","text":"def reset ( self ) -> httpx . Response View Source def reset ( self ) -> Response : with self . get_client () as client : return client . post ( url = \"/v1/settings/thresholds/reset/\" )","title":"reset"},{"location":"reference/neuroio/api/settings/v1/#update","text":"def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . Response View Source def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . patch ( url = \"/v1/settings/thresholds/\" , data = data )","title":"update"},{"location":"reference/neuroio/api/settings/v1/#settingsasync","text":"class SettingsAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SettingsAsync ( APIBaseAsync ): async def get ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = \"/v1/settings/thresholds/\" ) async def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) async def reset ( self ) -> Response: async with self . get_client () as client: return await client . post ( url = \"/v1/settings/thresholds/reset/\" )","title":"SettingsAsync"},{"location":"reference/neuroio/api/settings/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/settings/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/settings/v1/#get_1","text":"def get ( self ) -> httpx . Response View Source async def get ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = \"/v1/settings/thresholds/\" )","title":"get"},{"location":"reference/neuroio/api/settings/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/settings/v1/#reset_1","text":"def reset ( self ) -> httpx . Response View Source async def reset ( self ) -> Response : async with self . get_client () as client : return await client . post ( url = \"/v1/settings/thresholds/reset/\" )","title":"reset"},{"location":"reference/neuroio/api/settings/v1/#update_1","text":"def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . Response View Source async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . patch ( url = \"/v1/settings/thresholds/\" , data = data )","title":"update"},{"location":"reference/neuroio/api/sources/","text":"Module neuroio.api.sources Sub-modules neuroio.api.sources.v1","title":"Index"},{"location":"reference/neuroio/api/sources/#module-neuroioapisources","text":"","title":"Module neuroio.api.sources"},{"location":"reference/neuroio/api/sources/#sub-modules","text":"neuroio.api.sources.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/sources/v1/","text":"Module neuroio.api.sources.v1 View Source from typing import List , Optional , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import SourceLicense , sentinel from neuroio.utils import request_dict_processing , request_query_processing class Sources ( APIBase ): def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = \"/v1/sources/\" , json = data ) def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = \"/v1/sources/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/sources/ { id } /\" ) def update ( self , id : int , name : str , license_type : Union [ SourceLicense , object ] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) with self . get_client () as client : return client . patch ( url = f \"/v1/sources/ { id } /\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/sources/ { id } /\" ) class SourcesAsync ( APIBaseAsync ): async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = \"/v1/sources/\" , json = data ) async def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = \"/v1/sources/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/sources/ { id } /\" ) async def update ( self , id : int , name : str , license_type : Union [ SourceLicense , object ] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) async with self . get_client () as client : return await client . patch ( url = f \"/v1/sources/ { id } /\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/sources/ { id } /\" ) Variables sentinel Classes Sources class Sources ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Sources ( APIBase ) : def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = \"/v1/sources/\" , json = data ) def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/sources/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/sources/{id}/\" ) def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) with self . get_client () as client : return client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/sources/{id}/\" ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , name : str , license_type : neuroio . constants . SourceLicense = < SourceLicense . BASIC : 'basic' > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = \"/v1/sources/\" , json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/sources/{id}/\" ) get def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/sources/{id}/\" ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) list def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/sources/\" , params = data ) update def update ( self , id : int , name : str , license_type : Union [ neuroio . constants . SourceLicense , object ] = < object object at 0x1027fdd60 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , use_pps_time : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_persons : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) with self . get_client () as client : return client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) SourcesAsync class SourcesAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SourcesAsync ( APIBaseAsync ) : async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = \"/v1/sources/\" , json = data ) async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/sources/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/sources/{id}/\" ) async def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) async with self . get_client () as client : return await client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/sources/{id}/\" ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , name : str , license_type : neuroio . constants . SourceLicense = < SourceLicense . BASIC : 'basic' > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = \"/v1/sources/\" , json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/sources/{id}/\" ) get def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/sources/{id}/\" ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) list def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/sources/\" , params = data ) update def update ( self , id : int , name : str , license_type : Union [ neuroio . constants . SourceLicense , object ] = < object object at 0x1027fdd60 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , use_pps_time : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_persons : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) async with self . get_client () as client : return await client . patch ( url = f \"/v1/sources/{id}/\" , json = data )","title":"V1"},{"location":"reference/neuroio/api/sources/v1/#module-neuroioapisourcesv1","text":"View Source from typing import List , Optional , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import SourceLicense , sentinel from neuroio.utils import request_dict_processing , request_query_processing class Sources ( APIBase ): def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = \"/v1/sources/\" , json = data ) def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = \"/v1/sources/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/sources/ { id } /\" ) def update ( self , id : int , name : str , license_type : Union [ SourceLicense , object ] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) with self . get_client () as client : return client . patch ( url = f \"/v1/sources/ { id } /\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/sources/ { id } /\" ) class SourcesAsync ( APIBaseAsync ): async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = \"/v1/sources/\" , json = data ) async def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = \"/v1/sources/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/sources/ { id } /\" ) async def update ( self , id : int , name : str , license_type : Union [ SourceLicense , object ] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) async with self . get_client () as client : return await client . patch ( url = f \"/v1/sources/ { id } /\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/sources/ { id } /\" )","title":"Module neuroio.api.sources.v1"},{"location":"reference/neuroio/api/sources/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/api/sources/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/sources/v1/#sources","text":"class Sources ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Sources ( APIBase ) : def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = \"/v1/sources/\" , json = data ) def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/sources/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/sources/{id}/\" ) def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) with self . get_client () as client : return client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/sources/{id}/\" )","title":"Sources"},{"location":"reference/neuroio/api/sources/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/sources/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/sources/v1/#create","text":"def create ( self , name : str , license_type : neuroio . constants . SourceLicense = < SourceLicense . BASIC : 'basic' > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = \"/v1/sources/\" , json = data )","title":"create"},{"location":"reference/neuroio/api/sources/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/sources/{id}/\" )","title":"delete"},{"location":"reference/neuroio/api/sources/v1/#get","text":"def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/sources/{id}/\" )","title":"get"},{"location":"reference/neuroio/api/sources/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/sources/v1/#list","text":"def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = \"/v1/sources/\" , params = data )","title":"list"},{"location":"reference/neuroio/api/sources/v1/#update","text":"def update ( self , id : int , name : str , license_type : Union [ neuroio . constants . SourceLicense , object ] = < object object at 0x1027fdd60 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , use_pps_time : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_persons : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) with self . get_client () as client : return client . patch ( url = f \"/v1/sources/{id}/\" , json = data )","title":"update"},{"location":"reference/neuroio/api/sources/v1/#sourcesasync","text":"class SourcesAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SourcesAsync ( APIBaseAsync ) : async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = \"/v1/sources/\" , json = data ) async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/sources/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/sources/{id}/\" ) async def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) async with self . get_client () as client : return await client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/sources/{id}/\" )","title":"SourcesAsync"},{"location":"reference/neuroio/api/sources/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/sources/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/sources/v1/#create_1","text":"def create ( self , name : str , license_type : neuroio . constants . SourceLicense = < SourceLicense . BASIC : 'basic' > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = \"/v1/sources/\" , json = data )","title":"create"},{"location":"reference/neuroio/api/sources/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/sources/{id}/\" )","title":"delete"},{"location":"reference/neuroio/api/sources/v1/#get_1","text":"def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/sources/{id}/\" )","title":"get"},{"location":"reference/neuroio/api/sources/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/sources/v1/#list_1","text":"def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x1027fdd60 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = \"/v1/sources/\" , params = data )","title":"list"},{"location":"reference/neuroio/api/sources/v1/#update_1","text":"def update ( self , id : int , name : str , license_type : Union [ neuroio . constants . SourceLicense , object ] = < object object at 0x1027fdd60 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , use_pps_time : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_persons : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x1027fdd60 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x1027fdd60 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x1027fdd60 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x1027fdd60 > ) -> httpx . Response View Source async def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) async with self . get_client () as client : return await client . patch ( url = f \"/v1/sources/{id}/\" , json = data )","title":"update"},{"location":"reference/neuroio/api/utility/","text":"Module neuroio.api.utility Sub-modules neuroio.api.utility.v1","title":"Index"},{"location":"reference/neuroio/api/utility/#module-neuroioapiutility","text":"","title":"Module neuroio.api.utility"},{"location":"reference/neuroio/api/utility/#sub-modules","text":"neuroio.api.utility.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/utility/v1/","text":"Module neuroio.api.utility.v1 View Source from typing.io import BinaryIO from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryResult class Utility ( APIBase ): def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client : return client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } with self . get_client () as client : return client . post ( url = \"/v1/utility/asm/\" , files = files ) class UtilityAsync ( APIBaseAsync ): async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client : return await client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = \"/v1/utility/asm/\" , files = files ) Classes Utility class Utility ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Utility ( APIBase ): def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client: return client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } with self . get_client () as client: return client . post ( url = \"/v1/utility/asm/\" , files = files ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods asm def asm ( self , image : < class ' BinaryIO '> ) -> httpx . Response View Source def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } with self . get_client () as client : return client . post ( url = \"/v1/utility/asm/\" , files = files ) compare def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client : return client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) UtilityAsync class UtilityAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class UtilityAsync ( APIBaseAsync ): async def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client: return await client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) async def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } async with self . get_client () as client: return await client . post ( url = \"/v1/utility/asm/\" , files = files ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods asm def asm ( self , image : < class ' BinaryIO '> ) -> httpx . Response View Source async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = \"/v1/utility/asm/\" , files = files ) compare def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client : return await client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"V1"},{"location":"reference/neuroio/api/utility/v1/#module-neuroioapiutilityv1","text":"View Source from typing.io import BinaryIO from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryResult class Utility ( APIBase ): def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client : return client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } with self . get_client () as client : return client . post ( url = \"/v1/utility/asm/\" , files = files ) class UtilityAsync ( APIBaseAsync ): async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client : return await client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = \"/v1/utility/asm/\" , files = files )","title":"Module neuroio.api.utility.v1"},{"location":"reference/neuroio/api/utility/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/utility/v1/#utility","text":"class Utility ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Utility ( APIBase ): def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client: return client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } with self . get_client () as client: return client . post ( url = \"/v1/utility/asm/\" , files = files )","title":"Utility"},{"location":"reference/neuroio/api/utility/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/utility/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/utility/v1/#asm","text":"def asm ( self , image : < class ' BinaryIO '> ) -> httpx . Response View Source def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } with self . get_client () as client : return client . post ( url = \"/v1/utility/asm/\" , files = files )","title":"asm"},{"location":"reference/neuroio/api/utility/v1/#compare","text":"def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client : return client . post ( url = \"/v1/utility/compare/\" , data = data , files = files )","title":"compare"},{"location":"reference/neuroio/api/utility/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/api/utility/v1/#utilityasync","text":"class UtilityAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class UtilityAsync ( APIBaseAsync ): async def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client: return await client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) async def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } async with self . get_client () as client: return await client . post ( url = \"/v1/utility/asm/\" , files = files )","title":"UtilityAsync"},{"location":"reference/neuroio/api/utility/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/utility/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/utility/v1/#asm_1","text":"def asm ( self , image : < class ' BinaryIO '> ) -> httpx . Response View Source async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = \"/v1/utility/asm/\" , files = files )","title":"asm"},{"location":"reference/neuroio/api/utility/v1/#compare_1","text":"def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client : return await client . post ( url = \"/v1/utility/compare/\" , data = data , files = files )","title":"compare"},{"location":"reference/neuroio/api/utility/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/iam/","text":"Module neuroio.iam Sub-modules neuroio.iam.auth neuroio.iam.spaces neuroio.iam.tokens neuroio.iam.whoami","title":"Index"},{"location":"reference/neuroio/iam/#module-neuroioiam","text":"","title":"Module neuroio.iam"},{"location":"reference/neuroio/iam/#sub-modules","text":"neuroio.iam.auth neuroio.iam.spaces neuroio.iam.tokens neuroio.iam.whoami","title":"Sub-modules"},{"location":"reference/neuroio/iam/auth/","text":"Module neuroio.iam.auth Sub-modules neuroio.iam.auth.v1","title":"Index"},{"location":"reference/neuroio/iam/auth/#module-neuroioiamauth","text":"","title":"Module neuroio.iam.auth"},{"location":"reference/neuroio/iam/auth/#sub-modules","text":"neuroio.iam.auth.v1","title":"Sub-modules"},{"location":"reference/neuroio/iam/auth/v1/","text":"Module neuroio.iam.auth.v1 View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Auth ( APIBase ): def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } with self . get_client () as client : return client . post ( url = \"/v1/auth/token/\" , json = data ) def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client : return client . post ( url = \"/v1/auth/password/change/\" , json = data ) class AuthAsync ( APIBaseAsync ): async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } async with self . get_client () as client : return await client . post ( url = \"/v1/auth/token/\" , json = data ) async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client : return await client . post ( url = \"/v1/auth/password/change/\" , json = data ) Classes Auth class Auth ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Auth ( APIBase ): def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } with self . get_client () as client: return client . post ( url = \"/v1/auth/token/\" , json = data ) def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client: return client . post ( url = \"/v1/auth/password/change/\" , json = data ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) login def login ( self , username : str , password : str ) -> httpx . Response View Source def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } with self . get_client () as client : return client . post ( url = \"/v1/auth/token/\" , json = data ) password_change def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . Response View Source def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client : return client . post ( url = \"/v1/auth/password/change/\" , json = data ) AuthAsync class AuthAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class AuthAsync ( APIBaseAsync ): async def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } async with self . get_client () as client: return await client . post ( url = \"/v1/auth/token/\" , json = data ) async def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client: return await client . post ( url = \"/v1/auth/password/change/\" , json = data ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) login def login ( self , username : str , password : str ) -> httpx . Response View Source async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } async with self . get_client () as client : return await client . post ( url = \"/v1/auth/token/\" , json = data ) password_change def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . Response View Source async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client : return await client . post ( url = \"/v1/auth/password/change/\" , json = data )","title":"V1"},{"location":"reference/neuroio/iam/auth/v1/#module-neuroioiamauthv1","text":"View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Auth ( APIBase ): def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } with self . get_client () as client : return client . post ( url = \"/v1/auth/token/\" , json = data ) def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client : return client . post ( url = \"/v1/auth/password/change/\" , json = data ) class AuthAsync ( APIBaseAsync ): async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } async with self . get_client () as client : return await client . post ( url = \"/v1/auth/token/\" , json = data ) async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client : return await client . post ( url = \"/v1/auth/password/change/\" , json = data )","title":"Module neuroio.iam.auth.v1"},{"location":"reference/neuroio/iam/auth/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/iam/auth/v1/#auth","text":"class Auth ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Auth ( APIBase ): def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } with self . get_client () as client: return client . post ( url = \"/v1/auth/token/\" , json = data ) def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client: return client . post ( url = \"/v1/auth/password/change/\" , json = data )","title":"Auth"},{"location":"reference/neuroio/iam/auth/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/auth/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/iam/auth/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/iam/auth/v1/#login","text":"def login ( self , username : str , password : str ) -> httpx . Response View Source def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } with self . get_client () as client : return client . post ( url = \"/v1/auth/token/\" , json = data )","title":"login"},{"location":"reference/neuroio/iam/auth/v1/#password_change","text":"def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . Response View Source def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client : return client . post ( url = \"/v1/auth/password/change/\" , json = data )","title":"password_change"},{"location":"reference/neuroio/iam/auth/v1/#authasync","text":"class AuthAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class AuthAsync ( APIBaseAsync ): async def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } async with self . get_client () as client: return await client . post ( url = \"/v1/auth/token/\" , json = data ) async def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client: return await client . post ( url = \"/v1/auth/password/change/\" , json = data )","title":"AuthAsync"},{"location":"reference/neuroio/iam/auth/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/auth/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/iam/auth/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/iam/auth/v1/#login_1","text":"def login ( self , username : str , password : str ) -> httpx . Response View Source async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } async with self . get_client () as client : return await client . post ( url = \"/v1/auth/token/\" , json = data )","title":"login"},{"location":"reference/neuroio/iam/auth/v1/#password_change_1","text":"def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . Response View Source async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client : return await client . post ( url = \"/v1/auth/password/change/\" , json = data )","title":"password_change"},{"location":"reference/neuroio/iam/spaces/","text":"Module neuroio.iam.spaces Sub-modules neuroio.iam.spaces.v1","title":"Index"},{"location":"reference/neuroio/iam/spaces/#module-neuroioiamspaces","text":"","title":"Module neuroio.iam.spaces"},{"location":"reference/neuroio/iam/spaces/#sub-modules","text":"neuroio.iam.spaces.v1","title":"Sub-modules"},{"location":"reference/neuroio/iam/spaces/v1/","text":"Module neuroio.iam.spaces.v1 View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Spaces ( APIBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/spaces/\" , json = data ) def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = \"/v1/spaces/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/spaces/ { id } /\" ) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/spaces/ { id } /\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/spaces/ { id } /\" ) def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = f \"/v1/spaces/ { id } /tokens/\" , json = data ) class SpacesAsync ( APIBaseAsync ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/spaces/\" , json = data ) async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = \"/v1/spaces/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/spaces/ { id } /\" ) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/spaces/ { id } /\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/spaces/ { id } /\" ) async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = f \"/v1/spaces/ { id } /tokens/\" , json = data ) Classes Spaces class Spaces ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Spaces ( APIBase ): def create ( self , name: str ) -> Response: data = { \"name\" : name } with self . get_client () as client: return client . post ( url = \"/v1/spaces/\" , json = data ) def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } with self . get_client () as client: return client . get ( url = \"/v1/spaces/\" , params = data ) def get ( self , id: int ) -> Response: with self . get_client () as client: return client . get ( url = f \"/v1/spaces/{id}/\" ) def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } with self . get_client () as client: return client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) def delete ( self , id: int ) -> Response: with self . get_client () as client: return client . delete ( url = f \"/v1/spaces/{id}/\" ) def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } with self . get_client () as client: return client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , name : str ) -> httpx . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/spaces/\" , json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/spaces/{id}/\" ) get def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/spaces/{id}/\" ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) list def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = \"/v1/spaces/\" , params = data ) token def token ( self , id : int , permanent : bool = False ) -> httpx . Response View Source def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) update def update ( self , id : int , name : str ) -> httpx . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) SpacesAsync class SpacesAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SpacesAsync ( APIBaseAsync ): async def create ( self , name: str ) -> Response: data = { \"name\" : name } async with self . get_client () as client: return await client . post ( url = \"/v1/spaces/\" , json = data ) async def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = \"/v1/spaces/\" , params = data ) async def get ( self , id: int ) -> Response: async with self . get_client () as client: return await client . get ( url = f \"/v1/spaces/{id}/\" ) async def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } async with self . get_client () as client: return await client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) async def delete ( self , id: int ) -> Response: async with self . get_client () as client: return await client . delete ( url = f \"/v1/spaces/{id}/\" ) async def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } async with self . get_client () as client: return await client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , name : str ) -> httpx . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/spaces/\" , json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/spaces/{id}/\" ) get def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/spaces/{id}/\" ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) list def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = \"/v1/spaces/\" , params = data ) token def token ( self , id : int , permanent : bool = False ) -> httpx . Response View Source async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) update def update ( self , id : int , name : str ) -> httpx . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/spaces/{id}/\" , json = data )","title":"V1"},{"location":"reference/neuroio/iam/spaces/v1/#module-neuroioiamspacesv1","text":"View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Spaces ( APIBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/spaces/\" , json = data ) def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = \"/v1/spaces/\" , params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/spaces/ { id } /\" ) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/spaces/ { id } /\" , json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/spaces/ { id } /\" ) def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = f \"/v1/spaces/ { id } /tokens/\" , json = data ) class SpacesAsync ( APIBaseAsync ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/spaces/\" , json = data ) async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = \"/v1/spaces/\" , params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/spaces/ { id } /\" ) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/spaces/ { id } /\" , json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/spaces/ { id } /\" ) async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = f \"/v1/spaces/ { id } /tokens/\" , json = data )","title":"Module neuroio.iam.spaces.v1"},{"location":"reference/neuroio/iam/spaces/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/iam/spaces/v1/#spaces","text":"class Spaces ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Spaces ( APIBase ): def create ( self , name: str ) -> Response: data = { \"name\" : name } with self . get_client () as client: return client . post ( url = \"/v1/spaces/\" , json = data ) def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } with self . get_client () as client: return client . get ( url = \"/v1/spaces/\" , params = data ) def get ( self , id: int ) -> Response: with self . get_client () as client: return client . get ( url = f \"/v1/spaces/{id}/\" ) def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } with self . get_client () as client: return client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) def delete ( self , id: int ) -> Response: with self . get_client () as client: return client . delete ( url = f \"/v1/spaces/{id}/\" ) def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } with self . get_client () as client: return client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data )","title":"Spaces"},{"location":"reference/neuroio/iam/spaces/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/spaces/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/iam/spaces/v1/#create","text":"def create ( self , name : str ) -> httpx . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = \"/v1/spaces/\" , json = data )","title":"create"},{"location":"reference/neuroio/iam/spaces/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/spaces/{id}/\" )","title":"delete"},{"location":"reference/neuroio/iam/spaces/v1/#get","text":"def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/spaces/{id}/\" )","title":"get"},{"location":"reference/neuroio/iam/spaces/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/iam/spaces/v1/#list","text":"def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = \"/v1/spaces/\" , params = data )","title":"list"},{"location":"reference/neuroio/iam/spaces/v1/#token","text":"def token ( self , id : int , permanent : bool = False ) -> httpx . Response View Source def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data )","title":"token"},{"location":"reference/neuroio/iam/spaces/v1/#update","text":"def update ( self , id : int , name : str ) -> httpx . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = f \"/v1/spaces/{id}/\" , json = data )","title":"update"},{"location":"reference/neuroio/iam/spaces/v1/#spacesasync","text":"class SpacesAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SpacesAsync ( APIBaseAsync ): async def create ( self , name: str ) -> Response: data = { \"name\" : name } async with self . get_client () as client: return await client . post ( url = \"/v1/spaces/\" , json = data ) async def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = \"/v1/spaces/\" , params = data ) async def get ( self , id: int ) -> Response: async with self . get_client () as client: return await client . get ( url = f \"/v1/spaces/{id}/\" ) async def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } async with self . get_client () as client: return await client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) async def delete ( self , id: int ) -> Response: async with self . get_client () as client: return await client . delete ( url = f \"/v1/spaces/{id}/\" ) async def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } async with self . get_client () as client: return await client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data )","title":"SpacesAsync"},{"location":"reference/neuroio/iam/spaces/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/spaces/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/iam/spaces/v1/#create_1","text":"def create ( self , name : str ) -> httpx . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = \"/v1/spaces/\" , json = data )","title":"create"},{"location":"reference/neuroio/iam/spaces/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/spaces/{id}/\" )","title":"delete"},{"location":"reference/neuroio/iam/spaces/v1/#get_1","text":"def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/spaces/{id}/\" )","title":"get"},{"location":"reference/neuroio/iam/spaces/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/iam/spaces/v1/#list_1","text":"def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = \"/v1/spaces/\" , params = data )","title":"list"},{"location":"reference/neuroio/iam/spaces/v1/#token_1","text":"def token ( self , id : int , permanent : bool = False ) -> httpx . Response View Source async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data )","title":"token"},{"location":"reference/neuroio/iam/spaces/v1/#update_1","text":"def update ( self , id : int , name : str ) -> httpx . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = f \"/v1/spaces/{id}/\" , json = data )","title":"update"},{"location":"reference/neuroio/iam/tokens/","text":"Module neuroio.iam.tokens Sub-modules neuroio.iam.tokens.v1","title":"Index"},{"location":"reference/neuroio/iam/tokens/#module-neuroioiamtokens","text":"","title":"Module neuroio.iam.tokens"},{"location":"reference/neuroio/iam/tokens/#sub-modules","text":"neuroio.iam.tokens.v1","title":"Sub-modules"},{"location":"reference/neuroio/iam/tokens/v1/","text":"Module neuroio.iam.tokens.v1 View Source from typing import Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Tokens ( APIBase ): def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = \"/v1/tokens/\" , json = data ) def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = \"/v1/tokens/\" , params = data ) def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/tokens/ { token_id_or_key } /\" ) def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = f \"/v1/tokens/ { token_id_or_key } /\" , data = { \"is_active\" : is_active }, ) def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = \"/v1/tokens/\" , params = data ) def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/tokens/ { token_id_or_key } /\" ) class TokensAsync ( APIBaseAsync ): async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = \"/v1/tokens/\" , json = data ) async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = \"/v1/tokens/\" , params = data ) async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/tokens/ { token_id_or_key } /\" ) async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = f \"/v1/tokens/ { token_id_or_key } /\" , data = { \"is_active\" : is_active }, ) async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = \"/v1/tokens/\" , params = data ) async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/tokens/ { token_id_or_key } /\" ) Classes Tokens class Tokens ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Tokens ( APIBase ): def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } with self . get_client () as client: return client . post ( url = \"/v1/tokens/\" , json = data ) def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client: return client . get ( url = \"/v1/tokens/\" , params = data ) def get ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: with self . get_client () as client: return client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data ={ \"is_active\" : is_active }, ) def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client: return client . delete ( url = \"/v1/tokens/\" , params = data ) def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , permanent : bool = False ) -> httpx . Response View Source def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = \"/v1/tokens/\" , json = data ) delete def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) delete_list def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = \"/v1/tokens/\" , params = data ) get def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) list def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = \"/v1/tokens/\" , params = data ) update def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active }, ) TokensAsync class TokensAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class TokensAsync ( APIBaseAsync ): async def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } async with self . get_client () as client: return await client . post ( url = \"/v1/tokens/\" , json = data ) async def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = \"/v1/tokens/\" , params = data ) async def get ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) async def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: async with self . get_client () as client: return await client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data ={ \"is_active\" : is_active }, ) async def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client: return await client . delete ( url = \"/v1/tokens/\" , params = data ) async def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , permanent : bool = False ) -> httpx . Response View Source async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = \"/v1/tokens/\" , json = data ) delete def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) delete_list def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = \"/v1/tokens/\" , params = data ) get def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) list def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = \"/v1/tokens/\" , params = data ) update def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active }, )","title":"V1"},{"location":"reference/neuroio/iam/tokens/v1/#module-neuroioiamtokensv1","text":"View Source from typing import Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Tokens ( APIBase ): def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = \"/v1/tokens/\" , json = data ) def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = \"/v1/tokens/\" , params = data ) def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/tokens/ { token_id_or_key } /\" ) def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = f \"/v1/tokens/ { token_id_or_key } /\" , data = { \"is_active\" : is_active }, ) def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = \"/v1/tokens/\" , params = data ) def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/tokens/ { token_id_or_key } /\" ) class TokensAsync ( APIBaseAsync ): async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = \"/v1/tokens/\" , json = data ) async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = \"/v1/tokens/\" , params = data ) async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/tokens/ { token_id_or_key } /\" ) async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = f \"/v1/tokens/ { token_id_or_key } /\" , data = { \"is_active\" : is_active }, ) async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = \"/v1/tokens/\" , params = data ) async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/tokens/ { token_id_or_key } /\" )","title":"Module neuroio.iam.tokens.v1"},{"location":"reference/neuroio/iam/tokens/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/iam/tokens/v1/#tokens","text":"class Tokens ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Tokens ( APIBase ): def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } with self . get_client () as client: return client . post ( url = \"/v1/tokens/\" , json = data ) def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client: return client . get ( url = \"/v1/tokens/\" , params = data ) def get ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: with self . get_client () as client: return client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data ={ \"is_active\" : is_active }, ) def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client: return client . delete ( url = \"/v1/tokens/\" , params = data ) def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" )","title":"Tokens"},{"location":"reference/neuroio/iam/tokens/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/tokens/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/iam/tokens/v1/#create","text":"def create ( self , permanent : bool = False ) -> httpx . Response View Source def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = \"/v1/tokens/\" , json = data )","title":"create"},{"location":"reference/neuroio/iam/tokens/v1/#delete","text":"def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" )","title":"delete"},{"location":"reference/neuroio/iam/tokens/v1/#delete_list","text":"def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = \"/v1/tokens/\" , params = data )","title":"delete_list"},{"location":"reference/neuroio/iam/tokens/v1/#get","text":"def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" )","title":"get"},{"location":"reference/neuroio/iam/tokens/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/iam/tokens/v1/#list","text":"def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = \"/v1/tokens/\" , params = data )","title":"list"},{"location":"reference/neuroio/iam/tokens/v1/#update","text":"def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active }, )","title":"update"},{"location":"reference/neuroio/iam/tokens/v1/#tokensasync","text":"class TokensAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class TokensAsync ( APIBaseAsync ): async def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } async with self . get_client () as client: return await client . post ( url = \"/v1/tokens/\" , json = data ) async def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = \"/v1/tokens/\" , params = data ) async def get ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) async def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: async with self . get_client () as client: return await client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data ={ \"is_active\" : is_active }, ) async def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client: return await client . delete ( url = \"/v1/tokens/\" , params = data ) async def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" )","title":"TokensAsync"},{"location":"reference/neuroio/iam/tokens/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/tokens/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/iam/tokens/v1/#create_1","text":"def create ( self , permanent : bool = False ) -> httpx . Response View Source async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = \"/v1/tokens/\" , json = data )","title":"create"},{"location":"reference/neuroio/iam/tokens/v1/#delete_1","text":"def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" )","title":"delete"},{"location":"reference/neuroio/iam/tokens/v1/#delete_list_1","text":"def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = \"/v1/tokens/\" , params = data )","title":"delete_list"},{"location":"reference/neuroio/iam/tokens/v1/#get_1","text":"def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" )","title":"get"},{"location":"reference/neuroio/iam/tokens/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/iam/tokens/v1/#list_1","text":"def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = \"/v1/tokens/\" , params = data )","title":"list"},{"location":"reference/neuroio/iam/tokens/v1/#update_1","text":"def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active }, )","title":"update"},{"location":"reference/neuroio/iam/whoami/","text":"Module neuroio.iam.whoami Sub-modules neuroio.iam.whoami.v1","title":"Index"},{"location":"reference/neuroio/iam/whoami/#module-neuroioiamwhoami","text":"","title":"Module neuroio.iam.whoami"},{"location":"reference/neuroio/iam/whoami/#sub-modules","text":"neuroio.iam.whoami.v1","title":"Sub-modules"},{"location":"reference/neuroio/iam/whoami/v1/","text":"Module neuroio.iam.whoami.v1 View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Whoami ( APIBase ): def me ( self ) -> Response : with self . get_client () as client : return client . get ( url = \"/v1/whoami/\" ) class WhoamiAsync ( APIBaseAsync ): async def me ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = \"/v1/whoami/\" ) Classes Whoami class Whoami ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Whoami ( APIBase ): def me ( self ) -> Response: with self . get_client () as client: return client . get ( url = \"/v1/whoami/\" ) Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) me def me ( self ) -> httpx . Response View Source def me ( self ) -> Response : with self . get_client () as client : return client . get ( url = \"/v1/whoami/\" ) WhoamiAsync class WhoamiAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class WhoamiAsync ( APIBaseAsync ): async def me ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = \"/v1/whoami/\" ) Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) me def me ( self ) -> httpx . Response View Source async def me ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = \"/v1/whoami/\" )","title":"V1"},{"location":"reference/neuroio/iam/whoami/v1/#module-neuroioiamwhoamiv1","text":"View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Whoami ( APIBase ): def me ( self ) -> Response : with self . get_client () as client : return client . get ( url = \"/v1/whoami/\" ) class WhoamiAsync ( APIBaseAsync ): async def me ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = \"/v1/whoami/\" )","title":"Module neuroio.iam.whoami.v1"},{"location":"reference/neuroio/iam/whoami/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/iam/whoami/v1/#whoami","text":"class Whoami ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Whoami ( APIBase ): def me ( self ) -> Response: with self . get_client () as client: return client . get ( url = \"/v1/whoami/\" )","title":"Whoami"},{"location":"reference/neuroio/iam/whoami/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/whoami/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/iam/whoami/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/iam/whoami/v1/#me","text":"def me ( self ) -> httpx . Response View Source def me ( self ) -> Response : with self . get_client () as client : return client . get ( url = \"/v1/whoami/\" )","title":"me"},{"location":"reference/neuroio/iam/whoami/v1/#whoamiasync","text":"class WhoamiAsync ( settings : dict ) Helper class that provides a standard way to create an ABC using inheritance. View Source class WhoamiAsync ( APIBaseAsync ): async def me ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = \"/v1/whoami/\" )","title":"WhoamiAsync"},{"location":"reference/neuroio/iam/whoami/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/whoami/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/iam/whoami/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/iam/whoami/v1/#me_1","text":"def me ( self ) -> httpx . Response View Source async def me ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = \"/v1/whoami/\" )","title":"me"}]}