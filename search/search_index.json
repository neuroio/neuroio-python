{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"neuroio-python Read Latest Documentation - Browse GitHub Code Repository neuroio-python A Python package for interacting with NeuroIO API","title":"Home"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of neuroio-python simply run: pip3 install neuroio-python OR poetry add neuroio-python OR pipenv install neuroio-python Changelog 1.0.0 - TBD Initial API stable release.","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of neuroio-python simply run: pip3 install neuroio-python OR poetry add neuroio-python OR pipenv install neuroio-python","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#100-tbd","text":"Initial API stable release.","title":"1.0.0 - TBD"},{"location":"docs/","text":"neuroio-python A Python package for interacting with NeuroIO API Contributing: * Guide * Guide * Guide * Guide","title":"Index"},{"location":"docs/#neuroio-python","text":"","title":"neuroio-python"},{"location":"docs/#a-python-package-for-interacting-with-neuroio-api","text":"Contributing: * Guide * Guide * Guide * Guide","title":"A Python package for interacting with NeuroIO API"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to neuroio-python Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting neuroio-python set up for local development The first step when contributing to any project is getting it set up on your local machine. neuroio-python aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/neuroio-python.git cd neuroio-python poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the coding standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by neuroio-python contributors like you . Thank you!","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-neuroio-python","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to neuroio-python"},{"location":"docs/contributing/1.-contributing-guide/#getting-neuroio-python-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. neuroio-python aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/neuroio-python.git cd neuroio-python poetry install","title":"Getting neuroio-python set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the coding standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by neuroio-python contributors like you . Thank you!","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"Introduction This document gives coding conventions for the code in this repository. Optionally, projects that use this package are encouraged to follow this document and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. Descriptive Variable names Naming things is hard. This project has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to this project should be formatted using Black and isort. Black should be run with the line length set to 79, and isort with Black compatible settings in place. Automated Code Linting All code submitted should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the code in this repository. Optionally, projects that use this package are encouraged to follow this document and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. This project has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to this project should be formatted using Black and isort. Black should be run with the line length set to 79, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"Abstract Defines the Code of Conduct for this and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here For answers to common questions about this code of conduct, see","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for this and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here For answers to common questions about this code of conduct, see","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Lev Rubel (@levchik) Notable Bug Reporters - Code Contributors - Documenters - A sincere thanks to everyone who helps make neuroio-python into a great project! ~Lev Rubel","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Lev Rubel (@levchik)","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"-","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"- A sincere thanks to everyone who helps make neuroio-python into a great project! ~Lev Rubel","title":"Documenters"},{"location":"reference/neuroio/","text":"Module neuroio neuroio-python A Python package for interacting with the NeuroIO API View Source \"\"\"**neuroio-python** A Python package for interacting with the NeuroIO API \"\"\" from .clients import AsyncClient , Client __version__ : str = \"0.0.1\" __all__ = [ \"__version__\" , \"Client\" , \"AsyncClient\" ] Sub-modules neuroio.api neuroio.auth neuroio.clients neuroio.constants neuroio.iam neuroio.utils Variables __version__ Classes AsyncClient class AsyncClient ( api_token : Union [ str , NoneType ] = None , api_version : int = 1 , timeout : Union [ float , NoneType ] = None ) View Source class AsyncClient ( Client ) : @property def httpx_client_class ( self , ) -> Union [ Type[httpx.Client ] , Type [ httpx.AsyncClient ] ]: return httpx . AsyncClient @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM ) Ancestors (in MRO) neuroio.Client Instance variables auth common_headers entries groups httpx_client_class notifications persons settings sources spaces tokens utility whoami Methods get_api_class_instance def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) inject_api_token def inject_api_token ( self , api_token : Union [ str , NoneType ] = None ) -> None View Source def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) Client class Client ( api_token : Union [ str , NoneType ] = None , api_version : int = 1 , timeout : Union [ float , NoneType ] = None ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : Optional [ float ] = None , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_client = self . httpx_client_class ( base_url = constants . API_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . iam_client = self . httpx_client_class ( base_url = constants . IAM_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . inject_api_token () @property def httpx_client_class ( self , ) -> Union [ Type[httpx.Client ] , Type [ httpx.AsyncClient ] ]: return httpx . Client @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM ) Descendants neuroio.AsyncClient Instance variables auth common_headers entries groups httpx_client_class notifications persons settings sources spaces tokens utility whoami Methods get_api_class_instance def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) inject_api_token def inject_api_token ( self , api_token : Union [ str , NoneType ] = None ) -> None View Source def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token )","title":"Index"},{"location":"reference/neuroio/#module-neuroio","text":"neuroio-python A Python package for interacting with the NeuroIO API View Source \"\"\"**neuroio-python** A Python package for interacting with the NeuroIO API \"\"\" from .clients import AsyncClient , Client __version__ : str = \"0.0.1\" __all__ = [ \"__version__\" , \"Client\" , \"AsyncClient\" ]","title":"Module neuroio"},{"location":"reference/neuroio/#sub-modules","text":"neuroio.api neuroio.auth neuroio.clients neuroio.constants neuroio.iam neuroio.utils","title":"Sub-modules"},{"location":"reference/neuroio/#variables","text":"__version__","title":"Variables"},{"location":"reference/neuroio/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/#asyncclient","text":"class AsyncClient ( api_token : Union [ str , NoneType ] = None , api_version : int = 1 , timeout : Union [ float , NoneType ] = None ) View Source class AsyncClient ( Client ) : @property def httpx_client_class ( self , ) -> Union [ Type[httpx.Client ] , Type [ httpx.AsyncClient ] ]: return httpx . AsyncClient @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM )","title":"AsyncClient"},{"location":"reference/neuroio/#ancestors-in-mro","text":"neuroio.Client","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/#instance-variables","text":"auth common_headers entries groups httpx_client_class notifications persons settings sources spaces tokens utility whoami","title":"Instance variables"},{"location":"reference/neuroio/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/#get_api_class_instance","text":"def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client )","title":"get_api_class_instance"},{"location":"reference/neuroio/#inject_api_token","text":"def inject_api_token ( self , api_token : Union [ str , NoneType ] = None ) -> None View Source def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token )","title":"inject_api_token"},{"location":"reference/neuroio/#client","text":"class Client ( api_token : Union [ str , NoneType ] = None , api_version : int = 1 , timeout : Union [ float , NoneType ] = None ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : Optional [ float ] = None , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_client = self . httpx_client_class ( base_url = constants . API_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . iam_client = self . httpx_client_class ( base_url = constants . IAM_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . inject_api_token () @property def httpx_client_class ( self , ) -> Union [ Type[httpx.Client ] , Type [ httpx.AsyncClient ] ]: return httpx . Client @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM )","title":"Client"},{"location":"reference/neuroio/#descendants","text":"neuroio.AsyncClient","title":"Descendants"},{"location":"reference/neuroio/#instance-variables_1","text":"auth common_headers entries groups httpx_client_class notifications persons settings sources spaces tokens utility whoami","title":"Instance variables"},{"location":"reference/neuroio/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/#get_api_class_instance_1","text":"def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client )","title":"get_api_class_instance"},{"location":"reference/neuroio/#inject_api_token_1","text":"def inject_api_token ( self , api_token : Union [ str , NoneType ] = None ) -> None View Source def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token )","title":"inject_api_token"},{"location":"reference/neuroio/auth/","text":"Module neuroio.auth View Source import typing from httpx import Auth , Request , Response class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token : str , header_name : str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request Classes AuthorizationTokenAuth class AuthorizationTokenAuth ( api_token : str , header_name : str = None ) Describes an API Token requests authentication. View Source class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token: str , header_name: str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request: Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request Ancestors (in MRO) httpx._auth.Auth Class variables requires_request_body requires_response_body Methods auth_flow def auth_flow ( self , request : httpx . _models . Request ) -> Generator [ httpx . _models . Request , httpx . _models . Response , NoneType ] Execute the authentication flow. To dispatch a request, yield it: yield request The client will .send() the response back into the flow generator. You can access it like so: response = yield request A return (or reaching the end of the generator) will result in the client returning the last response obtained from the server. You can dispatch as many requests as is necessary. View Source def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request","title":"Auth"},{"location":"reference/neuroio/auth/#module-neuroioauth","text":"View Source import typing from httpx import Auth , Request , Response class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token : str , header_name : str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request","title":"Module neuroio.auth"},{"location":"reference/neuroio/auth/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/auth/#authorizationtokenauth","text":"class AuthorizationTokenAuth ( api_token : str , header_name : str = None ) Describes an API Token requests authentication. View Source class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token: str , header_name: str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request: Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request","title":"AuthorizationTokenAuth"},{"location":"reference/neuroio/auth/#ancestors-in-mro","text":"httpx._auth.Auth","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/auth/#class-variables","text":"requires_request_body requires_response_body","title":"Class variables"},{"location":"reference/neuroio/auth/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/auth/#auth_flow","text":"def auth_flow ( self , request : httpx . _models . Request ) -> Generator [ httpx . _models . Request , httpx . _models . Response , NoneType ] Execute the authentication flow. To dispatch a request, yield it: yield request The client will .send() the response back into the flow generator. You can access it like so: response = yield request A return (or reaching the end of the generator) will result in the client returning the last response obtained from the server. You can dispatch as many requests as is necessary. View Source def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request","title":"auth_flow"},{"location":"reference/neuroio/clients/","text":"Module neuroio.clients View Source import enum from typing import Optional , Type , Union import httpx from neuroio import constants from neuroio.api.base import APIBase from neuroio.auth import AuthorizationTokenAuth from neuroio.utils import cached_property , dynamic_import , get_package_version class Service ( str , enum . Enum ): API = \"api\" IAM = \"iam\" class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : Optional [ float ] = None , ): \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_client = self . httpx_client_class ( base_url = constants . API_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . iam_client = self . httpx_client_class ( base_url = constants . IAM_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . inject_api_token () @property def httpx_client_class ( self , ) -> Union [ Type [ httpx . Client ], Type [ httpx . AsyncClient ]]: return httpx . Client @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM ) class AsyncClient ( Client ): @property def httpx_client_class ( self , ) -> Union [ Type [ httpx . Client ], Type [ httpx . AsyncClient ]]: return httpx . AsyncClient @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM ) Classes AsyncClient class AsyncClient ( api_token : Union [ str , NoneType ] = None , api_version : int = 1 , timeout : Union [ float , NoneType ] = None ) View Source class AsyncClient ( Client ) : @property def httpx_client_class ( self , ) -> Union [ Type[httpx.Client ] , Type [ httpx.AsyncClient ] ]: return httpx . AsyncClient @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM ) Ancestors (in MRO) neuroio.clients.Client Instance variables auth common_headers entries groups httpx_client_class notifications persons settings sources spaces tokens utility whoami Methods get_api_class_instance def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) inject_api_token def inject_api_token ( self , api_token : Union [ str , NoneType ] = None ) -> None View Source def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) Client class Client ( api_token : Union [ str , NoneType ] = None , api_version : int = 1 , timeout : Union [ float , NoneType ] = None ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : Optional [ float ] = None , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_client = self . httpx_client_class ( base_url = constants . API_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . iam_client = self . httpx_client_class ( base_url = constants . IAM_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . inject_api_token () @property def httpx_client_class ( self , ) -> Union [ Type[httpx.Client ] , Type [ httpx.AsyncClient ] ]: return httpx . Client @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM ) Descendants neuroio.clients.AsyncClient Instance variables auth common_headers entries groups httpx_client_class notifications persons settings sources spaces tokens utility whoami Methods get_api_class_instance def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) inject_api_token def inject_api_token ( self , api_token : Union [ str , NoneType ] = None ) -> None View Source def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) Service class Service ( / , * args , ** kwargs ) An enumeration. View Source class Service ( str , enum . Enum ): API = \"api\" IAM = \"iam\" Ancestors (in MRO) builtins.str enum.Enum Class variables API IAM name value","title":"Clients"},{"location":"reference/neuroio/clients/#module-neuroioclients","text":"View Source import enum from typing import Optional , Type , Union import httpx from neuroio import constants from neuroio.api.base import APIBase from neuroio.auth import AuthorizationTokenAuth from neuroio.utils import cached_property , dynamic_import , get_package_version class Service ( str , enum . Enum ): API = \"api\" IAM = \"iam\" class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : Optional [ float ] = None , ): \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_client = self . httpx_client_class ( base_url = constants . API_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . iam_client = self . httpx_client_class ( base_url = constants . IAM_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . inject_api_token () @property def httpx_client_class ( self , ) -> Union [ Type [ httpx . Client ], Type [ httpx . AsyncClient ]]: return httpx . Client @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM ) class AsyncClient ( Client ): @property def httpx_client_class ( self , ) -> Union [ Type [ httpx . Client ], Type [ httpx . AsyncClient ]]: return httpx . AsyncClient @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM )","title":"Module neuroio.clients"},{"location":"reference/neuroio/clients/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/clients/#asyncclient","text":"class AsyncClient ( api_token : Union [ str , NoneType ] = None , api_version : int = 1 , timeout : Union [ float , NoneType ] = None ) View Source class AsyncClient ( Client ) : @property def httpx_client_class ( self , ) -> Union [ Type[httpx.Client ] , Type [ httpx.AsyncClient ] ]: return httpx . AsyncClient @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-async-python/{get_package_version()}\" } @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"AuthAsync\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"SourcesAsync\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"EntriesAsync\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"UtilityAsync\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"SettingsAsync\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"GroupsAsync\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"PersonsAsync\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"NotificationsAsync\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"SpacesAsync\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"WhoamiAsync\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"TokensAsync\" , service = Service . IAM )","title":"AsyncClient"},{"location":"reference/neuroio/clients/#ancestors-in-mro","text":"neuroio.clients.Client","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/clients/#instance-variables","text":"auth common_headers entries groups httpx_client_class notifications persons settings sources spaces tokens utility whoami","title":"Instance variables"},{"location":"reference/neuroio/clients/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/clients/#get_api_class_instance","text":"def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client )","title":"get_api_class_instance"},{"location":"reference/neuroio/clients/#inject_api_token","text":"def inject_api_token ( self , api_token : Union [ str , NoneType ] = None ) -> None View Source def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token )","title":"inject_api_token"},{"location":"reference/neuroio/clients/#client","text":"class Client ( api_token : Union [ str , NoneType ] = None , api_version : int = 1 , timeout : Union [ float , NoneType ] = None ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : Optional [ float ] = None , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_token = api_token self . api_version = api_version self . api_client = self . httpx_client_class ( base_url = constants . API_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . iam_client = self . httpx_client_class ( base_url = constants . IAM_BASE_URL , headers = self . common_headers , timeout = timeout or constants . HTTP_CLIENT_TIMEOUT , ) self . inject_api_token () @property def httpx_client_class ( self , ) -> Union [ Type[httpx.Client ] , Type [ httpx.AsyncClient ] ]: return httpx . Client @property def common_headers ( self ) -> dict : return { \"User-Agent\" : f \"neuroio-python/{get_package_version()}\" } def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client ) @cached_property def auth ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"auth\" , clsname = \"Auth\" , service = Service . IAM ) @cached_property def sources ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"sources\" , clsname = \"Sources\" ) @cached_property def entries ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"entries\" , clsname = \"Entries\" ) @cached_property def utility ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"utility\" , clsname = \"Utility\" ) @cached_property def settings ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"settings\" , clsname = \"Settings\" ) @cached_property def groups ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"groups\" , clsname = \"Groups\" ) @cached_property def persons ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"persons\" , clsname = \"Persons\" ) @cached_property def notifications ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"notifications\" , clsname = \"Notifications\" ) @cached_property def spaces ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"spaces\" , clsname = \"Spaces\" , service = Service . IAM ) @cached_property def whoami ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"whoami\" , clsname = \"Whoami\" , service = Service . IAM ) @cached_property def tokens ( self ) -> APIBase : return self . get_api_class_instance ( namespace = \"tokens\" , clsname = \"Tokens\" , service = Service . IAM )","title":"Client"},{"location":"reference/neuroio/clients/#descendants","text":"neuroio.clients.AsyncClient","title":"Descendants"},{"location":"reference/neuroio/clients/#instance-variables_1","text":"auth common_headers entries groups httpx_client_class notifications persons settings sources spaces tokens utility whoami","title":"Instance variables"},{"location":"reference/neuroio/clients/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/clients/#get_api_class_instance_1","text":"def get_api_class_instance ( self , namespace : str , clsname : str , service : neuroio . clients . Service = < Service . API : 'api' > ) -> neuroio . api . base . APIBase View Source def get_api_class_instance ( self , namespace : str , clsname : str , service : Service = Service . API ) -> APIBase : abs_path = f \"neuroio.{service}.{namespace}.v{self.api_version}\" cls = dynamic_import ( abs_path = abs_path , attribute = clsname ) if service == Service . API : return cls ( client = self . api_client ) return cls ( client = self . iam_client )","title":"get_api_class_instance"},{"location":"reference/neuroio/clients/#inject_api_token_1","text":"def inject_api_token ( self , api_token : Union [ str , NoneType ] = None ) -> None View Source def inject_api_token ( self , api_token : Optional [ str ] = None ) -> None : # Override api token only if provided api_token is not empty or None if api_token : self . api_token = api_token # Injecting auth only if api_token is not empty or None if self . api_token : self . api_client . auth = AuthorizationTokenAuth ( api_token = self . api_token ) self . iam_client . auth = AuthorizationTokenAuth ( api_token = self . api_token )","title":"inject_api_token"},{"location":"reference/neuroio/clients/#service","text":"class Service ( / , * args , ** kwargs ) An enumeration. View Source class Service ( str , enum . Enum ): API = \"api\" IAM = \"iam\"","title":"Service"},{"location":"reference/neuroio/clients/#ancestors-in-mro_1","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/clients/#class-variables","text":"API IAM name value","title":"Class variables"},{"location":"reference/neuroio/constants/","text":"Module neuroio.constants View Source from enum import Enum API_BASE_URL : str = \"https://api.neuroio.com\" IAM_BASE_URL : str = \"https://iam.neuroio.com\" HTTP_CLIENT_TIMEOUT : float = 4.0 sentinel = object () class SourceLicense ( str , Enum ): BASIC = \"basic\" STANDARD = \"standard\" STANDARD_PLUS = \"standard+\" ADVANCED = \"advanced\" class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\" class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\" class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\" class Sex ( int , Enum ): MALE = 0 FEMALE = 1 class HttpMethod ( int , Enum ): POST = 0 GET = 1 DEFAULT_EXACT_THRESHOLD = 79.3 DEFAULT_HA_THRESHOLD = 75.5 DEFAULT_JUNK_THRESHOLD = 68.84 Variables API_BASE_URL DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD HTTP_CLIENT_TIMEOUT IAM_BASE_URL sentinel Classes EntryLiveness class EntryLiveness ( / , * args , ** kwargs ) An enumeration. View Source class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\" Ancestors (in MRO) builtins.str enum.Enum Class variables FAILED PASSED UNDETERMINED name value EntryMood class EntryMood ( / , * args , ** kwargs ) An enumeration. View Source class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\" Ancestors (in MRO) builtins.str enum.Enum Class variables ANGER CONTEMPT DET DISGUST FEAR HAPPINESS NEUTRAL NM SADNESS SURPRISE name value EntryResult class EntryResult ( / , * args , ** kwargs ) An enumeration. View Source class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\" Ancestors (in MRO) builtins.str enum.Enum Class variables DET EXACT HA JUNK NEW NM REINIT name value HttpMethod class HttpMethod ( / , * args , ** kwargs ) An enumeration. View Source class HttpMethod ( int , Enum ): POST = 0 GET = 1 Ancestors (in MRO) builtins.int enum.Enum Class variables GET POST name value Sex class Sex ( / , * args , ** kwargs ) An enumeration. View Source class Sex ( int , Enum ): MALE = 0 FEMALE = 1 Ancestors (in MRO) builtins.int enum.Enum Class variables FEMALE MALE name value SourceLicense class SourceLicense ( / , * args , ** kwargs ) An enumeration. View Source class SourceLicense ( str , Enum ): BASIC = \"basic\" STANDARD = \"standard\" STANDARD_PLUS = \"standard+\" ADVANCED = \"advanced\" Ancestors (in MRO) builtins.str enum.Enum Class variables ADVANCED BASIC STANDARD STANDARD_PLUS name value","title":"Constants"},{"location":"reference/neuroio/constants/#module-neuroioconstants","text":"View Source from enum import Enum API_BASE_URL : str = \"https://api.neuroio.com\" IAM_BASE_URL : str = \"https://iam.neuroio.com\" HTTP_CLIENT_TIMEOUT : float = 4.0 sentinel = object () class SourceLicense ( str , Enum ): BASIC = \"basic\" STANDARD = \"standard\" STANDARD_PLUS = \"standard+\" ADVANCED = \"advanced\" class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\" class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\" class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\" class Sex ( int , Enum ): MALE = 0 FEMALE = 1 class HttpMethod ( int , Enum ): POST = 0 GET = 1 DEFAULT_EXACT_THRESHOLD = 79.3 DEFAULT_HA_THRESHOLD = 75.5 DEFAULT_JUNK_THRESHOLD = 68.84","title":"Module neuroio.constants"},{"location":"reference/neuroio/constants/#variables","text":"API_BASE_URL DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD HTTP_CLIENT_TIMEOUT IAM_BASE_URL sentinel","title":"Variables"},{"location":"reference/neuroio/constants/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/constants/#entryliveness","text":"class EntryLiveness ( / , * args , ** kwargs ) An enumeration. View Source class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\"","title":"EntryLiveness"},{"location":"reference/neuroio/constants/#ancestors-in-mro","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables","text":"FAILED PASSED UNDETERMINED name value","title":"Class variables"},{"location":"reference/neuroio/constants/#entrymood","text":"class EntryMood ( / , * args , ** kwargs ) An enumeration. View Source class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\"","title":"EntryMood"},{"location":"reference/neuroio/constants/#ancestors-in-mro_1","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_1","text":"ANGER CONTEMPT DET DISGUST FEAR HAPPINESS NEUTRAL NM SADNESS SURPRISE name value","title":"Class variables"},{"location":"reference/neuroio/constants/#entryresult","text":"class EntryResult ( / , * args , ** kwargs ) An enumeration. View Source class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\"","title":"EntryResult"},{"location":"reference/neuroio/constants/#ancestors-in-mro_2","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_2","text":"DET EXACT HA JUNK NEW NM REINIT name value","title":"Class variables"},{"location":"reference/neuroio/constants/#httpmethod","text":"class HttpMethod ( / , * args , ** kwargs ) An enumeration. View Source class HttpMethod ( int , Enum ): POST = 0 GET = 1","title":"HttpMethod"},{"location":"reference/neuroio/constants/#ancestors-in-mro_3","text":"builtins.int enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_3","text":"GET POST name value","title":"Class variables"},{"location":"reference/neuroio/constants/#sex","text":"class Sex ( / , * args , ** kwargs ) An enumeration. View Source class Sex ( int , Enum ): MALE = 0 FEMALE = 1","title":"Sex"},{"location":"reference/neuroio/constants/#ancestors-in-mro_4","text":"builtins.int enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_4","text":"FEMALE MALE name value","title":"Class variables"},{"location":"reference/neuroio/constants/#sourcelicense","text":"class SourceLicense ( / , * args , ** kwargs ) An enumeration. View Source class SourceLicense ( str , Enum ): BASIC = \"basic\" STANDARD = \"standard\" STANDARD_PLUS = \"standard+\" ADVANCED = \"advanced\"","title":"SourceLicense"},{"location":"reference/neuroio/constants/#ancestors-in-mro_5","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_5","text":"ADVANCED BASIC STANDARD STANDARD_PLUS name value","title":"Class variables"},{"location":"reference/neuroio/utils/","text":"Module neuroio.utils View Source import functools from importlib import import_module from typing import Any , Callable , List , Optional , TypeVar , Union from neuroio.constants import sentinel def get_package_version () -> str : from neuroio import __version__ return __version__ def dynamic_import ( abs_path : str , attribute : str ) -> Any : \"\"\" Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute \"\"\" module_object = import_module ( abs_path ) return getattr ( module_object , attribute ) F = TypeVar ( \"F\" , bound = Callable [ ... , Any ]) def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f )) def process_query_params ( params : dict ) -> dict : for key , item in params . items (): if isinstance ( item , list ): params [ key ] = \",\" . join ( map ( str , item )) return params def request_dict_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict : return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in reserved_names , local_items . items (), ) ) def request_query_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict : return process_query_params ( request_dict_processing ( local_items , reserved_names ) ) Variables F sentinel Functions cached_property def cached_property ( f : ~ F ) -> property View Source def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f )) dynamic_import def dynamic_import ( abs_path : str , attribute : str ) -> Any Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute View Source def dynamic_import ( abs_path : str , attribute : str ) -> Any : \"\"\" Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute \"\"\" module_object = import_module ( abs_path ) return getattr ( module_object , attribute ) get_package_version def get_package_version ( ) -> str View Source def get_package_version () -> str : from neuroio import __version__ return __version__ process_query_params def process_query_params ( params : dict ) -> dict View Source def process_query_params ( params : dict ) -> dict : for key , item in params . items () : if isinstance ( item , list ) : params [ key ] = \",\" . join ( map ( str , item )) return params request_dict_processing def request_dict_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict View Source def request_dict_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict : return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in reserved_names , local_items . items (), ) ) request_query_processing def request_query_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict View Source def request_query_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict : return process_query_params ( request_dict_processing ( local_items , reserved_names ) )","title":"Utils"},{"location":"reference/neuroio/utils/#module-neuroioutils","text":"View Source import functools from importlib import import_module from typing import Any , Callable , List , Optional , TypeVar , Union from neuroio.constants import sentinel def get_package_version () -> str : from neuroio import __version__ return __version__ def dynamic_import ( abs_path : str , attribute : str ) -> Any : \"\"\" Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute \"\"\" module_object = import_module ( abs_path ) return getattr ( module_object , attribute ) F = TypeVar ( \"F\" , bound = Callable [ ... , Any ]) def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f )) def process_query_params ( params : dict ) -> dict : for key , item in params . items (): if isinstance ( item , list ): params [ key ] = \",\" . join ( map ( str , item )) return params def request_dict_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict : return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in reserved_names , local_items . items (), ) ) def request_query_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict : return process_query_params ( request_dict_processing ( local_items , reserved_names ) )","title":"Module neuroio.utils"},{"location":"reference/neuroio/utils/#variables","text":"F sentinel","title":"Variables"},{"location":"reference/neuroio/utils/#functions","text":"","title":"Functions"},{"location":"reference/neuroio/utils/#cached_property","text":"def cached_property ( f : ~ F ) -> property View Source def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f ))","title":"cached_property"},{"location":"reference/neuroio/utils/#dynamic_import","text":"def dynamic_import ( abs_path : str , attribute : str ) -> Any Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute View Source def dynamic_import ( abs_path : str , attribute : str ) -> Any : \"\"\" Imports any attribute from the module specified as string dotted path. Takes into account current supplied version to the Client instance. :param abs_path: dotted path of the module from which to import from :param attribute: function, class or any other attr to be imported :return: imported attribute \"\"\" module_object = import_module ( abs_path ) return getattr ( module_object , attribute )","title":"dynamic_import"},{"location":"reference/neuroio/utils/#get_package_version","text":"def get_package_version ( ) -> str View Source def get_package_version () -> str : from neuroio import __version__ return __version__","title":"get_package_version"},{"location":"reference/neuroio/utils/#process_query_params","text":"def process_query_params ( params : dict ) -> dict View Source def process_query_params ( params : dict ) -> dict : for key , item in params . items () : if isinstance ( item , list ) : params [ key ] = \",\" . join ( map ( str , item )) return params","title":"process_query_params"},{"location":"reference/neuroio/utils/#request_dict_processing","text":"def request_dict_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict View Source def request_dict_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict : return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in reserved_names , local_items . items (), ) )","title":"request_dict_processing"},{"location":"reference/neuroio/utils/#request_query_processing","text":"def request_query_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict View Source def request_query_processing ( local_items : dict , reserved_names : List [ str ] ) -> dict : return process_query_params ( request_dict_processing ( local_items , reserved_names ) )","title":"request_query_processing"},{"location":"reference/neuroio/api/","text":"Module neuroio.api Sub-modules neuroio.api.base neuroio.api.entries neuroio.api.groups neuroio.api.notifications neuroio.api.persons neuroio.api.settings neuroio.api.sources neuroio.api.utility","title":"Index"},{"location":"reference/neuroio/api/#module-neuroioapi","text":"","title":"Module neuroio.api"},{"location":"reference/neuroio/api/#sub-modules","text":"neuroio.api.base neuroio.api.entries neuroio.api.groups neuroio.api.notifications neuroio.api.persons neuroio.api.settings neuroio.api.sources neuroio.api.utility","title":"Sub-modules"},{"location":"reference/neuroio/api/base/","text":"Module neuroio.api.base View Source import abc import httpx class APIBase ( abc . ABC ): def __init__ ( self , client : httpx . Client ) -> None : self . client = client class APIBaseAsync ( abc . ABC ): def __init__ ( self , client : httpx . AsyncClient ) -> None : self . client = client Classes APIBase class APIBase ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class APIBase ( abc . ABC ): def __init__ ( self , client: httpx . Client ) -> None: self . client = client Ancestors (in MRO) abc.ABC Descendants neuroio.api.entries.v1.Entries neuroio.api.groups.v1.Groups neuroio.api.notifications.v1.Notifications neuroio.api.persons.v1.Persons neuroio.api.settings.v1.Settings neuroio.api.sources.v1.Sources neuroio.api.utility.v1.Utility neuroio.iam.auth.v1.Auth neuroio.iam.spaces.v1.Spaces neuroio.iam.tokens.v1.Tokens neuroio.iam.whoami.v1.Whoami APIBaseAsync class APIBaseAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class APIBaseAsync ( abc . ABC ): def __init__ ( self , client: httpx . AsyncClient ) -> None: self . client = client Ancestors (in MRO) abc.ABC Descendants neuroio.api.entries.v1.EntriesAsync neuroio.api.groups.v1.GroupsAsync neuroio.api.notifications.v1.NotificationsAsync neuroio.api.persons.v1.PersonsAsync neuroio.api.settings.v1.SettingsAsync neuroio.api.sources.v1.SourcesAsync neuroio.api.utility.v1.UtilityAsync neuroio.iam.auth.v1.AuthAsync neuroio.iam.spaces.v1.SpacesAsync neuroio.iam.tokens.v1.TokensAsync neuroio.iam.whoami.v1.WhoamiAsync","title":"Base"},{"location":"reference/neuroio/api/base/#module-neuroioapibase","text":"View Source import abc import httpx class APIBase ( abc . ABC ): def __init__ ( self , client : httpx . Client ) -> None : self . client = client class APIBaseAsync ( abc . ABC ): def __init__ ( self , client : httpx . AsyncClient ) -> None : self . client = client","title":"Module neuroio.api.base"},{"location":"reference/neuroio/api/base/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/base/#apibase","text":"class APIBase ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class APIBase ( abc . ABC ): def __init__ ( self , client: httpx . Client ) -> None: self . client = client","title":"APIBase"},{"location":"reference/neuroio/api/base/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/base/#descendants","text":"neuroio.api.entries.v1.Entries neuroio.api.groups.v1.Groups neuroio.api.notifications.v1.Notifications neuroio.api.persons.v1.Persons neuroio.api.settings.v1.Settings neuroio.api.sources.v1.Sources neuroio.api.utility.v1.Utility neuroio.iam.auth.v1.Auth neuroio.iam.spaces.v1.Spaces neuroio.iam.tokens.v1.Tokens neuroio.iam.whoami.v1.Whoami","title":"Descendants"},{"location":"reference/neuroio/api/base/#apibaseasync","text":"class APIBaseAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class APIBaseAsync ( abc . ABC ): def __init__ ( self , client: httpx . AsyncClient ) -> None: self . client = client","title":"APIBaseAsync"},{"location":"reference/neuroio/api/base/#ancestors-in-mro_1","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/base/#descendants_1","text":"neuroio.api.entries.v1.EntriesAsync neuroio.api.groups.v1.GroupsAsync neuroio.api.notifications.v1.NotificationsAsync neuroio.api.persons.v1.PersonsAsync neuroio.api.settings.v1.SettingsAsync neuroio.api.sources.v1.SourcesAsync neuroio.api.utility.v1.UtilityAsync neuroio.iam.auth.v1.AuthAsync neuroio.iam.spaces.v1.SpacesAsync neuroio.iam.tokens.v1.TokensAsync neuroio.iam.whoami.v1.WhoamiAsync","title":"Descendants"},{"location":"reference/neuroio/api/entries/","text":"Module neuroio.api.entries Sub-modules neuroio.api.entries.v1","title":"Index"},{"location":"reference/neuroio/api/entries/#module-neuroioapientries","text":"","title":"Module neuroio.api.entries"},{"location":"reference/neuroio/api/entries/#sub-modules","text":"neuroio.api.entries.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/entries/v1/","text":"Module neuroio.api.entries.v1 View Source from datetime import datetime from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryLiveness , EntryMood , EntryResult , sentinel from neuroio.utils import request_query_processing class Entries ( APIBase ): def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return self . client . get ( url = \"/v1/entries/\" , params = data ) finally : self . client . close () def get ( self , pid : str ) -> Response : try : return self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : self . client . close () def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : self . client . close () class EntriesAsync ( APIBaseAsync ): async def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return await self . client . get ( url = \"/v1/entries/\" , params = data ) finally : await self . client . aclose () async def get ( self , pid : str ) -> Response : try : return await self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : await self . client . aclose () async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : await self . client . aclose () Variables sentinel Classes Entries class Entries ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Entries ( APIBase ) : def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/entries/\" , params = data ) finally : self . client . close () def get ( self , pid : str ) -> Response : try : return self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : self . client . close () def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods delete def delete ( self , pid : str ) -> httpx . _models . Response View Source def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : self . client . close () get def get ( self , pid : str ) -> httpx . _models . Response View Source def get ( self , pid : str ) -> Response : try : return self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : self . client . close () list def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ int , object ] = < object object at 0x10b7673c0 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x10b7673c0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/entries/\" , params = data ) finally : self . client . close () EntriesAsync class EntriesAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class EntriesAsync ( APIBaseAsync ) : async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/entries/\" , params = data ) finally : await self . client . aclose () async def get ( self , pid : str ) -> Response : try : return await self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : await self . client . aclose () async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods delete def delete ( self , pid : str ) -> httpx . _models . Response View Source async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : await self . client . aclose () get def get ( self , pid : str ) -> httpx . _models . Response View Source async def get ( self , pid : str ) -> Response : try : return await self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : await self . client . aclose () list def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ int , object ] = < object object at 0x10b7673c0 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x10b7673c0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/entries/\" , params = data ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/api/entries/v1/#module-neuroioapientriesv1","text":"View Source from datetime import datetime from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryLiveness , EntryMood , EntryResult , sentinel from neuroio.utils import request_query_processing class Entries ( APIBase ): def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return self . client . get ( url = \"/v1/entries/\" , params = data ) finally : self . client . close () def get ( self , pid : str ) -> Response : try : return self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : self . client . close () def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : self . client . close () class EntriesAsync ( APIBaseAsync ): async def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return await self . client . get ( url = \"/v1/entries/\" , params = data ) finally : await self . client . aclose () async def get ( self , pid : str ) -> Response : try : return await self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : await self . client . aclose () async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : await self . client . aclose ()","title":"Module neuroio.api.entries.v1"},{"location":"reference/neuroio/api/entries/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/api/entries/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/entries/v1/#entries","text":"class Entries ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Entries ( APIBase ) : def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/entries/\" , params = data ) finally : self . client . close () def get ( self , pid : str ) -> Response : try : return self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : self . client . close () def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : self . client . close ()","title":"Entries"},{"location":"reference/neuroio/api/entries/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/entries/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/entries/v1/#delete","text":"def delete ( self , pid : str ) -> httpx . _models . Response View Source def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : self . client . close ()","title":"delete"},{"location":"reference/neuroio/api/entries/v1/#get","text":"def get ( self , pid : str ) -> httpx . _models . Response View Source def get ( self , pid : str ) -> Response : try : return self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : self . client . close ()","title":"get"},{"location":"reference/neuroio/api/entries/v1/#list","text":"def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ int , object ] = < object object at 0x10b7673c0 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x10b7673c0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/entries/\" , params = data ) finally : self . client . close ()","title":"list"},{"location":"reference/neuroio/api/entries/v1/#entriesasync","text":"class EntriesAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class EntriesAsync ( APIBaseAsync ) : async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/entries/\" , params = data ) finally : await self . client . aclose () async def get ( self , pid : str ) -> Response : try : return await self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : await self . client . aclose () async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : await self . client . aclose ()","title":"EntriesAsync"},{"location":"reference/neuroio/api/entries/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/entries/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/entries/v1/#delete_1","text":"def delete ( self , pid : str ) -> httpx . _models . Response View Source async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/entries/{pid}/\" ) finally : await self . client . aclose ()","title":"delete"},{"location":"reference/neuroio/api/entries/v1/#get_1","text":"def get ( self , pid : str ) -> httpx . _models . Response View Source async def get ( self , pid : str ) -> Response : try : return await self . client . get ( url = f \"/v1/entries/stats/pid/{pid}/\" ) finally : await self . client . aclose ()","title":"get"},{"location":"reference/neuroio/api/entries/v1/#list_1","text":"def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ int , object ] = < object object at 0x10b7673c0 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x10b7673c0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/entries/\" , params = data ) finally : await self . client . aclose ()","title":"list"},{"location":"reference/neuroio/api/groups/","text":"Module neuroio.api.groups Sub-modules neuroio.api.groups.v1","title":"Index"},{"location":"reference/neuroio/api/groups/#module-neuroioapigroups","text":"","title":"Module neuroio.api.groups"},{"location":"reference/neuroio/api/groups/#sub-modules","text":"neuroio.api.groups.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/groups/v1/","text":"Module neuroio.api.groups.v1 View Source from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import sentinel from neuroio.utils import request_query_processing class Groups ( APIBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : self . client . close () def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) try : return self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : self . client . close () def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close () def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close () class GroupsAsync ( APIBaseAsync ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return await self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () async def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : await self . client . aclose () async def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose () async def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose () Variables sentinel Classes Groups class Groups ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Groups ( APIBase ) : def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : self . client . close () def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) try : return self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : self . client . close () def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close () def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods add def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . _models . Response View Source def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close () create def create ( self , name : str ) -> httpx . _models . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : self . client . close () delete def delete ( self , id : int ) -> httpx . _models . Response View Source def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () get def get ( self , id : int ) -> httpx . _models . Response View Source def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () list def list ( self , q : Union [ str , object ] = < object object at 0x10b7673c0 > , pids_include : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : self . client . close () persons def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) try : return self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : self . client . close () remove def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . _models . Response View Source def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close () update def update ( self , id : int , name : str ) -> httpx . _models . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : self . client . close () GroupsAsync class GroupsAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class GroupsAsync ( APIBaseAsync ) : async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : await self . client . aclose () async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose () async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods add def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . _models . Response View Source async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose () create def create ( self , name : str ) -> httpx . _models . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : await self . client . aclose () delete def delete ( self , id : int ) -> httpx . _models . Response View Source async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () get def get ( self , id : int ) -> httpx . _models . Response View Source async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () list def list ( self , q : Union [ str , object ] = < object object at 0x10b7673c0 > , pids_include : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : await self . client . aclose () persons def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : await self . client . aclose () remove def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . _models . Response View Source async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose () update def update ( self , id : int , name : str ) -> httpx . _models . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/api/groups/v1/#module-neuroioapigroupsv1","text":"View Source from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import sentinel from neuroio.utils import request_query_processing class Groups ( APIBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : self . client . close () def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) try : return self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : self . client . close () def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close () def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close () class GroupsAsync ( APIBaseAsync ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return await self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () async def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : await self . client . aclose () async def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose () async def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose ()","title":"Module neuroio.api.groups.v1"},{"location":"reference/neuroio/api/groups/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/api/groups/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/groups/v1/#groups","text":"class Groups ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Groups ( APIBase ) : def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : self . client . close () def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close () def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) try : return self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : self . client . close () def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close () def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close ()","title":"Groups"},{"location":"reference/neuroio/api/groups/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/groups/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/groups/v1/#add","text":"def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . _models . Response View Source def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close ()","title":"add"},{"location":"reference/neuroio/api/groups/v1/#create","text":"def create ( self , name : str ) -> httpx . _models . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : self . client . close ()","title":"create"},{"location":"reference/neuroio/api/groups/v1/#delete","text":"def delete ( self , id : int ) -> httpx . _models . Response View Source def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close ()","title":"delete"},{"location":"reference/neuroio/api/groups/v1/#get","text":"def get ( self , id : int ) -> httpx . _models . Response View Source def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : self . client . close ()","title":"get"},{"location":"reference/neuroio/api/groups/v1/#list","text":"def list ( self , q : Union [ str , object ] = < object object at 0x10b7673c0 > , pids_include : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : self . client . close ()","title":"list"},{"location":"reference/neuroio/api/groups/v1/#persons","text":"def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) try : return self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : self . client . close ()","title":"persons"},{"location":"reference/neuroio/api/groups/v1/#remove","text":"def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . _models . Response View Source def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : self . client . close ()","title":"remove"},{"location":"reference/neuroio/api/groups/v1/#update","text":"def update ( self , id : int , name : str ) -> httpx . _models . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : self . client . close ()","title":"update"},{"location":"reference/neuroio/api/groups/v1/#groupsasync","text":"class GroupsAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class GroupsAsync ( APIBaseAsync ) : async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose () async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : await self . client . aclose () async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose () async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose ()","title":"GroupsAsync"},{"location":"reference/neuroio/api/groups/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/groups/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/groups/v1/#add_1","text":"def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . _models . Response View Source async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . post ( url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose ()","title":"add"},{"location":"reference/neuroio/api/groups/v1/#create_1","text":"def create ( self , name : str ) -> httpx . _models . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/groups/persons/\" , json = data ) finally : await self . client . aclose ()","title":"create"},{"location":"reference/neuroio/api/groups/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . _models . Response View Source async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose ()","title":"delete"},{"location":"reference/neuroio/api/groups/v1/#get_1","text":"def get ( self , id : int ) -> httpx . _models . Response View Source async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/\" ) finally : await self . client . aclose ()","title":"get"},{"location":"reference/neuroio/api/groups/v1/#list_1","text":"def list ( self , q : Union [ str , object ] = < object object at 0x10b7673c0 > , pids_include : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/groups/persons/\" , params = data ) finally : await self . client . aclose ()","title":"list"},{"location":"reference/neuroio/api/groups/v1/#persons_1","text":"def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) try : return await self . client . get ( url = f \"/v1/groups/persons/{id}/pids/\" , params = data ) finally : await self . client . aclose ()","title":"persons"},{"location":"reference/neuroio/api/groups/v1/#remove_1","text":"def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . _models . Response View Source async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } try : return await self . client . request ( \"DELETE\" , url = \"/v1/groups/persons/pids/\" , json = data ) finally : await self . client . aclose ()","title":"remove"},{"location":"reference/neuroio/api/groups/v1/#update_1","text":"def update ( self , id : int , name : str ) -> httpx . _models . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/groups/persons/{id}/\" , json = data ) finally : await self . client . aclose ()","title":"update"},{"location":"reference/neuroio/api/notifications/","text":"Module neuroio.api.notifications Sub-modules neuroio.api.notifications.v1","title":"Index"},{"location":"reference/neuroio/api/notifications/#module-neuroioapinotifications","text":"","title":"Module neuroio.api.notifications"},{"location":"reference/neuroio/api/notifications/#sub-modules","text":"neuroio.api.notifications.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/notifications/v1/","text":"Module neuroio.api.notifications.v1 View Source from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , sentinel , ) from neuroio.utils import request_dict_processing , request_query_processing class Notifications ( APIBase ): def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : self . client . close () def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) try : return self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close () class NotificationsAsync ( APIBaseAsync ): async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return await self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) try : return await self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose () Variables sentinel Classes Notifications class Notifications ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Notifications ( APIBase ) : def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : self . client . close () def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) try : return self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10b7673c0 > , sources : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : self . client . close () delete def delete ( self , id : int ) -> httpx . _models . Response View Source def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close () get def get ( self , id : int ) -> httpx . _models . Response View Source def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close () list def list ( self , q : Union [ str , object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : self . client . close () update def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10b7673c0 > , sources : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) try : return self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : self . client . close () NotificationsAsync class NotificationsAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class NotificationsAsync ( APIBaseAsync ) : async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return await self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) try : return await self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10b7673c0 > , sources : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return await self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : await self . client . aclose () delete def delete ( self , id : int ) -> httpx . _models . Response View Source async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose () get def get ( self , id : int ) -> httpx . _models . Response View Source async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose () list def list ( self , q : Union [ str , object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : await self . client . aclose () update def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10b7673c0 > , sources : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) try : return await self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/api/notifications/v1/#module-neuroioapinotificationsv1","text":"View Source from typing import List , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , sentinel , ) from neuroio.utils import request_dict_processing , request_query_processing class Notifications ( APIBase ): def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : self . client . close () def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) try : return self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close () class NotificationsAsync ( APIBaseAsync ): async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return await self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) try : return await self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose ()","title":"Module neuroio.api.notifications.v1"},{"location":"reference/neuroio/api/notifications/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/api/notifications/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/notifications/v1/#notifications","text":"class Notifications ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Notifications ( APIBase ) : def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : self . client . close () def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) try : return self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close ()","title":"Notifications"},{"location":"reference/neuroio/api/notifications/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/notifications/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/notifications/v1/#create","text":"def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10b7673c0 > , sources : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : self . client . close ()","title":"create"},{"location":"reference/neuroio/api/notifications/v1/#delete","text":"def delete ( self , id : int ) -> httpx . _models . Response View Source def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close ()","title":"delete"},{"location":"reference/neuroio/api/notifications/v1/#get","text":"def get ( self , id : int ) -> httpx . _models . Response View Source def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : self . client . close ()","title":"get"},{"location":"reference/neuroio/api/notifications/v1/#list","text":"def list ( self , q : Union [ str , object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : self . client . close ()","title":"list"},{"location":"reference/neuroio/api/notifications/v1/#update","text":"def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10b7673c0 > , sources : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) try : return self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : self . client . close ()","title":"update"},{"location":"reference/neuroio/api/notifications/v1/#notificationsasync","text":"class NotificationsAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class NotificationsAsync ( APIBaseAsync ) : async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return await self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) try : return await self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose ()","title":"NotificationsAsync"},{"location":"reference/neuroio/api/notifications/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/notifications/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/notifications/v1/#create_1","text":"def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10b7673c0 > , sources : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return await self . client . post ( url = \"/v1/notifications/\" , json = data ) finally : await self . client . aclose ()","title":"create"},{"location":"reference/neuroio/api/notifications/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . _models . Response View Source async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose ()","title":"delete"},{"location":"reference/neuroio/api/notifications/v1/#get_1","text":"def get ( self , id : int ) -> httpx . _models . Response View Source async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/notifications/{id}/\" ) finally : await self . client . aclose ()","title":"get"},{"location":"reference/neuroio/api/notifications/v1/#list_1","text":"def list ( self , q : Union [ str , object ] = < object object at 0x10b7673c0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/notifications/\" , params = data ) finally : await self . client . aclose ()","title":"list"},{"location":"reference/neuroio/api/notifications/v1/#update_1","text":"def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10b7673c0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10b7673c0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10b7673c0 > , age_from : Union [ int , object ] = < object object at 0x10b7673c0 > , age_to : Union [ int , object ] = < object object at 0x10b7673c0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10b7673c0 > , sources : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) try : return await self . client . patch ( url = f \"/v1/notifications/{id}/\" , json = data ) finally : await self . client . aclose ()","title":"update"},{"location":"reference/neuroio/api/persons/","text":"Module neuroio.api.persons Sub-modules neuroio.api.persons.v1","title":"Index"},{"location":"reference/neuroio/api/persons/#module-neuroioapipersons","text":"","title":"Module neuroio.api.persons"},{"location":"reference/neuroio/api/persons/#sub-modules","text":"neuroio.api.persons.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/persons/v1/","text":"Module neuroio.api.persons.v1 View Source from typing import BinaryIO from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryResult from neuroio.utils import request_dict_processing class Persons ( APIBase ): def create ( self , image : BinaryIO , source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try : return self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally : self . client . close () def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally : self . client . close () def reinit ( self , id : int ) -> Response : try : return self . client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id }) finally : self . client . close () def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : int , identify_asm : bool , result : str = EntryResult . HA , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try : return self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally : self . client . close () def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} try : return self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally : self . client . close () def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally : self . client . close () class PersonsAsync ( APIBaseAsync ): async def create ( self , image : BinaryIO , source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try : return await self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally : await self . client . aclose () async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally : await self . client . aclose () async def reinit ( self , id : int ) -> Response : try : return await self . client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } ) finally : await self . client . aclose () async def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : int , identify_asm : bool , result : str = EntryResult . HA , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try : return await self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally : await self . client . aclose () async def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} try : return await self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally : await self . client . aclose () async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally : await self . client . aclose () Classes Persons class Persons ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Persons ( APIBase ): def create ( self , image: BinaryIO , source: str , facesize: int , create_on_ha: bool , create_on_junk: bool , identify_asm: bool , ) -> Response: files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try: return self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally: self . client . close () def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) try: return self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally: self . client . close () def reinit ( self , id: int ) -> Response: try: return self . client . post ( url = \"/v1/persons/reinit/\" , json ={ \"id\" : id }) finally: self . client . close () def reinit_by_photo ( self , pid: str , image: BinaryIO , source: str , facesize: int , identify_asm: bool , result: str = EntryResult . HA , ) -> Response: files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try: return self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally: self . client . close () def search ( self , image: BinaryIO , identify_asm: bool = False ) -> Response: files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} try: return self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally: self . client . close () def delete ( self , pid: str ) -> Response: try: return self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally: self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , image : < class ' BinaryIO '>, source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool ) -> httpx . _models . Response View Source def create ( self , image : BinaryIO , source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try : return self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally : self . client . close () create_by_entry def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . _models . Response View Source def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally : self . client . close () delete def delete ( self , pid : str ) -> httpx . _models . Response View Source def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally : self . client . close () reinit def reinit ( self , id : int ) -> httpx . _models . Response View Source def reinit ( self , id : int ) -> Response : try : return self . client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } ) finally : self . client . close () reinit_by_photo def reinit_by_photo ( self , pid : str , image : < class ' BinaryIO '>, source : str , facesize : int , identify_asm : bool , result : str = < EntryResult . HA : 'ha' > ) -> httpx . _models . Response View Source def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : int , identify_asm : bool , result : str = EntryResult . HA , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try : return self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally : self . client . close () search def search ( self , image : < class ' BinaryIO '>, identify_asm : bool = False ) -> httpx . _models . Response View Source def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" ) } data = { \"identify_asm\" : str ( identify_asm ) } try : return self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally : self . client . close () PersonsAsync class PersonsAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class PersonsAsync ( APIBaseAsync ): async def create ( self , image: BinaryIO , source: str , facesize: int , create_on_ha: bool , create_on_junk: bool , identify_asm: bool , ) -> Response: files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try: return await self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally: await self . client . aclose () async def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) try: return await self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally: await self . client . aclose () async def reinit ( self , id: int ) -> Response: try: return await self . client . post ( url = \"/v1/persons/reinit/\" , json ={ \"id\" : id } ) finally: await self . client . aclose () async def reinit_by_photo ( self , pid: str , image: BinaryIO , source: str , facesize: int , identify_asm: bool , result: str = EntryResult . HA , ) -> Response: files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try: return await self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally: await self . client . aclose () async def search ( self , image: BinaryIO , identify_asm: bool = False ) -> Response: files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} try: return await self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally: await self . client . aclose () async def delete ( self , pid: str ) -> Response: try: return await self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally: await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , image : < class ' BinaryIO '>, source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool ) -> httpx . _models . Response View Source async def create ( self , image : BinaryIO , source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try : return await self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally : await self . client . aclose () create_by_entry def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . _models . Response View Source async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally : await self . client . aclose () delete def delete ( self , pid : str ) -> httpx . _models . Response View Source async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally : await self . client . aclose () reinit def reinit ( self , id : int ) -> httpx . _models . Response View Source async def reinit ( self , id : int ) -> Response : try : return await self . client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } ) finally : await self . client . aclose () reinit_by_photo def reinit_by_photo ( self , pid : str , image : < class ' BinaryIO '>, source : str , facesize : int , identify_asm : bool , result : str = < EntryResult . HA : 'ha' > ) -> httpx . _models . Response View Source async def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : int , identify_asm : bool , result : str = EntryResult . HA , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try : return await self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally : await self . client . aclose () search def search ( self , image : < class ' BinaryIO '>, identify_asm : bool = False ) -> httpx . _models . Response View Source async def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" ) } data = { \"identify_asm\" : str ( identify_asm ) } try : return await self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/api/persons/v1/#module-neuroioapipersonsv1","text":"View Source from typing import BinaryIO from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryResult from neuroio.utils import request_dict_processing class Persons ( APIBase ): def create ( self , image : BinaryIO , source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try : return self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally : self . client . close () def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally : self . client . close () def reinit ( self , id : int ) -> Response : try : return self . client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id }) finally : self . client . close () def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : int , identify_asm : bool , result : str = EntryResult . HA , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try : return self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally : self . client . close () def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} try : return self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally : self . client . close () def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally : self . client . close () class PersonsAsync ( APIBaseAsync ): async def create ( self , image : BinaryIO , source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try : return await self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally : await self . client . aclose () async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally : await self . client . aclose () async def reinit ( self , id : int ) -> Response : try : return await self . client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } ) finally : await self . client . aclose () async def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : int , identify_asm : bool , result : str = EntryResult . HA , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try : return await self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally : await self . client . aclose () async def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} try : return await self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally : await self . client . aclose () async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally : await self . client . aclose ()","title":"Module neuroio.api.persons.v1"},{"location":"reference/neuroio/api/persons/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/persons/v1/#persons","text":"class Persons ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Persons ( APIBase ): def create ( self , image: BinaryIO , source: str , facesize: int , create_on_ha: bool , create_on_junk: bool , identify_asm: bool , ) -> Response: files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try: return self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally: self . client . close () def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) try: return self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally: self . client . close () def reinit ( self , id: int ) -> Response: try: return self . client . post ( url = \"/v1/persons/reinit/\" , json ={ \"id\" : id }) finally: self . client . close () def reinit_by_photo ( self , pid: str , image: BinaryIO , source: str , facesize: int , identify_asm: bool , result: str = EntryResult . HA , ) -> Response: files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try: return self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally: self . client . close () def search ( self , image: BinaryIO , identify_asm: bool = False ) -> Response: files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} try: return self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally: self . client . close () def delete ( self , pid: str ) -> Response: try: return self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally: self . client . close ()","title":"Persons"},{"location":"reference/neuroio/api/persons/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/persons/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/persons/v1/#create","text":"def create ( self , image : < class ' BinaryIO '>, source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool ) -> httpx . _models . Response View Source def create ( self , image : BinaryIO , source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try : return self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally : self . client . close ()","title":"create"},{"location":"reference/neuroio/api/persons/v1/#create_by_entry","text":"def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . _models . Response View Source def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally : self . client . close ()","title":"create_by_entry"},{"location":"reference/neuroio/api/persons/v1/#delete","text":"def delete ( self , pid : str ) -> httpx . _models . Response View Source def delete ( self , pid : str ) -> Response : try : return self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally : self . client . close ()","title":"delete"},{"location":"reference/neuroio/api/persons/v1/#reinit","text":"def reinit ( self , id : int ) -> httpx . _models . Response View Source def reinit ( self , id : int ) -> Response : try : return self . client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } ) finally : self . client . close ()","title":"reinit"},{"location":"reference/neuroio/api/persons/v1/#reinit_by_photo","text":"def reinit_by_photo ( self , pid : str , image : < class ' BinaryIO '>, source : str , facesize : int , identify_asm : bool , result : str = < EntryResult . HA : 'ha' > ) -> httpx . _models . Response View Source def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : int , identify_asm : bool , result : str = EntryResult . HA , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try : return self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally : self . client . close ()","title":"reinit_by_photo"},{"location":"reference/neuroio/api/persons/v1/#search","text":"def search ( self , image : < class ' BinaryIO '>, identify_asm : bool = False ) -> httpx . _models . Response View Source def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" ) } data = { \"identify_asm\" : str ( identify_asm ) } try : return self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally : self . client . close ()","title":"search"},{"location":"reference/neuroio/api/persons/v1/#personsasync","text":"class PersonsAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class PersonsAsync ( APIBaseAsync ): async def create ( self , image: BinaryIO , source: str , facesize: int , create_on_ha: bool , create_on_junk: bool , identify_asm: bool , ) -> Response: files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try: return await self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally: await self . client . aclose () async def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) try: return await self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally: await self . client . aclose () async def reinit ( self , id: int ) -> Response: try: return await self . client . post ( url = \"/v1/persons/reinit/\" , json ={ \"id\" : id } ) finally: await self . client . aclose () async def reinit_by_photo ( self , pid: str , image: BinaryIO , source: str , facesize: int , identify_asm: bool , result: str = EntryResult . HA , ) -> Response: files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try: return await self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally: await self . client . aclose () async def search ( self , image: BinaryIO , identify_asm: bool = False ) -> Response: files = { \"image\" : ( \"image\" , image , \"image/jpeg\" )} data = { \"identify_asm\" : str ( identify_asm )} try: return await self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally: await self . client . aclose () async def delete ( self , pid: str ) -> Response: try: return await self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally: await self . client . aclose ()","title":"PersonsAsync"},{"location":"reference/neuroio/api/persons/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/persons/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/persons/v1/#create_1","text":"def create ( self , image : < class ' BinaryIO '>, source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool ) -> httpx . _models . Response View Source async def create ( self , image : BinaryIO , source : str , facesize : int , create_on_ha : bool , create_on_junk : bool , identify_asm : bool , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"create_on_ha\" : str ( create_on_ha ), \"create_on_junk\" : str ( create_on_junk ), \"identify_asm\" : str ( identify_asm ), } try : return await self . client . post ( url = \"/v1/persons/\" , data = data , files = files ) finally : await self . client . aclose ()","title":"create"},{"location":"reference/neuroio/api/persons/v1/#create_by_entry_1","text":"def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . _models . Response View Source async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . post ( url = \"/v1/persons/entry/\" , json = data ) finally : await self . client . aclose ()","title":"create_by_entry"},{"location":"reference/neuroio/api/persons/v1/#delete_1","text":"def delete ( self , pid : str ) -> httpx . _models . Response View Source async def delete ( self , pid : str ) -> Response : try : return await self . client . delete ( url = f \"/v1/persons/{pid}/\" ) finally : await self . client . aclose ()","title":"delete"},{"location":"reference/neuroio/api/persons/v1/#reinit_1","text":"def reinit ( self , id : int ) -> httpx . _models . Response View Source async def reinit ( self , id : int ) -> Response : try : return await self . client . post ( url = \"/v1/persons/reinit/\" , json = { \"id\" : id } ) finally : await self . client . aclose ()","title":"reinit"},{"location":"reference/neuroio/api/persons/v1/#reinit_by_photo_1","text":"def reinit_by_photo ( self , pid : str , image : < class ' BinaryIO '>, source : str , facesize : int , identify_asm : bool , result : str = < EntryResult . HA : 'ha' > ) -> httpx . _models . Response View Source async def reinit_by_photo ( self , pid : str , image : BinaryIO , source : str , facesize : int , identify_asm : bool , result : str = EntryResult . HA , ) -> Response : files = { \"image\" : image } data = { \"source\" : source , \"facesize\" : str ( facesize ), \"identify_asm\" : str ( identify_asm ), \"result\" : result , } try : return await self . client . post ( url = f \"/v1/persons/reinit/{pid}/\" , data = data , files = files ) finally : await self . client . aclose ()","title":"reinit_by_photo"},{"location":"reference/neuroio/api/persons/v1/#search_1","text":"def search ( self , image : < class ' BinaryIO '>, identify_asm : bool = False ) -> httpx . _models . Response View Source async def search ( self , image : BinaryIO , identify_asm : bool = False ) -> Response : files = { \"image\" : ( \"image\" , image , \"image/jpeg\" ) } data = { \"identify_asm\" : str ( identify_asm ) } try : return await self . client . post ( url = \"/v1/persons/search/\" , data = data , files = files ) finally : await self . client . aclose ()","title":"search"},{"location":"reference/neuroio/api/settings/","text":"Module neuroio.api.settings Sub-modules neuroio.api.settings.v1","title":"Index"},{"location":"reference/neuroio/api/settings/#module-neuroioapisettings","text":"","title":"Module neuroio.api.settings"},{"location":"reference/neuroio/api/settings/#sub-modules","text":"neuroio.api.settings.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/settings/v1/","text":"Module neuroio.api.settings.v1 View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import ( DEFAULT_EXACT_THRESHOLD , DEFAULT_HA_THRESHOLD , DEFAULT_JUNK_THRESHOLD , ) from neuroio.utils import request_dict_processing class Settings ( APIBase ): def get ( self ) -> Response : try : return self . client . get ( url = \"/v1/settings/thresholds/\" ) finally : self . client . close () def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally : self . client . close () def reset ( self ) -> Response : try : return self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally : self . client . close () class SettingsAsync ( APIBaseAsync ): async def get ( self ) -> Response : try : return await self . client . get ( url = \"/v1/settings/thresholds/\" ) finally : await self . client . aclose () async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally : await self . client . aclose () async def reset ( self ) -> Response : try : return await self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally : await self . client . aclose () Variables DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD Classes Settings class Settings ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Settings ( APIBase ): def get ( self ) -> Response: try: return self . client . get ( url = \"/v1/settings/thresholds/\" ) finally: self . client . close () def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) try: return self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally: self . client . close () def reset ( self ) -> Response: try: return self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally: self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods get def get ( self ) -> httpx . _models . Response View Source def get ( self ) -> Response : try : return self . client . get ( url = \"/v1/settings/thresholds/\" ) finally : self . client . close () reset def reset ( self ) -> httpx . _models . Response View Source def reset ( self ) -> Response : try : return self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally : self . client . close () update def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . _models . Response View Source def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally : self . client . close () SettingsAsync class SettingsAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SettingsAsync ( APIBaseAsync ): async def get ( self ) -> Response: try: return await self . client . get ( url = \"/v1/settings/thresholds/\" ) finally: await self . client . aclose () async def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) try: return await self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally: await self . client . aclose () async def reset ( self ) -> Response: try: return await self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally: await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods get def get ( self ) -> httpx . _models . Response View Source async def get ( self ) -> Response : try : return await self . client . get ( url = \"/v1/settings/thresholds/\" ) finally : await self . client . aclose () reset def reset ( self ) -> httpx . _models . Response View Source async def reset ( self ) -> Response : try : return await self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally : await self . client . aclose () update def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . _models . Response View Source async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/api/settings/v1/#module-neuroioapisettingsv1","text":"View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import ( DEFAULT_EXACT_THRESHOLD , DEFAULT_HA_THRESHOLD , DEFAULT_JUNK_THRESHOLD , ) from neuroio.utils import request_dict_processing class Settings ( APIBase ): def get ( self ) -> Response : try : return self . client . get ( url = \"/v1/settings/thresholds/\" ) finally : self . client . close () def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally : self . client . close () def reset ( self ) -> Response : try : return self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally : self . client . close () class SettingsAsync ( APIBaseAsync ): async def get ( self ) -> Response : try : return await self . client . get ( url = \"/v1/settings/thresholds/\" ) finally : await self . client . aclose () async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally : await self . client . aclose () async def reset ( self ) -> Response : try : return await self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally : await self . client . aclose ()","title":"Module neuroio.api.settings.v1"},{"location":"reference/neuroio/api/settings/v1/#variables","text":"DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD","title":"Variables"},{"location":"reference/neuroio/api/settings/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/settings/v1/#settings","text":"class Settings ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Settings ( APIBase ): def get ( self ) -> Response: try: return self . client . get ( url = \"/v1/settings/thresholds/\" ) finally: self . client . close () def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) try: return self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally: self . client . close () def reset ( self ) -> Response: try: return self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally: self . client . close ()","title":"Settings"},{"location":"reference/neuroio/api/settings/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/settings/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/settings/v1/#get","text":"def get ( self ) -> httpx . _models . Response View Source def get ( self ) -> Response : try : return self . client . get ( url = \"/v1/settings/thresholds/\" ) finally : self . client . close ()","title":"get"},{"location":"reference/neuroio/api/settings/v1/#reset","text":"def reset ( self ) -> httpx . _models . Response View Source def reset ( self ) -> Response : try : return self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally : self . client . close ()","title":"reset"},{"location":"reference/neuroio/api/settings/v1/#update","text":"def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . _models . Response View Source def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally : self . client . close ()","title":"update"},{"location":"reference/neuroio/api/settings/v1/#settingsasync","text":"class SettingsAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SettingsAsync ( APIBaseAsync ): async def get ( self ) -> Response: try: return await self . client . get ( url = \"/v1/settings/thresholds/\" ) finally: await self . client . aclose () async def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) try: return await self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally: await self . client . aclose () async def reset ( self ) -> Response: try: return await self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally: await self . client . aclose ()","title":"SettingsAsync"},{"location":"reference/neuroio/api/settings/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/settings/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/settings/v1/#get_1","text":"def get ( self ) -> httpx . _models . Response View Source async def get ( self ) -> Response : try : return await self . client . get ( url = \"/v1/settings/thresholds/\" ) finally : await self . client . aclose ()","title":"get"},{"location":"reference/neuroio/api/settings/v1/#reset_1","text":"def reset ( self ) -> httpx . _models . Response View Source async def reset ( self ) -> Response : try : return await self . client . post ( url = \"/v1/settings/thresholds/reset/\" ) finally : await self . client . aclose ()","title":"reset"},{"location":"reference/neuroio/api/settings/v1/#update_1","text":"def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . _models . Response View Source async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . patch ( url = \"/v1/settings/thresholds/\" , data = data ) finally : await self . client . aclose ()","title":"update"},{"location":"reference/neuroio/api/sources/","text":"Module neuroio.api.sources Sub-modules neuroio.api.sources.v1","title":"Index"},{"location":"reference/neuroio/api/sources/#module-neuroioapisources","text":"","title":"Module neuroio.api.sources"},{"location":"reference/neuroio/api/sources/#sub-modules","text":"neuroio.api.sources.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/sources/v1/","text":"Module neuroio.api.sources.v1 View Source from typing import List , Optional , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import SourceLicense , sentinel from neuroio.utils import request_dict_processing , request_query_processing class Sources ( APIBase ): def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . post ( url = \"/v1/sources/\" , json = data ) finally : self . client . close () def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return self . client . get ( url = \"/v1/sources/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str , license_type : Union [ SourceLicense , object ] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) try : return self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close () class SourcesAsync ( APIBaseAsync ): async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . post ( url = \"/v1/sources/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return await self . client . get ( url = \"/v1/sources/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str , license_type : Union [ SourceLicense , object ] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) try : return await self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose () Variables sentinel Classes Sources class Sources ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Sources ( APIBase ) : def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return self . client . post ( url = \"/v1/sources/\" , json = data ) finally : self . client . close () def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/sources/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) try : return self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , name : str , license_type : neuroio . constants . SourceLicense = < SourceLicense . BASIC : 'basic' > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return self . client . post ( url = \"/v1/sources/\" , json = data ) finally : self . client . close () delete def delete ( self , id : int ) -> httpx . _models . Response View Source def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close () get def get ( self , id : int ) -> httpx . _models . Response View Source def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close () list def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/sources/\" , params = data ) finally : self . client . close () update def update ( self , id : int , name : str , license_type : Union [ neuroio . constants . SourceLicense , object ] = < object object at 0x10b7673c0 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , use_pps_time : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_persons : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x10b7673c0 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) try : return self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : self . client . close () SourcesAsync class SourcesAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SourcesAsync ( APIBaseAsync ) : async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return await self . client . post ( url = \"/v1/sources/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/sources/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) try : return await self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , name : str , license_type : neuroio . constants . SourceLicense = < SourceLicense . BASIC : 'basic' > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return await self . client . post ( url = \"/v1/sources/\" , json = data ) finally : await self . client . aclose () delete def delete ( self , id : int ) -> httpx . _models . Response View Source async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose () get def get ( self , id : int ) -> httpx . _models . Response View Source async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose () list def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/sources/\" , params = data ) finally : await self . client . aclose () update def update ( self , id : int , name : str , license_type : Union [ neuroio . constants . SourceLicense , object ] = < object object at 0x10b7673c0 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , use_pps_time : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_persons : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x10b7673c0 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source async def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) try : return await self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/api/sources/v1/#module-neuroioapisourcesv1","text":"View Source from typing import List , Optional , Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import SourceLicense , sentinel from neuroio.utils import request_dict_processing , request_query_processing class Sources ( APIBase ): def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return self . client . post ( url = \"/v1/sources/\" , json = data ) finally : self . client . close () def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return self . client . get ( url = \"/v1/sources/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str , license_type : Union [ SourceLicense , object ] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) try : return self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close () class SourcesAsync ( APIBaseAsync ): async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) try : return await self . client . post ( url = \"/v1/sources/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) try : return await self . client . get ( url = \"/v1/sources/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str , license_type : Union [ SourceLicense , object ] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) try : return await self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose ()","title":"Module neuroio.api.sources.v1"},{"location":"reference/neuroio/api/sources/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/api/sources/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/sources/v1/#sources","text":"class Sources ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Sources ( APIBase ) : def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return self . client . post ( url = \"/v1/sources/\" , json = data ) finally : self . client . close () def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/sources/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) try : return self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close ()","title":"Sources"},{"location":"reference/neuroio/api/sources/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/sources/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/sources/v1/#create","text":"def create ( self , name : str , license_type : neuroio . constants . SourceLicense = < SourceLicense . BASIC : 'basic' > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return self . client . post ( url = \"/v1/sources/\" , json = data ) finally : self . client . close ()","title":"create"},{"location":"reference/neuroio/api/sources/v1/#delete","text":"def delete ( self , id : int ) -> httpx . _models . Response View Source def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close ()","title":"delete"},{"location":"reference/neuroio/api/sources/v1/#get","text":"def get ( self , id : int ) -> httpx . _models . Response View Source def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : self . client . close ()","title":"get"},{"location":"reference/neuroio/api/sources/v1/#list","text":"def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return self . client . get ( url = \"/v1/sources/\" , params = data ) finally : self . client . close ()","title":"list"},{"location":"reference/neuroio/api/sources/v1/#update","text":"def update ( self , id : int , name : str , license_type : Union [ neuroio . constants . SourceLicense , object ] = < object object at 0x10b7673c0 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , use_pps_time : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_persons : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x10b7673c0 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) try : return self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : self . client . close ()","title":"update"},{"location":"reference/neuroio/api/sources/v1/#sourcesasync","text":"class SourcesAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SourcesAsync ( APIBaseAsync ) : async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return await self . client . post ( url = \"/v1/sources/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/sources/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) try : return await self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose ()","title":"SourcesAsync"},{"location":"reference/neuroio/api/sources/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/sources/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/sources/v1/#create_1","text":"def create ( self , name : str , license_type : neuroio . constants . SourceLicense = < SourceLicense . BASIC : 'basic' > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source async def create ( self , name : str , license_type : SourceLicense = SourceLicense . BASIC , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) try : return await self . client . post ( url = \"/v1/sources/\" , json = data ) finally : await self . client . aclose ()","title":"create"},{"location":"reference/neuroio/api/sources/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . _models . Response View Source async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose ()","title":"delete"},{"location":"reference/neuroio/api/sources/v1/#get_1","text":"def get ( self , id : int ) -> httpx . _models . Response View Source async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/sources/{id}/\" ) finally : await self . client . aclose ()","title":"get"},{"location":"reference/neuroio/api/sources/v1/#list_1","text":"def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10b7673c0 > , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) try : return await self . client . get ( url = \"/v1/sources/\" , params = data ) finally : await self . client . aclose ()","title":"list"},{"location":"reference/neuroio/api/sources/v1/#update_1","text":"def update ( self , id : int , name : str , license_type : Union [ neuroio . constants . SourceLicense , object ] = < object object at 0x10b7673c0 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , use_pps_time : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x10b7673c0 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_persons : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x10b7673c0 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x10b7673c0 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x10b7673c0 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x10b7673c0 > ) -> httpx . _models . Response View Source async def update ( self , id : int , name : str , license_type : Union [ SourceLicense, object ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) try : return await self . client . patch ( url = f \"/v1/sources/{id}/\" , json = data ) finally : await self . client . aclose ()","title":"update"},{"location":"reference/neuroio/api/utility/","text":"Module neuroio.api.utility Sub-modules neuroio.api.utility.v1","title":"Index"},{"location":"reference/neuroio/api/utility/#module-neuroioapiutility","text":"","title":"Module neuroio.api.utility"},{"location":"reference/neuroio/api/utility/#sub-modules","text":"neuroio.api.utility.v1","title":"Sub-modules"},{"location":"reference/neuroio/api/utility/v1/","text":"Module neuroio.api.utility.v1 View Source from typing.io import BinaryIO from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryResult class Utility ( APIBase ): def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try : return self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally : self . client . close () def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } try : return self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally : self . client . close () class UtilityAsync ( APIBaseAsync ): async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try : return await self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally : await self . client . aclose () async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } try : return await self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally : await self . client . aclose () Classes Utility class Utility ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Utility ( APIBase ): def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try: return self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally: self . client . close () def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } try: return self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally: self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods asm def asm ( self , image : < class ' BinaryIO '> ) -> httpx . _models . Response View Source def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } try : return self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally : self . client . close () compare def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . _models . Response View Source def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try : return self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally : self . client . close () UtilityAsync class UtilityAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class UtilityAsync ( APIBaseAsync ): async def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try: return await self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally: await self . client . aclose () async def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } try: return await self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally: await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods asm def asm ( self , image : < class ' BinaryIO '> ) -> httpx . _models . Response View Source async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } try : return await self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally : await self . client . aclose () compare def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . _models . Response View Source async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try : return await self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/api/utility/v1/#module-neuroioapiutilityv1","text":"View Source from typing.io import BinaryIO from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync from neuroio.constants import EntryResult class Utility ( APIBase ): def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try : return self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally : self . client . close () def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } try : return self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally : self . client . close () class UtilityAsync ( APIBaseAsync ): async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try : return await self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally : await self . client . aclose () async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } try : return await self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally : await self . client . aclose ()","title":"Module neuroio.api.utility.v1"},{"location":"reference/neuroio/api/utility/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/api/utility/v1/#utility","text":"class Utility ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Utility ( APIBase ): def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try: return self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally: self . client . close () def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } try: return self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally: self . client . close ()","title":"Utility"},{"location":"reference/neuroio/api/utility/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/utility/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/api/utility/v1/#asm","text":"def asm ( self , image : < class ' BinaryIO '> ) -> httpx . _models . Response View Source def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } try : return self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally : self . client . close ()","title":"asm"},{"location":"reference/neuroio/api/utility/v1/#compare","text":"def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . _models . Response View Source def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try : return self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally : self . client . close ()","title":"compare"},{"location":"reference/neuroio/api/utility/v1/#utilityasync","text":"class UtilityAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class UtilityAsync ( APIBaseAsync ): async def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try: return await self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally: await self . client . aclose () async def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } try: return await self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally: await self . client . aclose ()","title":"UtilityAsync"},{"location":"reference/neuroio/api/utility/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/api/utility/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/api/utility/v1/#asm_1","text":"def asm ( self , image : < class ' BinaryIO '> ) -> httpx . _models . Response View Source async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } try : return await self . client . post ( url = \"/v1/utility/asm/\" , files = files ) finally : await self . client . aclose ()","title":"asm"},{"location":"reference/neuroio/api/utility/v1/#compare_1","text":"def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . _models . Response View Source async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } try : return await self . client . post ( url = \"/v1/utility/compare/\" , data = data , files = files ) finally : await self . client . aclose ()","title":"compare"},{"location":"reference/neuroio/iam/","text":"Module neuroio.iam Sub-modules neuroio.iam.auth neuroio.iam.spaces neuroio.iam.tokens neuroio.iam.whoami","title":"Index"},{"location":"reference/neuroio/iam/#module-neuroioiam","text":"","title":"Module neuroio.iam"},{"location":"reference/neuroio/iam/#sub-modules","text":"neuroio.iam.auth neuroio.iam.spaces neuroio.iam.tokens neuroio.iam.whoami","title":"Sub-modules"},{"location":"reference/neuroio/iam/auth/","text":"Module neuroio.iam.auth Sub-modules neuroio.iam.auth.v1","title":"Index"},{"location":"reference/neuroio/iam/auth/#module-neuroioiamauth","text":"","title":"Module neuroio.iam.auth"},{"location":"reference/neuroio/iam/auth/#sub-modules","text":"neuroio.iam.auth.v1","title":"Sub-modules"},{"location":"reference/neuroio/iam/auth/v1/","text":"Module neuroio.iam.auth.v1 View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Auth ( APIBase ): def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } try : return self . client . post ( url = \"/v1/login/\" , json = data ) finally : self . client . close () def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try : return self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally : self . client . close () class AuthAsync ( APIBaseAsync ): async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } try : return await self . client . post ( url = \"/v1/login/\" , json = data ) finally : await self . client . aclose () async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try : return await self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally : await self . client . aclose () Classes Auth class Auth ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Auth ( APIBase ): def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } try: return self . client . post ( url = \"/v1/login/\" , json = data ) finally: self . client . close () def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try: return self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally: self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods login def login ( self , username : str , password : str ) -> httpx . _models . Response View Source def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } try : return self . client . post ( url = \"/v1/login/\" , json = data ) finally : self . client . close () password_change def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . _models . Response View Source def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try : return self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally : self . client . close () AuthAsync class AuthAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class AuthAsync ( APIBaseAsync ): async def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } try: return await self . client . post ( url = \"/v1/login/\" , json = data ) finally: await self . client . aclose () async def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try: return await self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally: await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods login def login ( self , username : str , password : str ) -> httpx . _models . Response View Source async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } try : return await self . client . post ( url = \"/v1/login/\" , json = data ) finally : await self . client . aclose () password_change def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . _models . Response View Source async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try : return await self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/iam/auth/v1/#module-neuroioiamauthv1","text":"View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Auth ( APIBase ): def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } try : return self . client . post ( url = \"/v1/login/\" , json = data ) finally : self . client . close () def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try : return self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally : self . client . close () class AuthAsync ( APIBaseAsync ): async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } try : return await self . client . post ( url = \"/v1/login/\" , json = data ) finally : await self . client . aclose () async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try : return await self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally : await self . client . aclose ()","title":"Module neuroio.iam.auth.v1"},{"location":"reference/neuroio/iam/auth/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/iam/auth/v1/#auth","text":"class Auth ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Auth ( APIBase ): def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } try: return self . client . post ( url = \"/v1/login/\" , json = data ) finally: self . client . close () def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try: return self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally: self . client . close ()","title":"Auth"},{"location":"reference/neuroio/iam/auth/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/auth/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/iam/auth/v1/#login","text":"def login ( self , username : str , password : str ) -> httpx . _models . Response View Source def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } try : return self . client . post ( url = \"/v1/login/\" , json = data ) finally : self . client . close ()","title":"login"},{"location":"reference/neuroio/iam/auth/v1/#password_change","text":"def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . _models . Response View Source def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try : return self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally : self . client . close ()","title":"password_change"},{"location":"reference/neuroio/iam/auth/v1/#authasync","text":"class AuthAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class AuthAsync ( APIBaseAsync ): async def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } try: return await self . client . post ( url = \"/v1/login/\" , json = data ) finally: await self . client . aclose () async def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try: return await self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally: await self . client . aclose ()","title":"AuthAsync"},{"location":"reference/neuroio/iam/auth/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/auth/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/iam/auth/v1/#login_1","text":"def login ( self , username : str , password : str ) -> httpx . _models . Response View Source async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } try : return await self . client . post ( url = \"/v1/login/\" , json = data ) finally : await self . client . aclose ()","title":"login"},{"location":"reference/neuroio/iam/auth/v1/#password_change_1","text":"def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . _models . Response View Source async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } try : return await self . client . post ( url = \"/v1/auth/password/change/\" , json = data ) finally : await self . client . aclose ()","title":"password_change"},{"location":"reference/neuroio/iam/spaces/","text":"Module neuroio.iam.spaces Sub-modules neuroio.iam.spaces.v1","title":"Index"},{"location":"reference/neuroio/iam/spaces/#module-neuroioiamspaces","text":"","title":"Module neuroio.iam.spaces"},{"location":"reference/neuroio/iam/spaces/#sub-modules","text":"neuroio.iam.spaces.v1","title":"Sub-modules"},{"location":"reference/neuroio/iam/spaces/v1/","text":"Module neuroio.iam.spaces.v1 View Source import httpx from httpx import URL , Response from neuroio import constants from neuroio.api.base import APIBase , APIBaseAsync class Spaces ( APIBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/spaces/\" , json = data ) finally : self . client . close () def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } try : return self . client . get ( url = \"/v1/spaces/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally : self . client . close () def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally : self . client . close () class SpacesAsync ( APIBaseAsync ): def __init__ ( self , client : httpx . AsyncClient ): client . base_url = URL ( constants . IAM_BASE_URL ) super () . __init__ ( client = client ) async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/spaces/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } try : return await self . client . get ( url = \"/v1/spaces/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally : await self . client . aclose () async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return await self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally : await self . client . aclose () Classes Spaces class Spaces ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Spaces ( APIBase ): def create ( self , name: str ) -> Response: data = { \"name\" : name } try: return self . client . post ( url = \"/v1/spaces/\" , json = data ) finally: self . client . close () def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } try: return self . client . get ( url = \"/v1/spaces/\" , params = data ) finally: self . client . close () def get ( self , id: int ) -> Response: try: return self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally: self . client . close () def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } try: return self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally: self . client . close () def delete ( self , id: int ) -> Response: try: return self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally: self . client . close () def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } try: return self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally: self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , name : str ) -> httpx . _models . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/spaces/\" , json = data ) finally : self . client . close () delete def delete ( self , id : int ) -> httpx . _models . Response View Source def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally : self . client . close () get def get ( self , id : int ) -> httpx . _models . Response View Source def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally : self . client . close () list def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } try : return self . client . get ( url = \"/v1/spaces/\" , params = data ) finally : self . client . close () token def token ( self , id : int , permanent : bool = False ) -> httpx . _models . Response View Source def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally : self . client . close () update def update ( self , id : int , name : str ) -> httpx . _models . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally : self . client . close () SpacesAsync class SpacesAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SpacesAsync ( APIBaseAsync ): def __init__ ( self , client: httpx . AsyncClient ): client . base_url = URL ( constants . IAM_BASE_URL ) super (). __init__ ( client = client ) async def create ( self , name: str ) -> Response: data = { \"name\" : name } try: return await self . client . post ( url = \"/v1/spaces/\" , json = data ) finally: await self . client . aclose () async def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } try: return await self . client . get ( url = \"/v1/spaces/\" , params = data ) finally: await self . client . aclose () async def get ( self , id: int ) -> Response: try: return await self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally: await self . client . aclose () async def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } try: return await self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally: await self . client . aclose () async def delete ( self , id: int ) -> Response: try: return await self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally: await self . client . aclose () async def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } try: return await self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally: await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , name : str ) -> httpx . _models . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/spaces/\" , json = data ) finally : await self . client . aclose () delete def delete ( self , id : int ) -> httpx . _models . Response View Source async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally : await self . client . aclose () get def get ( self , id : int ) -> httpx . _models . Response View Source async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally : await self . client . aclose () list def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } try : return await self . client . get ( url = \"/v1/spaces/\" , params = data ) finally : await self . client . aclose () token def token ( self , id : int , permanent : bool = False ) -> httpx . _models . Response View Source async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return await self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally : await self . client . aclose () update def update ( self , id : int , name : str ) -> httpx . _models . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/iam/spaces/v1/#module-neuroioiamspacesv1","text":"View Source import httpx from httpx import URL , Response from neuroio import constants from neuroio.api.base import APIBase , APIBaseAsync class Spaces ( APIBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/spaces/\" , json = data ) finally : self . client . close () def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } try : return self . client . get ( url = \"/v1/spaces/\" , params = data ) finally : self . client . close () def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally : self . client . close () def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally : self . client . close () def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally : self . client . close () def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally : self . client . close () class SpacesAsync ( APIBaseAsync ): def __init__ ( self , client : httpx . AsyncClient ): client . base_url = URL ( constants . IAM_BASE_URL ) super () . __init__ ( client = client ) async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/spaces/\" , json = data ) finally : await self . client . aclose () async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } try : return await self . client . get ( url = \"/v1/spaces/\" , params = data ) finally : await self . client . aclose () async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally : await self . client . aclose () async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally : await self . client . aclose () async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally : await self . client . aclose () async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return await self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally : await self . client . aclose ()","title":"Module neuroio.iam.spaces.v1"},{"location":"reference/neuroio/iam/spaces/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/iam/spaces/v1/#spaces","text":"class Spaces ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Spaces ( APIBase ): def create ( self , name: str ) -> Response: data = { \"name\" : name } try: return self . client . post ( url = \"/v1/spaces/\" , json = data ) finally: self . client . close () def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } try: return self . client . get ( url = \"/v1/spaces/\" , params = data ) finally: self . client . close () def get ( self , id: int ) -> Response: try: return self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally: self . client . close () def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } try: return self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally: self . client . close () def delete ( self , id: int ) -> Response: try: return self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally: self . client . close () def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } try: return self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally: self . client . close ()","title":"Spaces"},{"location":"reference/neuroio/iam/spaces/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/spaces/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/iam/spaces/v1/#create","text":"def create ( self , name : str ) -> httpx . _models . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return self . client . post ( url = \"/v1/spaces/\" , json = data ) finally : self . client . close ()","title":"create"},{"location":"reference/neuroio/iam/spaces/v1/#delete","text":"def delete ( self , id : int ) -> httpx . _models . Response View Source def delete ( self , id : int ) -> Response : try : return self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally : self . client . close ()","title":"delete"},{"location":"reference/neuroio/iam/spaces/v1/#get","text":"def get ( self , id : int ) -> httpx . _models . Response View Source def get ( self , id : int ) -> Response : try : return self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally : self . client . close ()","title":"get"},{"location":"reference/neuroio/iam/spaces/v1/#list","text":"def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } try : return self . client . get ( url = \"/v1/spaces/\" , params = data ) finally : self . client . close ()","title":"list"},{"location":"reference/neuroio/iam/spaces/v1/#token","text":"def token ( self , id : int , permanent : bool = False ) -> httpx . _models . Response View Source def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally : self . client . close ()","title":"token"},{"location":"reference/neuroio/iam/spaces/v1/#update","text":"def update ( self , id : int , name : str ) -> httpx . _models . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally : self . client . close ()","title":"update"},{"location":"reference/neuroio/iam/spaces/v1/#spacesasync","text":"class SpacesAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class SpacesAsync ( APIBaseAsync ): def __init__ ( self , client: httpx . AsyncClient ): client . base_url = URL ( constants . IAM_BASE_URL ) super (). __init__ ( client = client ) async def create ( self , name: str ) -> Response: data = { \"name\" : name } try: return await self . client . post ( url = \"/v1/spaces/\" , json = data ) finally: await self . client . aclose () async def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } try: return await self . client . get ( url = \"/v1/spaces/\" , params = data ) finally: await self . client . aclose () async def get ( self , id: int ) -> Response: try: return await self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally: await self . client . aclose () async def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } try: return await self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally: await self . client . aclose () async def delete ( self , id: int ) -> Response: try: return await self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally: await self . client . aclose () async def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } try: return await self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally: await self . client . aclose ()","title":"SpacesAsync"},{"location":"reference/neuroio/iam/spaces/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/spaces/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/iam/spaces/v1/#create_1","text":"def create ( self , name : str ) -> httpx . _models . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . post ( url = \"/v1/spaces/\" , json = data ) finally : await self . client . aclose ()","title":"create"},{"location":"reference/neuroio/iam/spaces/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . _models . Response View Source async def delete ( self , id : int ) -> Response : try : return await self . client . delete ( url = f \"/v1/spaces/{id}/\" ) finally : await self . client . aclose ()","title":"delete"},{"location":"reference/neuroio/iam/spaces/v1/#get_1","text":"def get ( self , id : int ) -> httpx . _models . Response View Source async def get ( self , id : int ) -> Response : try : return await self . client . get ( url = f \"/v1/spaces/{id}/\" ) finally : await self . client . aclose ()","title":"get"},{"location":"reference/neuroio/iam/spaces/v1/#list_1","text":"def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } try : return await self . client . get ( url = \"/v1/spaces/\" , params = data ) finally : await self . client . aclose ()","title":"list"},{"location":"reference/neuroio/iam/spaces/v1/#token_1","text":"def token ( self , id : int , permanent : bool = False ) -> httpx . _models . Response View Source async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return await self . client . post ( url = f \"/v1/spaces/{id}/tokens/\" , json = data ) finally : await self . client . aclose ()","title":"token"},{"location":"reference/neuroio/iam/spaces/v1/#update_1","text":"def update ( self , id : int , name : str ) -> httpx . _models . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } try : return await self . client . patch ( url = f \"/v1/spaces/{id}/\" , json = data ) finally : await self . client . aclose ()","title":"update"},{"location":"reference/neuroio/iam/tokens/","text":"Module neuroio.iam.tokens Sub-modules neuroio.iam.tokens.v1","title":"Index"},{"location":"reference/neuroio/iam/tokens/#module-neuroioiamtokens","text":"","title":"Module neuroio.iam.tokens"},{"location":"reference/neuroio/iam/tokens/#sub-modules","text":"neuroio.iam.tokens.v1","title":"Sub-modules"},{"location":"reference/neuroio/iam/tokens/v1/","text":"Module neuroio.iam.tokens.v1 View Source from typing import Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Tokens ( APIBase ): def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return self . client . post ( url = \"/v1/tokens/\" , json = data ) finally : self . client . close () def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try : return self . client . get ( url = \"/v1/tokens/\" , params = data ) finally : self . client . close () def get ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : self . client . close () def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : try : return self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active }, ) finally : self . client . close () def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None try : return self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally : self . client . close () def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : self . client . close () class TokensAsync ( APIBaseAsync ): async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return await self . client . post ( url = \"/v1/tokens/\" , json = data ) finally : await self . client . aclose () async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try : return await self . client . get ( url = \"/v1/tokens/\" , params = data ) finally : await self . client . aclose () async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return await self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : await self . client . aclose () async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : try : return await self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active }, ) finally : await self . client . aclose () async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None try : return await self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally : await self . client . aclose () async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return await self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : await self . client . aclose () Classes Tokens class Tokens ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Tokens ( APIBase ): def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } try: return self . client . post ( url = \"/v1/tokens/\" , json = data ) finally: self . client . close () def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try: return self . client . get ( url = \"/v1/tokens/\" , params = data ) finally: self . client . close () def get ( self , token_id_or_key: Union [ int , str ]) -> Response: try: return self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally: self . client . close () def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: try: return self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data ={ \"is_active\" : is_active }, ) finally: self . client . close () def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None try: return self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally: self . client . close () def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: try: return self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally: self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods create def create ( self , permanent : bool = False ) -> httpx . _models . Response View Source def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return self . client . post ( url = \"/v1/tokens/\" , json = data ) finally : self . client . close () delete def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . _models . Response View Source def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : self . client . close () delete_list def delete_list ( self , permanent : bool = None ) -> httpx . _models . Response View Source def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None try : return self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally : self . client . close () get def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . _models . Response View Source def get ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : self . client . close () list def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try : return self . client . get ( url = \"/v1/tokens/\" , params = data ) finally : self . client . close () update def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . _models . Response View Source def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : try : return self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active } , ) finally : self . client . close () TokensAsync class TokensAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class TokensAsync ( APIBaseAsync ): async def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } try: return await self . client . post ( url = \"/v1/tokens/\" , json = data ) finally: await self . client . aclose () async def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try: return await self . client . get ( url = \"/v1/tokens/\" , params = data ) finally: await self . client . aclose () async def get ( self , token_id_or_key: Union [ int , str ]) -> Response: try: return await self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally: await self . client . aclose () async def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: try: return await self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data ={ \"is_active\" : is_active }, ) finally: await self . client . aclose () async def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None try: return await self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally: await self . client . aclose () async def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: try: return await self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally: await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods create def create ( self , permanent : bool = False ) -> httpx . _models . Response View Source async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return await self . client . post ( url = \"/v1/tokens/\" , json = data ) finally : await self . client . aclose () delete def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . _models . Response View Source async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return await self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : await self . client . aclose () delete_list def delete_list ( self , permanent : bool = None ) -> httpx . _models . Response View Source async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None try : return await self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally : await self . client . aclose () get def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . _models . Response View Source async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return await self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : await self . client . aclose () list def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try : return await self . client . get ( url = \"/v1/tokens/\" , params = data ) finally : await self . client . aclose () update def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . _models . Response View Source async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : try : return await self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active } , ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/iam/tokens/v1/#module-neuroioiamtokensv1","text":"View Source from typing import Union from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Tokens ( APIBase ): def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return self . client . post ( url = \"/v1/tokens/\" , json = data ) finally : self . client . close () def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try : return self . client . get ( url = \"/v1/tokens/\" , params = data ) finally : self . client . close () def get ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : self . client . close () def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : try : return self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active }, ) finally : self . client . close () def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None try : return self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally : self . client . close () def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : self . client . close () class TokensAsync ( APIBaseAsync ): async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return await self . client . post ( url = \"/v1/tokens/\" , json = data ) finally : await self . client . aclose () async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try : return await self . client . get ( url = \"/v1/tokens/\" , params = data ) finally : await self . client . aclose () async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return await self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : await self . client . aclose () async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : try : return await self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active }, ) finally : await self . client . aclose () async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None try : return await self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally : await self . client . aclose () async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return await self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : await self . client . aclose ()","title":"Module neuroio.iam.tokens.v1"},{"location":"reference/neuroio/iam/tokens/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/iam/tokens/v1/#tokens","text":"class Tokens ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Tokens ( APIBase ): def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } try: return self . client . post ( url = \"/v1/tokens/\" , json = data ) finally: self . client . close () def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try: return self . client . get ( url = \"/v1/tokens/\" , params = data ) finally: self . client . close () def get ( self , token_id_or_key: Union [ int , str ]) -> Response: try: return self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally: self . client . close () def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: try: return self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data ={ \"is_active\" : is_active }, ) finally: self . client . close () def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None try: return self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally: self . client . close () def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: try: return self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally: self . client . close ()","title":"Tokens"},{"location":"reference/neuroio/iam/tokens/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/tokens/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/iam/tokens/v1/#create","text":"def create ( self , permanent : bool = False ) -> httpx . _models . Response View Source def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return self . client . post ( url = \"/v1/tokens/\" , json = data ) finally : self . client . close ()","title":"create"},{"location":"reference/neuroio/iam/tokens/v1/#delete","text":"def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . _models . Response View Source def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : self . client . close ()","title":"delete"},{"location":"reference/neuroio/iam/tokens/v1/#delete_list","text":"def delete_list ( self , permanent : bool = None ) -> httpx . _models . Response View Source def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None try : return self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally : self . client . close ()","title":"delete_list"},{"location":"reference/neuroio/iam/tokens/v1/#get","text":"def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . _models . Response View Source def get ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : self . client . close ()","title":"get"},{"location":"reference/neuroio/iam/tokens/v1/#list","text":"def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try : return self . client . get ( url = \"/v1/tokens/\" , params = data ) finally : self . client . close ()","title":"list"},{"location":"reference/neuroio/iam/tokens/v1/#update","text":"def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . _models . Response View Source def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : try : return self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active } , ) finally : self . client . close ()","title":"update"},{"location":"reference/neuroio/iam/tokens/v1/#tokensasync","text":"class TokensAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class TokensAsync ( APIBaseAsync ): async def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } try: return await self . client . post ( url = \"/v1/tokens/\" , json = data ) finally: await self . client . aclose () async def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try: return await self . client . get ( url = \"/v1/tokens/\" , params = data ) finally: await self . client . aclose () async def get ( self , token_id_or_key: Union [ int , str ]) -> Response: try: return await self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally: await self . client . aclose () async def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: try: return await self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data ={ \"is_active\" : is_active }, ) finally: await self . client . aclose () async def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None try: return await self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally: await self . client . aclose () async def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: try: return await self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally: await self . client . aclose ()","title":"TokensAsync"},{"location":"reference/neuroio/iam/tokens/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/tokens/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/iam/tokens/v1/#create_1","text":"def create ( self , permanent : bool = False ) -> httpx . _models . Response View Source async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } try : return await self . client . post ( url = \"/v1/tokens/\" , json = data ) finally : await self . client . aclose ()","title":"create"},{"location":"reference/neuroio/iam/tokens/v1/#delete_1","text":"def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . _models . Response View Source async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return await self . client . delete ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : await self . client . aclose ()","title":"delete"},{"location":"reference/neuroio/iam/tokens/v1/#delete_list_1","text":"def delete_list ( self , permanent : bool = None ) -> httpx . _models . Response View Source async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None try : return await self . client . delete ( url = \"/v1/tokens/\" , params = data ) finally : await self . client . aclose ()","title":"delete_list"},{"location":"reference/neuroio/iam/tokens/v1/#get_1","text":"def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . _models . Response View Source async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : try : return await self . client . get ( url = f \"/v1/tokens/{token_id_or_key}/\" ) finally : await self . client . aclose ()","title":"get"},{"location":"reference/neuroio/iam/tokens/v1/#list_1","text":"def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . _models . Response View Source async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } try : return await self . client . get ( url = \"/v1/tokens/\" , params = data ) finally : await self . client . aclose ()","title":"list"},{"location":"reference/neuroio/iam/tokens/v1/#update_1","text":"def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . _models . Response View Source async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : try : return await self . client . patch ( url = f \"/v1/tokens/{token_id_or_key}/\" , data = { \"is_active\" : is_active } , ) finally : await self . client . aclose ()","title":"update"},{"location":"reference/neuroio/iam/whoami/","text":"Module neuroio.iam.whoami Sub-modules neuroio.iam.whoami.v1","title":"Index"},{"location":"reference/neuroio/iam/whoami/#module-neuroioiamwhoami","text":"","title":"Module neuroio.iam.whoami"},{"location":"reference/neuroio/iam/whoami/#sub-modules","text":"neuroio.iam.whoami.v1","title":"Sub-modules"},{"location":"reference/neuroio/iam/whoami/v1/","text":"Module neuroio.iam.whoami.v1 View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Whoami ( APIBase ): def me ( self ) -> Response : try : return self . client . get ( url = \"/v1/whoami/\" ) finally : self . client . close () class WhoamiAsync ( APIBaseAsync ): async def me ( self ) -> Response : try : return await self . client . get ( url = \"/v1/whoami/\" ) finally : await self . client . aclose () Classes Whoami class Whoami ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Whoami ( APIBase ): def me ( self ) -> Response: try: return self . client . get ( url = \"/v1/whoami/\" ) finally: self . client . close () Ancestors (in MRO) neuroio.api.base.APIBase abc.ABC Methods me def me ( self ) -> httpx . _models . Response View Source def me ( self ) -> Response : try : return self . client . get ( url = \"/v1/whoami/\" ) finally : self . client . close () WhoamiAsync class WhoamiAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class WhoamiAsync ( APIBaseAsync ): async def me ( self ) -> Response: try: return await self . client . get ( url = \"/v1/whoami/\" ) finally: await self . client . aclose () Ancestors (in MRO) neuroio.api.base.APIBaseAsync abc.ABC Methods me def me ( self ) -> httpx . _models . Response View Source async def me ( self ) -> Response : try : return await self . client . get ( url = \"/v1/whoami/\" ) finally : await self . client . aclose ()","title":"V1"},{"location":"reference/neuroio/iam/whoami/v1/#module-neuroioiamwhoamiv1","text":"View Source from httpx import Response from neuroio.api.base import APIBase , APIBaseAsync class Whoami ( APIBase ): def me ( self ) -> Response : try : return self . client . get ( url = \"/v1/whoami/\" ) finally : self . client . close () class WhoamiAsync ( APIBaseAsync ): async def me ( self ) -> Response : try : return await self . client . get ( url = \"/v1/whoami/\" ) finally : await self . client . aclose ()","title":"Module neuroio.iam.whoami.v1"},{"location":"reference/neuroio/iam/whoami/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/iam/whoami/v1/#whoami","text":"class Whoami ( client : httpx . _client . Client ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Whoami ( APIBase ): def me ( self ) -> Response: try: return self . client . get ( url = \"/v1/whoami/\" ) finally: self . client . close ()","title":"Whoami"},{"location":"reference/neuroio/iam/whoami/v1/#ancestors-in-mro","text":"neuroio.api.base.APIBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/whoami/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/iam/whoami/v1/#me","text":"def me ( self ) -> httpx . _models . Response View Source def me ( self ) -> Response : try : return self . client . get ( url = \"/v1/whoami/\" ) finally : self . client . close ()","title":"me"},{"location":"reference/neuroio/iam/whoami/v1/#whoamiasync","text":"class WhoamiAsync ( client : httpx . _client . AsyncClient ) Helper class that provides a standard way to create an ABC using inheritance. View Source class WhoamiAsync ( APIBaseAsync ): async def me ( self ) -> Response: try: return await self . client . get ( url = \"/v1/whoami/\" ) finally: await self . client . aclose ()","title":"WhoamiAsync"},{"location":"reference/neuroio/iam/whoami/v1/#ancestors-in-mro_1","text":"neuroio.api.base.APIBaseAsync abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/iam/whoami/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/iam/whoami/v1/#me_1","text":"def me ( self ) -> httpx . _models . Response View Source async def me ( self ) -> Response : try : return await self . client . get ( url = \"/v1/whoami/\" ) finally : await self . client . aclose ()","title":"me"}]}