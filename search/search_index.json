{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python API client for NeuroIO Read Latest Documentation - Browse GitHub Code Repository This library strives to be a complete mirror of official NeuroIO API in terms of methods and interfaces. Official latest API documentation can be found here . For your convenience, you can make API calls using sync or async (asyncio) interface. Installation pip install neuroio Note that it is always recommended pinning version of your installed packages. Usage example (sync) An example of how to create a source: from neuroio import Client if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to create source client . sources . create ( name = \"test_name\" ) Now that we have our source created, we can create person inside that source: from neuroio import Client def create_persons_example ( client : Client ): source_name = \"test_name\" with open ( \"image.png\" , \"rb\" ) as f : response = client . persons . create ( image = f , source = source_name , facesize = 1000 , create_on_ha = True , create_on_junk = True , identify_asm = True ) print ( \"Persons Create Response: \\n \" , response . json (), flush = True ) if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to create a person create_persons_example ( client ) Now that we have our source & person created, we can search for persons: from neuroio import Client def search_persons_example ( client : Client ): with open ( \"image.png\" , \"rb\" ) as f : response = client . persons . search ( image = f , identify_asm = True ) print ( \"Persons Search Response: \\n \" , response . json (), flush = True ) if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to search persons search_persons_example ( client ) An example of how to listen for events: import asyncio import json import logging import signal from neuroio import EventListener async def event_handler_func ( event_message : str ): # NOTE: this must be awaitable and accept single param Union[str, bytes] json_message = json . loads ( event_message ) is_ping_response = \"PING\" in json_message . keys () is_auth_response = \"auth\" in json_message . keys () is_error_response = \"error\" in json_message . keys () if is_ping_response : if json_message [ \"PING\" ] != \"PONG\" : # something is wrong with socket connection raise RuntimeError () else : # this is correct pong response on our periodic pings logging . info ( \"Connection is alive\" ) elif is_auth_response : logging . info ( \"Authorized successfully\" ) elif is_error_response : # something is wrong with provided token logging . info ( json_message [ \"error\" ], flush = True ) else : # this must be event about entry itself # now you can inspect json_message for information about that logging . info ( json_message [ \"data\" ][ \"face_image\" ]) async def shutdown ( signal , loop ): \"\"\"Cleanup tasks tied to the service's shutdown.\"\"\" logging . info ( f \"Received exit signal { signal . name } ...\" ) tasks = [ t for t in asyncio . all_tasks () if t is not asyncio . current_task ()] [ task . cancel () for task in tasks ] logging . info ( f \"Cancelling { len ( tasks ) } outstanding tasks\" ) await asyncio . gather ( * tasks , return_exceptions = True ) loop . stop () if __name__ == \"__main__\" : logging . getLogger () . setLevel ( logging . INFO ) # NOTE: You are advised to hook-up uvloop here for improved performance api_token = \"1234567890\" events_listener = EventListener ( api_token = api_token , event_handler_func = event_handler_func ) loop = asyncio . get_event_loop () # May want to catch other signals too signals = ( signal . SIGHUP , signal . SIGTERM , signal . SIGINT ) for s in signals : loop . add_signal_handler ( s , lambda _s = s : asyncio . create_task ( shutdown ( _s , loop )) ) try : loop . create_task ( events_listener . listen ()) loop . run_forever () finally : loop . close () logging . info ( \"Successfully shutdown\" ) For more examples and usage, please refer to the docs . Development setup To install all the development requirements: pip install --upgrade pip pip install poetry poetry install --no-root To run linters & test suite: ./scripts/test.sh Release History 0.1.0 Support for WebSocket Events Drop Python 3.6 support 0.0.9 Fixes to the sources API in terms of required fields 0.0.8 Updated library to latest API version (at the time of this release - 1.3.1) Updated README & docs 0.0.7 Updated library to latest API version (at the time of this release - 1.3.0) Updated requirements Updated README & docs 0.0.6 Updated library to latest API version (at the time of this release - 1.2.1) Updated README & docs 0.0.5 Fixed persistent connection problems Updated requirements Codebase cleanup 0.0.4 Changed the way how we treat httpx connection - now we don't close it after every request (which was supposedly right way in httpx docs) 0.0.3 Updated httpx version, disabled cruft check since it just messes up project files License Distributed under the MIT license. See LICENSE for more information. Contributing Fork it ( https://github.com/yourname/yourproject/fork ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Home"},{"location":"#python-api-client-for-neuroio","text":"Read Latest Documentation - Browse GitHub Code Repository This library strives to be a complete mirror of official NeuroIO API in terms of methods and interfaces. Official latest API documentation can be found here . For your convenience, you can make API calls using sync or async (asyncio) interface.","title":"Python API client for NeuroIO"},{"location":"#installation","text":"pip install neuroio Note that it is always recommended pinning version of your installed packages.","title":"Installation"},{"location":"#usage-example-sync","text":"An example of how to create a source: from neuroio import Client if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to create source client . sources . create ( name = \"test_name\" ) Now that we have our source created, we can create person inside that source: from neuroio import Client def create_persons_example ( client : Client ): source_name = \"test_name\" with open ( \"image.png\" , \"rb\" ) as f : response = client . persons . create ( image = f , source = source_name , facesize = 1000 , create_on_ha = True , create_on_junk = True , identify_asm = True ) print ( \"Persons Create Response: \\n \" , response . json (), flush = True ) if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to create a person create_persons_example ( client ) Now that we have our source & person created, we can search for persons: from neuroio import Client def search_persons_example ( client : Client ): with open ( \"image.png\" , \"rb\" ) as f : response = client . persons . search ( image = f , identify_asm = True ) print ( \"Persons Search Response: \\n \" , response . json (), flush = True ) if __name__ == '__main__' : # api_token is just str with your API token from NeuroIO api_token = \"abcd012345\" # Now create instance of Client. There should be only one per process. client = Client ( api_token = api_token ) # Issue API request to search persons search_persons_example ( client ) An example of how to listen for events: import asyncio import json import logging import signal from neuroio import EventListener async def event_handler_func ( event_message : str ): # NOTE: this must be awaitable and accept single param Union[str, bytes] json_message = json . loads ( event_message ) is_ping_response = \"PING\" in json_message . keys () is_auth_response = \"auth\" in json_message . keys () is_error_response = \"error\" in json_message . keys () if is_ping_response : if json_message [ \"PING\" ] != \"PONG\" : # something is wrong with socket connection raise RuntimeError () else : # this is correct pong response on our periodic pings logging . info ( \"Connection is alive\" ) elif is_auth_response : logging . info ( \"Authorized successfully\" ) elif is_error_response : # something is wrong with provided token logging . info ( json_message [ \"error\" ], flush = True ) else : # this must be event about entry itself # now you can inspect json_message for information about that logging . info ( json_message [ \"data\" ][ \"face_image\" ]) async def shutdown ( signal , loop ): \"\"\"Cleanup tasks tied to the service's shutdown.\"\"\" logging . info ( f \"Received exit signal { signal . name } ...\" ) tasks = [ t for t in asyncio . all_tasks () if t is not asyncio . current_task ()] [ task . cancel () for task in tasks ] logging . info ( f \"Cancelling { len ( tasks ) } outstanding tasks\" ) await asyncio . gather ( * tasks , return_exceptions = True ) loop . stop () if __name__ == \"__main__\" : logging . getLogger () . setLevel ( logging . INFO ) # NOTE: You are advised to hook-up uvloop here for improved performance api_token = \"1234567890\" events_listener = EventListener ( api_token = api_token , event_handler_func = event_handler_func ) loop = asyncio . get_event_loop () # May want to catch other signals too signals = ( signal . SIGHUP , signal . SIGTERM , signal . SIGINT ) for s in signals : loop . add_signal_handler ( s , lambda _s = s : asyncio . create_task ( shutdown ( _s , loop )) ) try : loop . create_task ( events_listener . listen ()) loop . run_forever () finally : loop . close () logging . info ( \"Successfully shutdown\" ) For more examples and usage, please refer to the docs .","title":"Usage example (sync)"},{"location":"#development-setup","text":"To install all the development requirements: pip install --upgrade pip pip install poetry poetry install --no-root To run linters & test suite: ./scripts/test.sh","title":"Development setup"},{"location":"#release-history","text":"0.1.0 Support for WebSocket Events Drop Python 3.6 support 0.0.9 Fixes to the sources API in terms of required fields 0.0.8 Updated library to latest API version (at the time of this release - 1.3.1) Updated README & docs 0.0.7 Updated library to latest API version (at the time of this release - 1.3.0) Updated requirements Updated README & docs 0.0.6 Updated library to latest API version (at the time of this release - 1.2.1) Updated README & docs 0.0.5 Fixed persistent connection problems Updated requirements Codebase cleanup 0.0.4 Changed the way how we treat httpx connection - now we don't close it after every request (which was supposedly right way in httpx docs) 0.0.3 Updated httpx version, disabled cruft check since it just messes up project files","title":"Release History"},{"location":"#license","text":"Distributed under the MIT license. See LICENSE for more information.","title":"License"},{"location":"#contributing","text":"Fork it ( https://github.com/yourname/yourproject/fork ) Create your feature branch ( git checkout -b feature/fooBar ) Commit your changes ( git commit -am 'Add some fooBar' ) Push to the branch ( git push origin feature/fooBar ) Create a new Pull Request","title":"Contributing"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of neuroio simply run: pip3 install neuroio OR poetry add neuroio OR pipenv install neuroio Changelog 0.1.0 Support for WebSocket Events Drop Python 3.6 support 0.0.9 Fixes to the sources API in terms of required fields 0.0.8 Updated library to latest API version (at the time of this release - 1.3.1) Updated README & docs 0.0.7 Updated library to latest API version (at the time of this release - 1.3.0) Updated requirements Updated README & docs 0.0.6 Updated library to latest API version (at the time of this release - 1.2.1) Updated README & docs 0.0.5 Fixed persistent connection problems Updated requirements Codebase cleanup 0.0.4 Changed the way how we treat httpx connection - now we don't close it after every request (which was supposedly right way in httpx docs) 0.0.3 Updated httpx version, disabled cruft check since it just messes up project files","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of neuroio simply run: pip3 install neuroio OR poetry add neuroio OR pipenv install neuroio","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"0.1.0 Support for WebSocket Events Drop Python 3.6 support 0.0.9 Fixes to the sources API in terms of required fields 0.0.8 Updated library to latest API version (at the time of this release - 1.3.1) Updated README & docs 0.0.7 Updated library to latest API version (at the time of this release - 1.3.0) Updated requirements Updated README & docs 0.0.6 Updated library to latest API version (at the time of this release - 1.2.1) Updated README & docs 0.0.5 Fixed persistent connection problems Updated requirements Codebase cleanup 0.0.4 Changed the way how we treat httpx connection - now we don't close it after every request (which was supposedly right way in httpx docs) 0.0.3 Updated httpx version, disabled cruft check since it just messes up project files","title":"Changelog"},{"location":"docs/authentication/","text":"Authentication Basic concepts There are two main namespaces in NeuroIO: IAM & API. IAM (identity & access management) allows you to follow authentication flow using username/password, create API access tokens for your application, manage Spaces and many more. API (application programming interface) allows you to interact with database of people, create sources of data, manage notifications settings and many more. Some things to note about access tokens: In order to access NeuroIO API, you need valid token. Valid token is the one, that is currently active & not expired. Tokens could be temporary & permanent (those do not expire automatically). As of now, all temporary tokens have the same TTL of 24 hours since creation time. Login This method creates new temporary token for user if username/password pair is correct. from neuroio import Client c = Client () login_response = c . auth . login ( username = \"usr\" , password = \"pwd\" ) json_login_response = login_response . json () if login_response . status_code == 200 : print ( \"Login Successful.\" ) print ( json_login_response ) # { # 'user': { # 'username': 'usr' # }, # 'token': { # 'id': 1, # 'key': 'abcd', # 'is_active': True, # 'created': '2021-05-28T10:37:51.433760+00:00', # 'expires': '2021-05-29T10:37:51.433563+00:00' # } # } else : print ( \"Login failed.\" ) print ( json_login_response ) # { # 'error_codes': [602], # 'message': 'Username and password do not match.', # 'fields': [] # } After that you need to re-create Client instance with as so: from neuroio import Client client = Client ( api_token = json_login_response [ \"token\" ][ \"key\" ]) # From now on, use this new client instance whenever you access API Change password Given correct current password, this method allows you to specify new password & optionally reset all tokens that were previously created. from neuroio import Client c = Client ( api_token = \"abcd\" ) login_response = c . auth . password_change ( old_password = \"pwd\" , new_password = \"newpwd\" , reset_tokens = False ) json_response = login_response . json () if login_response . status_code == 204 : print ( \"Password change successful.\" ) else : print ( \"Password change failed.\" ) print ( json_response ) # { # 'error_codes': [400], # 'message': 'Validation error.', # 'fields': [ # { # 'name': 'old_password', # 'message': 'Incorrect password.', # 'error_code': 400 # } # ] # }","title":"Authentication"},{"location":"docs/authentication/#authentication","text":"","title":"Authentication"},{"location":"docs/authentication/#basic-concepts","text":"There are two main namespaces in NeuroIO: IAM & API. IAM (identity & access management) allows you to follow authentication flow using username/password, create API access tokens for your application, manage Spaces and many more. API (application programming interface) allows you to interact with database of people, create sources of data, manage notifications settings and many more. Some things to note about access tokens: In order to access NeuroIO API, you need valid token. Valid token is the one, that is currently active & not expired. Tokens could be temporary & permanent (those do not expire automatically). As of now, all temporary tokens have the same TTL of 24 hours since creation time.","title":"Basic concepts"},{"location":"docs/authentication/#login","text":"This method creates new temporary token for user if username/password pair is correct. from neuroio import Client c = Client () login_response = c . auth . login ( username = \"usr\" , password = \"pwd\" ) json_login_response = login_response . json () if login_response . status_code == 200 : print ( \"Login Successful.\" ) print ( json_login_response ) # { # 'user': { # 'username': 'usr' # }, # 'token': { # 'id': 1, # 'key': 'abcd', # 'is_active': True, # 'created': '2021-05-28T10:37:51.433760+00:00', # 'expires': '2021-05-29T10:37:51.433563+00:00' # } # } else : print ( \"Login failed.\" ) print ( json_login_response ) # { # 'error_codes': [602], # 'message': 'Username and password do not match.', # 'fields': [] # } After that you need to re-create Client instance with as so: from neuroio import Client client = Client ( api_token = json_login_response [ \"token\" ][ \"key\" ]) # From now on, use this new client instance whenever you access API","title":"Login"},{"location":"docs/authentication/#change-password","text":"Given correct current password, this method allows you to specify new password & optionally reset all tokens that were previously created. from neuroio import Client c = Client ( api_token = \"abcd\" ) login_response = c . auth . password_change ( old_password = \"pwd\" , new_password = \"newpwd\" , reset_tokens = False ) json_response = login_response . json () if login_response . status_code == 204 : print ( \"Password change successful.\" ) else : print ( \"Password change failed.\" ) print ( json_response ) # { # 'error_codes': [400], # 'message': 'Validation error.', # 'fields': [ # { # 'name': 'old_password', # 'message': 'Incorrect password.', # 'error_code': 400 # } # ] # }","title":"Change password"},{"location":"docs/basics/","text":"Common usage patterns Basic concepts For any call you do, in response you'll get httpx response object. So you can do anything with it as per httpx docs . You can parse response as json, read http status code, response headers and all that good stuff. Note that responses are only of two kinds - successes (< 400) & errors (>= 400). Please refer to the documentation of NeuroIO API for response format in each individual case. Unlike successful responses, errors are always the same format which can be easily parsed on client's side like so: from neuroio import Client class NeuroIOFieldError : def __init__ ( self , name : str , message : str , error_code : int ): self . name = name self . message = message self . error_code = error_code class NeuroIOException ( Exception ): def __init__ ( self , json_response : dict ): self . error_codes = json_response [ \"error_codes\" ] self . message = json_response [ \"message\" ] self . fields = [ NeuroIOFieldError ( ** f ) for f in json_response [ \"fields\" ]] if __name__ == '__main__' : c = Client () response = c . spaces . create ( name = \"test\" ) if response . status_code >= 400 : exc = NeuroIOException ( json_response = response . json ()) raise exc","title":"Basics"},{"location":"docs/basics/#common-usage-patterns","text":"","title":"Common usage patterns"},{"location":"docs/basics/#basic-concepts","text":"For any call you do, in response you'll get httpx response object. So you can do anything with it as per httpx docs . You can parse response as json, read http status code, response headers and all that good stuff. Note that responses are only of two kinds - successes (< 400) & errors (>= 400). Please refer to the documentation of NeuroIO API for response format in each individual case. Unlike successful responses, errors are always the same format which can be easily parsed on client's side like so: from neuroio import Client class NeuroIOFieldError : def __init__ ( self , name : str , message : str , error_code : int ): self . name = name self . message = message self . error_code = error_code class NeuroIOException ( Exception ): def __init__ ( self , json_response : dict ): self . error_codes = json_response [ \"error_codes\" ] self . message = json_response [ \"message\" ] self . fields = [ NeuroIOFieldError ( ** f ) for f in json_response [ \"fields\" ]] if __name__ == '__main__' : c = Client () response = c . spaces . create ( name = \"test\" ) if response . status_code >= 400 : exc = NeuroIOException ( json_response = response . json ()) raise exc","title":"Basic concepts"},{"location":"docs/billing/","text":"Billing Basic concepts Billing module provides methods to get insight about user's usage of platform resources. You can filter billing data by month, spaces, and types of events. Event types options are: API_CALLS = 1 PERSONS_STORAGE = 2 ENTRY_STORAGE = 3 SOURCE_LICENSES = 4 Billing Usage Authorized Client() required. This method returns paginated list of billing usage. Available only for users and spaces. Available only for access tokens. Can be filtered by name using list of event types & by list of space ids and months range. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . billing . usage ( month_from = \"2020-01\" , month_to = \"2020-06\" , spaces_ids = [ 4 , 5 , 6 ], event_types = [ 1 , 2 , 3 ], limit = 10 , offset = 5 , ) json_response = response . json () print ( json_response ) Billing Total Usage Authorized Client() required. This method returns billing usage. Available only for users and spaces. Available only for access tokens. Can be filtered by name using list of event types and months range. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . billing . usage_total ( month_from = \"2020-01\" , month_to = \"2020-06\" , event_types = [ 1 , 2 , 3 ], spaces_ids = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response )","title":"Billing"},{"location":"docs/billing/#billing","text":"","title":"Billing"},{"location":"docs/billing/#basic-concepts","text":"Billing module provides methods to get insight about user's usage of platform resources. You can filter billing data by month, spaces, and types of events. Event types options are: API_CALLS = 1 PERSONS_STORAGE = 2 ENTRY_STORAGE = 3 SOURCE_LICENSES = 4","title":"Basic concepts"},{"location":"docs/billing/#billing-usage","text":"Authorized Client() required. This method returns paginated list of billing usage. Available only for users and spaces. Available only for access tokens. Can be filtered by name using list of event types & by list of space ids and months range. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . billing . usage ( month_from = \"2020-01\" , month_to = \"2020-06\" , spaces_ids = [ 4 , 5 , 6 ], event_types = [ 1 , 2 , 3 ], limit = 10 , offset = 5 , ) json_response = response . json () print ( json_response )","title":"Billing Usage"},{"location":"docs/billing/#billing-total-usage","text":"Authorized Client() required. This method returns billing usage. Available only for users and spaces. Available only for access tokens. Can be filtered by name using list of event types and months range. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . billing . usage_total ( month_from = \"2020-01\" , month_to = \"2020-06\" , event_types = [ 1 , 2 , 3 ], spaces_ids = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response )","title":"Billing Total Usage"},{"location":"docs/entries/","text":"Entries Basic concepts Entries are containers which store the results of the processing of a photo that was uploaded to the platform. The source of the photo can be either the user (when they create or re-initialize a persona) or a surveillance camera that is connected to the platform via the preprocessing server. When a user uploads a photo, two types of entries may appear in the platform: new and reinit. When video streams from network cameras are processed, all types of entries can appear in the platform: new, reinit, exact, ha, junk, nm and det. List Entries Authorized Client() required. This method returns paginated list of entries. All the filtering parameters in this call are optional, this example just shows every single option. For sex : 0 - male, 1 - female. import datetime from neuroio import Client from neuroio.constants import EntryLiveness , EntryMood , EntryResult c = Client ( api_token = \"abcd\" ) response = c . entries . list ( pid = [ \"abcdef01-abcd-abcd01-abcdef01\" ], result = [ EntryResult . NEW ], age_from = 1 , age_to = 100 , sex = 0 , mood = [ EntryMood . FEAR ], liveness = [ EntryLiveness . PASSED ], sources_ids = [ 1 ], spaces_ids = [ 1 ], date_from = datetime . datetime ( year = 2020 , month = 1 , day = 31 ), date_to = datetime . datetime . utcnow (), limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response ) Get the statistics for a persona\u2019s id Authorized Client() required. This method returns statistics for a person, if found by its pid. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . entries . get ( pid = \"abcdef01-abcd-abcd01-abcdef01\" ) json_response = response . json () print ( json_response ) Delete Entry by id Authorized Client() required. This method deletes entry, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . entries . delete ( id = 1 ) if response . status_code == 204 : print ( \"Entry deleted successfully.\" )","title":"Entries"},{"location":"docs/entries/#entries","text":"","title":"Entries"},{"location":"docs/entries/#basic-concepts","text":"Entries are containers which store the results of the processing of a photo that was uploaded to the platform. The source of the photo can be either the user (when they create or re-initialize a persona) or a surveillance camera that is connected to the platform via the preprocessing server. When a user uploads a photo, two types of entries may appear in the platform: new and reinit. When video streams from network cameras are processed, all types of entries can appear in the platform: new, reinit, exact, ha, junk, nm and det.","title":"Basic concepts"},{"location":"docs/entries/#list-entries","text":"Authorized Client() required. This method returns paginated list of entries. All the filtering parameters in this call are optional, this example just shows every single option. For sex : 0 - male, 1 - female. import datetime from neuroio import Client from neuroio.constants import EntryLiveness , EntryMood , EntryResult c = Client ( api_token = \"abcd\" ) response = c . entries . list ( pid = [ \"abcdef01-abcd-abcd01-abcdef01\" ], result = [ EntryResult . NEW ], age_from = 1 , age_to = 100 , sex = 0 , mood = [ EntryMood . FEAR ], liveness = [ EntryLiveness . PASSED ], sources_ids = [ 1 ], spaces_ids = [ 1 ], date_from = datetime . datetime ( year = 2020 , month = 1 , day = 31 ), date_to = datetime . datetime . utcnow (), limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response )","title":"List Entries"},{"location":"docs/entries/#get-the-statistics-for-a-personas-id","text":"Authorized Client() required. This method returns statistics for a person, if found by its pid. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . entries . get ( pid = \"abcdef01-abcd-abcd01-abcdef01\" ) json_response = response . json () print ( json_response )","title":"Get the statistics for a persona\u2019s id"},{"location":"docs/entries/#delete-entry-by-id","text":"Authorized Client() required. This method deletes entry, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . entries . delete ( id = 1 ) if response . status_code == 204 : print ( \"Entry deleted successfully.\" )","title":"Delete Entry by id"},{"location":"docs/events/","text":"WebSocket Events Listener Basic concepts Included class EventListener is used to asynchronously listen to events coming over WebSocket connection via wss://events.neuroio.com Reference for communication protocol & objects structure can be found here: https://kb.neuroio.com/#/notifications?id=creating-a-connection-to-the-platform-with-websocket There are only 4 types of messages as of now: 1) Response for AUTH message 2) Response for PING message 3) Error messages 4) Event data message We highly recommend using uvloop library for better performance in high-load usage scenarios. This is a basic but sufficient example of how to use EventListener and receive events in your application: import asyncio import json import logging import signal from neuroio import EventListener async def event_handler_func ( event_message : str ): # NOTE: this must be awaitable and accept single param Union[str, bytes] json_message = json . loads ( event_message ) is_ping_response = \"PING\" in json_message . keys () is_auth_response = \"auth\" in json_message . keys () is_error_response = \"error\" in json_message . keys () if is_ping_response : if json_message [ \"PING\" ] != \"PONG\" : # something is wrong with socket connection raise RuntimeError () else : # this is correct pong response on our periodic pings logging . info ( \"Connection is alive\" ) elif is_auth_response : logging . info ( \"Authorized successfully\" ) elif is_error_response : # something is wrong with provided token logging . info ( json_message [ \"error\" ], flush = True ) else : # this must be event about entry itself # now you can inspect json_message for information about that logging . info ( json_message [ \"data\" ][ \"face_image\" ]) async def shutdown ( signal , loop ): \"\"\"Cleanup tasks tied to the service's shutdown.\"\"\" logging . info ( f \"Received exit signal { signal . name } ...\" ) tasks = [ t for t in asyncio . all_tasks () if t is not asyncio . current_task ()] [ task . cancel () for task in tasks ] logging . info ( f \"Cancelling { len ( tasks ) } outstanding tasks\" ) await asyncio . gather ( * tasks , return_exceptions = True ) loop . stop () if __name__ == \"__main__\" : logging . getLogger () . setLevel ( logging . INFO ) # NOTE: You are advised to hook-up uvloop here for improved performance api_token = \"1234567890\" events_listener = EventListener ( api_token = api_token , event_handler_func = event_handler_func ) loop = asyncio . get_event_loop () # May want to catch other signals too signals = ( signal . SIGHUP , signal . SIGTERM , signal . SIGINT ) for s in signals : loop . add_signal_handler ( s , lambda _s = s : asyncio . create_task ( shutdown ( _s , loop )) ) try : loop . create_task ( events_listener . listen ()) loop . run_forever () finally : loop . close () logging . info ( \"Successfully shutdown\" )","title":"Events"},{"location":"docs/events/#websocket-events-listener","text":"","title":"WebSocket Events Listener"},{"location":"docs/events/#basic-concepts","text":"Included class EventListener is used to asynchronously listen to events coming over WebSocket connection via wss://events.neuroio.com Reference for communication protocol & objects structure can be found here: https://kb.neuroio.com/#/notifications?id=creating-a-connection-to-the-platform-with-websocket There are only 4 types of messages as of now: 1) Response for AUTH message 2) Response for PING message 3) Error messages 4) Event data message We highly recommend using uvloop library for better performance in high-load usage scenarios. This is a basic but sufficient example of how to use EventListener and receive events in your application: import asyncio import json import logging import signal from neuroio import EventListener async def event_handler_func ( event_message : str ): # NOTE: this must be awaitable and accept single param Union[str, bytes] json_message = json . loads ( event_message ) is_ping_response = \"PING\" in json_message . keys () is_auth_response = \"auth\" in json_message . keys () is_error_response = \"error\" in json_message . keys () if is_ping_response : if json_message [ \"PING\" ] != \"PONG\" : # something is wrong with socket connection raise RuntimeError () else : # this is correct pong response on our periodic pings logging . info ( \"Connection is alive\" ) elif is_auth_response : logging . info ( \"Authorized successfully\" ) elif is_error_response : # something is wrong with provided token logging . info ( json_message [ \"error\" ], flush = True ) else : # this must be event about entry itself # now you can inspect json_message for information about that logging . info ( json_message [ \"data\" ][ \"face_image\" ]) async def shutdown ( signal , loop ): \"\"\"Cleanup tasks tied to the service's shutdown.\"\"\" logging . info ( f \"Received exit signal { signal . name } ...\" ) tasks = [ t for t in asyncio . all_tasks () if t is not asyncio . current_task ()] [ task . cancel () for task in tasks ] logging . info ( f \"Cancelling { len ( tasks ) } outstanding tasks\" ) await asyncio . gather ( * tasks , return_exceptions = True ) loop . stop () if __name__ == \"__main__\" : logging . getLogger () . setLevel ( logging . INFO ) # NOTE: You are advised to hook-up uvloop here for improved performance api_token = \"1234567890\" events_listener = EventListener ( api_token = api_token , event_handler_func = event_handler_func ) loop = asyncio . get_event_loop () # May want to catch other signals too signals = ( signal . SIGHUP , signal . SIGTERM , signal . SIGINT ) for s in signals : loop . add_signal_handler ( s , lambda _s = s : asyncio . create_task ( shutdown ( _s , loop )) ) try : loop . create_task ( events_listener . listen ()) loop . run_forever () finally : loop . close () logging . info ( \"Successfully shutdown\" )","title":"Basic concepts"},{"location":"docs/groups/","text":"Person Groups Basic concepts You can group persons into arbitrary lists. If the identified person is included in any group or groups, then notifications from the platform will contain not only the person's identifier, but also the names of all groups in which user is included. Each person can be added to any number of groups. Each group can contain a maximum of 100,000 persons. Create Person Group Authorized Client() required. This method creates new person group. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . create ( name = \"test\" ) json_response = response . json () print ( json_response ) List Person Groups Authorized Client() required. This method returns paginated list of groups. Can be filtered by name using q . All the filtering parameters in this call are optional, this example just shows every single option. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . list ( q = \"te\" , pids_include = [ \"abcdef01-abcd-abcd01-abcdef01\" ], pids_exclude = [ \"fedcab10-dcba-dcba10-fedcab10\" ], groups_ids = [ 1 , 2 , 3 ], spaces_ids = [ 4 , 5 , 6 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response ) Get Person Group by id Authorized Client() required. This method returns group info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . get ( id = 1 ) json_response = response . json () print ( json_response ) Update Person Group by id Authorized Client() required. This method updates group info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . update ( id = 1 , name = \"newname\" ) json_response = response . json () print ( json_response ) Delete Person Group by id Authorized Client() required. This method deletes group, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . groups . delete ( id = 1 ) if response . status_code == 204 : print ( \"Person Group deleted successfully.\" ) Get a list of persons in a group Authorized Client() required. This method returns paginated results of persons that are in a group, if found by id. You can filter out list by specifying exact list of PIDs. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . persons ( id = 1 , pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], limit = 5 , offset = 0 ) json_response = response . json () print ( json_response ) Add persons to groups Authorized Client() required. This method allows you to add many persons to many groups in one request. Max PIDs in request - 100. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . add ( pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], groups_ids = [ 1 , 2 , 3 , 4 , 5 ] ) Remove persons to groups Authorized Client() required. This method allows you to remove many persons from many groups in one request. Max PIDs in request - 100. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . remove ( pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], groups_ids = [ 1 , 2 , 3 , 4 , 5 ] )","title":"Groups"},{"location":"docs/groups/#person-groups","text":"","title":"Person Groups"},{"location":"docs/groups/#basic-concepts","text":"You can group persons into arbitrary lists. If the identified person is included in any group or groups, then notifications from the platform will contain not only the person's identifier, but also the names of all groups in which user is included. Each person can be added to any number of groups. Each group can contain a maximum of 100,000 persons.","title":"Basic concepts"},{"location":"docs/groups/#create-person-group","text":"Authorized Client() required. This method creates new person group. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . create ( name = \"test\" ) json_response = response . json () print ( json_response )","title":"Create Person Group"},{"location":"docs/groups/#list-person-groups","text":"Authorized Client() required. This method returns paginated list of groups. Can be filtered by name using q . All the filtering parameters in this call are optional, this example just shows every single option. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . list ( q = \"te\" , pids_include = [ \"abcdef01-abcd-abcd01-abcdef01\" ], pids_exclude = [ \"fedcab10-dcba-dcba10-fedcab10\" ], groups_ids = [ 1 , 2 , 3 ], spaces_ids = [ 4 , 5 , 6 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response )","title":"List Person Groups"},{"location":"docs/groups/#get-person-group-by-id","text":"Authorized Client() required. This method returns group info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . get ( id = 1 ) json_response = response . json () print ( json_response )","title":"Get Person Group by id"},{"location":"docs/groups/#update-person-group-by-id","text":"Authorized Client() required. This method updates group info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . update ( id = 1 , name = \"newname\" ) json_response = response . json () print ( json_response )","title":"Update Person Group by id"},{"location":"docs/groups/#delete-person-group-by-id","text":"Authorized Client() required. This method deletes group, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . groups . delete ( id = 1 ) if response . status_code == 204 : print ( \"Person Group deleted successfully.\" )","title":"Delete Person Group by id"},{"location":"docs/groups/#get-a-list-of-persons-in-a-group","text":"Authorized Client() required. This method returns paginated results of persons that are in a group, if found by id. You can filter out list by specifying exact list of PIDs. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . persons ( id = 1 , pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], limit = 5 , offset = 0 ) json_response = response . json () print ( json_response )","title":"Get a list of persons in a group"},{"location":"docs/groups/#add-persons-to-groups","text":"Authorized Client() required. This method allows you to add many persons to many groups in one request. Max PIDs in request - 100. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . add ( pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], groups_ids = [ 1 , 2 , 3 , 4 , 5 ] )","title":"Add persons to groups"},{"location":"docs/groups/#remove-persons-to-groups","text":"Authorized Client() required. This method allows you to remove many persons from many groups in one request. Max PIDs in request - 100. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . groups . remove ( pids = [ \"abcdef01-abcd-abcd01-abcdef01\" ], groups_ids = [ 1 , 2 , 3 , 4 , 5 ] )","title":"Remove persons to groups"},{"location":"docs/licenses/","text":"Licenses Basic concepts Create License Authorized Client() required. This method creates new license with specified name. All of the parameters, except name , are optional. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . licenses . sources . create ( name = \"test\" , entry_storage_days = 1 ) json_response = response . json () print ( json_response ) List Licenses Authorized Client() required. This method returns paginated list of licenses. Can be filtered by name using q & by list of space ids. Filter is_bound can be used to retrieve only those licenses that are bound (or not bound) to a source. import datetime from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . licenses . sources . list ( q = \"te\" , date_from = datetime . datetime ( year = 2020 , month = 1 , day = 31 ), date_to = datetime . datetime . utcnow (), is_bound = True , limit = 10 , offset = 5 , ) json_response = response . json () print ( json_response ) Get License by id Authorized Client() required. This method returns license info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . licenses . sources . get ( id = 1 ) json_response = response . json () print ( json_response ) Update License by id Authorized Client() required. This method updates license info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . licenses . sources . update ( id = 1 , name = \"test\" , is_active = True , entry_storage_days = 3 ) json_response = response . json () print ( json_response )","title":"Licenses"},{"location":"docs/licenses/#licenses","text":"","title":"Licenses"},{"location":"docs/licenses/#basic-concepts","text":"","title":"Basic concepts"},{"location":"docs/licenses/#create-license","text":"Authorized Client() required. This method creates new license with specified name. All of the parameters, except name , are optional. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . licenses . sources . create ( name = \"test\" , entry_storage_days = 1 ) json_response = response . json () print ( json_response )","title":"Create License"},{"location":"docs/licenses/#list-licenses","text":"Authorized Client() required. This method returns paginated list of licenses. Can be filtered by name using q & by list of space ids. Filter is_bound can be used to retrieve only those licenses that are bound (or not bound) to a source. import datetime from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . licenses . sources . list ( q = \"te\" , date_from = datetime . datetime ( year = 2020 , month = 1 , day = 31 ), date_to = datetime . datetime . utcnow (), is_bound = True , limit = 10 , offset = 5 , ) json_response = response . json () print ( json_response )","title":"List Licenses"},{"location":"docs/licenses/#get-license-by-id","text":"Authorized Client() required. This method returns license info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . licenses . sources . get ( id = 1 ) json_response = response . json () print ( json_response )","title":"Get License by id"},{"location":"docs/licenses/#update-license-by-id","text":"Authorized Client() required. This method updates license info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . licenses . sources . update ( id = 1 , name = \"test\" , is_active = True , entry_storage_days = 3 ) json_response = response . json () print ( json_response )","title":"Update License by id"},{"location":"docs/notifications/","text":"Notifications Basic concepts The notification service allows you to receive filtered data about events as soon as they happened, and without the need to constantly query the platform. The platform supports the following types of transport: webhook - when an event occurs, a POST or GET request with a fixed syntax is sent to the specified url; websocket - the client application itself initiates a connection to the service and receives a notification on it in the format of websocket messages. For applications in which the speed of informing about events that have occurred in the platform is important, it is recommended to use a websocket connection. This type of transport is always on, no pre-filtering is provided. For client applications operating in gray networks and receiving data directly from the platform, only websocket transport is suitable for use. Folliwing sections only apply to webhooks! Create Notification Authorized Client() required. This method creates new notification with specified parameters. from neuroio import Client from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , ) c = Client ( api_token = \"abcd\" ) response = c . notifications . create ( name = \"test\" , http_method = HttpMethod . POST , destination_url = \"https://neuroio.com/\" , is_active = True , moods = [ EntryMood . FEAR ], results = [ EntryResult . NEW ], liveness = [ EntryLiveness . PASSED ], age_from = 1 , age_to = 100 , sex = Sex . MALE , sources = [ 1 , 2 , 3 ], persons_groups = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response ) List Notifications Authorized Client() required. This method returns paginated list of notifications. Can be filtered by name using q , also, by list of Spaces IDs. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . notifications . list ( q = \"te\" , spaces_ids = [ 1 , 2 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response ) Get Notification by id Authorized Client() required. This method returns notification info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . notifications . get ( id = 1 ) json_response = response . json () print ( json_response ) Update Notification by id Authorized Client() required. This method updates notification info, if found by its id. from neuroio import Client from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , ) c = Client ( api_token = \"abcd\" ) response = c . notifications . update ( name = \"test\" , http_method = HttpMethod . POST , destination_url = \"https://neuroio.com/\" , is_active = True , moods = [ EntryMood . FEAR ], results = [ EntryResult . NEW ], liveness = [ EntryLiveness . PASSED ], age_from = 1 , age_to = 100 , sex = Sex . MALE , sources = [ 1 , 2 , 3 ], persons_groups = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response ) Delete Notification by id Authorized Client() required. This method deletes notification, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . notifications . delete ( id = 1 ) if response . status_code == 204 : print ( \"Notification deleted successfully.\" )","title":"Notifications"},{"location":"docs/notifications/#notifications","text":"","title":"Notifications"},{"location":"docs/notifications/#basic-concepts","text":"The notification service allows you to receive filtered data about events as soon as they happened, and without the need to constantly query the platform. The platform supports the following types of transport: webhook - when an event occurs, a POST or GET request with a fixed syntax is sent to the specified url; websocket - the client application itself initiates a connection to the service and receives a notification on it in the format of websocket messages. For applications in which the speed of informing about events that have occurred in the platform is important, it is recommended to use a websocket connection. This type of transport is always on, no pre-filtering is provided. For client applications operating in gray networks and receiving data directly from the platform, only websocket transport is suitable for use. Folliwing sections only apply to webhooks!","title":"Basic concepts"},{"location":"docs/notifications/#create-notification","text":"Authorized Client() required. This method creates new notification with specified parameters. from neuroio import Client from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , ) c = Client ( api_token = \"abcd\" ) response = c . notifications . create ( name = \"test\" , http_method = HttpMethod . POST , destination_url = \"https://neuroio.com/\" , is_active = True , moods = [ EntryMood . FEAR ], results = [ EntryResult . NEW ], liveness = [ EntryLiveness . PASSED ], age_from = 1 , age_to = 100 , sex = Sex . MALE , sources = [ 1 , 2 , 3 ], persons_groups = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response )","title":"Create Notification"},{"location":"docs/notifications/#list-notifications","text":"Authorized Client() required. This method returns paginated list of notifications. Can be filtered by name using q , also, by list of Spaces IDs. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . notifications . list ( q = \"te\" , spaces_ids = [ 1 , 2 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response )","title":"List Notifications"},{"location":"docs/notifications/#get-notification-by-id","text":"Authorized Client() required. This method returns notification info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . notifications . get ( id = 1 ) json_response = response . json () print ( json_response )","title":"Get Notification by id"},{"location":"docs/notifications/#update-notification-by-id","text":"Authorized Client() required. This method updates notification info, if found by its id. from neuroio import Client from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , ) c = Client ( api_token = \"abcd\" ) response = c . notifications . update ( name = \"test\" , http_method = HttpMethod . POST , destination_url = \"https://neuroio.com/\" , is_active = True , moods = [ EntryMood . FEAR ], results = [ EntryResult . NEW ], liveness = [ EntryLiveness . PASSED ], age_from = 1 , age_to = 100 , sex = Sex . MALE , sources = [ 1 , 2 , 3 ], persons_groups = [ 4 , 5 , 6 ], ) json_response = response . json () print ( json_response )","title":"Update Notification by id"},{"location":"docs/notifications/#delete-notification-by-id","text":"Authorized Client() required. This method deletes notification, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . notifications . delete ( id = 1 ) if response . status_code == 204 : print ( \"Notification deleted successfully.\" )","title":"Delete Notification by id"},{"location":"docs/persons/","text":"Persons Basic concepts Persons are wrapped face embeddings that come through user uploads or automatically from connected cameras. In fact, this is the similar \"tag\" as sources, but if the sources indicate where the photo came from, then the person is a tag indicating who is on it. Entry types that are always associated with persons: new, reinit, exact, ha, junk. The types of records nm, det cannot be associated with persons, since in this case the platform does not know who is in the photo. Any work with persons implies the automatic scope of the token with which the request is made. When created, created from id, upon reinit, Entries and Persons fall into the same space where the source specified in the request is located (again, provided that this source is visible from the current token space). Create Person Authorized Client() required. This method creates (or finds, to avoid duplicates) person using provided photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . create ( image = f , source = \"test\" , facesize = 1000 , create_on_ha = True , create_on_junk = False , identify_asm = True ) json_response = response . json () print ( json_response ) Create Person from Entry Authorized Client() required. This method creates new persons from photo on specified Entry ID. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . persons . create_by_entry ( id = 1 , create_on_ha = False , create_on_junk = False ) json_response = response . json () print ( json_response ) Re-init Person from photo in specified Entry ID. Authorized Client() required. This method changes face embedding for a specified persons to the one, extracted from photo in Entry. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . persons . reinit ( id = 1 ) # NOTE: There is empty response in case of successful operation Re-init Person from provided photo Authorized Client() required. This method changes face embedding for a specified persons to the one, extracted from provided photo. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . reinit_by_photo ( pid = \"abcdef01-abcd-abcd01-abcdef01\" , image = f , source = \"test\" , facesize = 1000 , identify_asm = True , result = EntryResult . HA , ) # NOTE: There is empty response in case of successful operation Search Person by provided photo Authorized Client() required. This method searches for a person in database, comparing face embedding from provided photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . search ( image = f , identify_asm = True ) json_response = response . json () print ( json_response ) Delete Person by PID Authorized Client() required. This method deletes person, if found by its pid. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . persons . delete ( pid = \"abcdef01-abcd-abcd01-abcdef01\" ) if response . status_code == 204 : print ( \"Person deleted successfully.\" )","title":"Persons"},{"location":"docs/persons/#persons","text":"","title":"Persons"},{"location":"docs/persons/#basic-concepts","text":"Persons are wrapped face embeddings that come through user uploads or automatically from connected cameras. In fact, this is the similar \"tag\" as sources, but if the sources indicate where the photo came from, then the person is a tag indicating who is on it. Entry types that are always associated with persons: new, reinit, exact, ha, junk. The types of records nm, det cannot be associated with persons, since in this case the platform does not know who is in the photo. Any work with persons implies the automatic scope of the token with which the request is made. When created, created from id, upon reinit, Entries and Persons fall into the same space where the source specified in the request is located (again, provided that this source is visible from the current token space).","title":"Basic concepts"},{"location":"docs/persons/#create-person","text":"Authorized Client() required. This method creates (or finds, to avoid duplicates) person using provided photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . create ( image = f , source = \"test\" , facesize = 1000 , create_on_ha = True , create_on_junk = False , identify_asm = True ) json_response = response . json () print ( json_response )","title":"Create Person"},{"location":"docs/persons/#create-person-from-entry","text":"Authorized Client() required. This method creates new persons from photo on specified Entry ID. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . persons . create_by_entry ( id = 1 , create_on_ha = False , create_on_junk = False ) json_response = response . json () print ( json_response )","title":"Create Person from Entry"},{"location":"docs/persons/#re-init-person-from-photo-in-specified-entry-id","text":"Authorized Client() required. This method changes face embedding for a specified persons to the one, extracted from photo in Entry. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . persons . reinit ( id = 1 ) # NOTE: There is empty response in case of successful operation","title":"Re-init Person from photo in specified Entry ID."},{"location":"docs/persons/#re-init-person-from-provided-photo","text":"Authorized Client() required. This method changes face embedding for a specified persons to the one, extracted from provided photo. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . reinit_by_photo ( pid = \"abcdef01-abcd-abcd01-abcdef01\" , image = f , source = \"test\" , facesize = 1000 , identify_asm = True , result = EntryResult . HA , ) # NOTE: There is empty response in case of successful operation","title":"Re-init Person from provided photo"},{"location":"docs/persons/#search-person-by-provided-photo","text":"Authorized Client() required. This method searches for a person in database, comparing face embedding from provided photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . persons . search ( image = f , identify_asm = True ) json_response = response . json () print ( json_response )","title":"Search Person by provided photo"},{"location":"docs/persons/#delete-person-by-pid","text":"Authorized Client() required. This method deletes person, if found by its pid. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . persons . delete ( pid = \"abcdef01-abcd-abcd01-abcdef01\" ) if response . status_code == 204 : print ( \"Person deleted successfully.\" )","title":"Delete Person by PID"},{"location":"docs/settings/","text":"Threshold Settings Basic concepts The platform operates with events that have several types of results. The results have predefined thresholds, but the threshold values can be changed if necessary using settings. New threshold values will be applied only for the classification of future Entries, the classification of previous Entries cannot be changed. You can have different threshold settings for different spaces (very useful in some security scenarios). Get current thresholds Authorized Client() required. This method get the info about current threshold settings. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . get () json_response = response . json () print ( json_response ) Update threshold settings Authorized Client() required. This method updates the values of threshold settings. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . update ( exact = 90.0 , ha = 80.0 , junk = 70.0 , ) json_response = response . json () print ( json_response ) Reset current thresholds to defaults Authorized Client() required. This method sets all threshold settings to default ones. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . reset () json_response = response . json () print ( json_response )","title":"Settings"},{"location":"docs/settings/#threshold-settings","text":"","title":"Threshold Settings"},{"location":"docs/settings/#basic-concepts","text":"The platform operates with events that have several types of results. The results have predefined thresholds, but the threshold values can be changed if necessary using settings. New threshold values will be applied only for the classification of future Entries, the classification of previous Entries cannot be changed. You can have different threshold settings for different spaces (very useful in some security scenarios).","title":"Basic concepts"},{"location":"docs/settings/#get-current-thresholds","text":"Authorized Client() required. This method get the info about current threshold settings. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . get () json_response = response . json () print ( json_response )","title":"Get current thresholds"},{"location":"docs/settings/#update-threshold-settings","text":"Authorized Client() required. This method updates the values of threshold settings. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . update ( exact = 90.0 , ha = 80.0 , junk = 70.0 , ) json_response = response . json () print ( json_response )","title":"Update threshold settings"},{"location":"docs/settings/#reset-current-thresholds-to-defaults","text":"Authorized Client() required. This method sets all threshold settings to default ones. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . settings . reset () json_response = response . json () print ( json_response )","title":"Reset current thresholds to defaults"},{"location":"docs/sources/","text":"Sources Basic concepts A source in the platform is a tag for the correct cataloging and correlation of incoming data, as well as a container with user settings which indicate how this data should be processed. All data stored in the platform must have as one of its attributes the name of its source, because only then can the platform accurately identify where the data has come from into the platform, and, as a result, correctly catalog it and execute custom logic. Before you begin uploading data to the platform, make sure to create a source with the same name that you will then specify in your API request or when connecting a camera to the preprocessing server. All data that is intended for cataloging and storage in the platform cannot be saved in the platform if when it is uploaded no source is specified or a source that does not exist is specified. An error message will appear each time this happens. Create Source Authorized Client() required. This method creates new source with specified name. All of the parameters, except name , are optional. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) response = c . sources . create ( name = \"test\" , license = 1 , identify_facesize_threshold = 1000 , use_pps_time = True , manual_create_facesize_threshold = 1000 , manual_create_on_ha = True , manual_create_on_junk = True , manual_identify_asm = False , auto_create_persons = True , auto_create_facesize_threshold = 1000 , auto_create_check_blur = True , auto_create_check_exposure = True , auto_create_on_ha = False , auto_create_on_junk = False , auto_check_face_angle = False , auto_check_liveness = False , auto_create_liveness_only = False , auto_identify_asm = False , store_images_for_results = [ EntryResult . DET ] ) json_response = response . json () print ( json_response ) List Sources Authorized Client() required. This method returns paginated list of sources. Can be filtered by name using q & by list of space ids. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . sources . list ( q = \"te\" , spaces_ids = [ 1 , 2 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response ) Get Source by id Authorized Client() required. This method returns source info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . sources . get ( id = 1 ) json_response = response . json () print ( json_response ) Update Source by id Authorized Client() required. This method updates source info, if found by its id. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) response = c . sources . update ( id = 1 , name = \"test\" , license = 1 , identify_facesize_threshold = 1000 , use_pps_time = True , manual_create_facesize_threshold = 1000 , manual_create_on_ha = True , manual_create_on_junk = True , manual_identify_asm = False , auto_create_persons = True , auto_create_facesize_threshold = 1000 , auto_create_check_blur = True , auto_create_check_exposure = True , auto_create_on_ha = False , auto_create_on_junk = False , auto_check_face_angle = False , auto_check_liveness = False , auto_create_liveness_only = False , auto_identify_asm = False , store_images_for_results = [ EntryResult . DET ] ) json_response = response . json () print ( json_response ) Delete Source by id Authorized Client() required. This method deletes source, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . sources . delete ( id = 1 ) if response . status_code == 202 : print ( \"Source deleted successfully.\" )","title":"Sources"},{"location":"docs/sources/#sources","text":"","title":"Sources"},{"location":"docs/sources/#basic-concepts","text":"A source in the platform is a tag for the correct cataloging and correlation of incoming data, as well as a container with user settings which indicate how this data should be processed. All data stored in the platform must have as one of its attributes the name of its source, because only then can the platform accurately identify where the data has come from into the platform, and, as a result, correctly catalog it and execute custom logic. Before you begin uploading data to the platform, make sure to create a source with the same name that you will then specify in your API request or when connecting a camera to the preprocessing server. All data that is intended for cataloging and storage in the platform cannot be saved in the platform if when it is uploaded no source is specified or a source that does not exist is specified. An error message will appear each time this happens.","title":"Basic concepts"},{"location":"docs/sources/#create-source","text":"Authorized Client() required. This method creates new source with specified name. All of the parameters, except name , are optional. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) response = c . sources . create ( name = \"test\" , license = 1 , identify_facesize_threshold = 1000 , use_pps_time = True , manual_create_facesize_threshold = 1000 , manual_create_on_ha = True , manual_create_on_junk = True , manual_identify_asm = False , auto_create_persons = True , auto_create_facesize_threshold = 1000 , auto_create_check_blur = True , auto_create_check_exposure = True , auto_create_on_ha = False , auto_create_on_junk = False , auto_check_face_angle = False , auto_check_liveness = False , auto_create_liveness_only = False , auto_identify_asm = False , store_images_for_results = [ EntryResult . DET ] ) json_response = response . json () print ( json_response )","title":"Create Source"},{"location":"docs/sources/#list-sources","text":"Authorized Client() required. This method returns paginated list of sources. Can be filtered by name using q & by list of space ids. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . sources . list ( q = \"te\" , spaces_ids = [ 1 , 2 ], limit = 10 , offset = 5 ) json_response = response . json () print ( json_response )","title":"List Sources"},{"location":"docs/sources/#get-source-by-id","text":"Authorized Client() required. This method returns source info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . sources . get ( id = 1 ) json_response = response . json () print ( json_response )","title":"Get Source by id"},{"location":"docs/sources/#update-source-by-id","text":"Authorized Client() required. This method updates source info, if found by its id. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) response = c . sources . update ( id = 1 , name = \"test\" , license = 1 , identify_facesize_threshold = 1000 , use_pps_time = True , manual_create_facesize_threshold = 1000 , manual_create_on_ha = True , manual_create_on_junk = True , manual_identify_asm = False , auto_create_persons = True , auto_create_facesize_threshold = 1000 , auto_create_check_blur = True , auto_create_check_exposure = True , auto_create_on_ha = False , auto_create_on_junk = False , auto_check_face_angle = False , auto_check_liveness = False , auto_create_liveness_only = False , auto_identify_asm = False , store_images_for_results = [ EntryResult . DET ] ) json_response = response . json () print ( json_response )","title":"Update Source by id"},{"location":"docs/sources/#delete-source-by-id","text":"Authorized Client() required. This method deletes source, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . sources . delete ( id = 1 ) if response . status_code == 202 : print ( \"Source deleted successfully.\" )","title":"Delete Source by id"},{"location":"docs/spaces/","text":"Spaces Basic concepts Spaces are a way of having multiple databases of people inside your single account. Sources, Persons and any other entities are only visible (created & searched, for example) inside particular space you're in. To be precise, you can't have any data in your account that isn't attached to a space. You always have space named \"default\", and even if you use account tokens (not space tokens), you're still using spaces (well, that \"default\" space). Create Space Authorized Client() required. This method creates new space with specified name. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . create ( name = \"test\" ) json_response = response . json () print ( json_response ) List Spaces Authorized Client() required. This method returns paginated list of spaces. Can be filtered by name using q . from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . list ( q = \"te\" , limit = 10 , offset = 5 ) json_response = response . json () print ( json_response ) Get Space by id Authorized Client() required. This method returns space info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . get ( id = 1 ) json_response = response . json () print ( json_response ) Update Space by id Authorized Client() required. This method updates space info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . update ( id = 1 , name = \"newname\" ) json_response = response . json () print ( json_response ) Delete Space by id Authorized Client() required. This method deletes space, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . spaces . delete ( id = 1 ) if response . status_code == 204 : print ( \"Space deleted successfully.\" ) Create Token for specified Space Authorized Client() required. This method creates new token for space, if found by its id. You can create temporary or permanent token as with any other type of tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . token ( id = 1 , permanent = True ) json_response = response . json () print ( json_response ) Spaces Full List Authorized Client() required. This method returns full list of spaces. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . lists . spaces . all () json_response = response . json () print ( json_response )","title":"Spaces"},{"location":"docs/spaces/#spaces","text":"","title":"Spaces"},{"location":"docs/spaces/#basic-concepts","text":"Spaces are a way of having multiple databases of people inside your single account. Sources, Persons and any other entities are only visible (created & searched, for example) inside particular space you're in. To be precise, you can't have any data in your account that isn't attached to a space. You always have space named \"default\", and even if you use account tokens (not space tokens), you're still using spaces (well, that \"default\" space).","title":"Basic concepts"},{"location":"docs/spaces/#create-space","text":"Authorized Client() required. This method creates new space with specified name. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . create ( name = \"test\" ) json_response = response . json () print ( json_response )","title":"Create Space"},{"location":"docs/spaces/#list-spaces","text":"Authorized Client() required. This method returns paginated list of spaces. Can be filtered by name using q . from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . list ( q = \"te\" , limit = 10 , offset = 5 ) json_response = response . json () print ( json_response )","title":"List Spaces"},{"location":"docs/spaces/#get-space-by-id","text":"Authorized Client() required. This method returns space info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . get ( id = 1 ) json_response = response . json () print ( json_response )","title":"Get Space by id"},{"location":"docs/spaces/#update-space-by-id","text":"Authorized Client() required. This method updates space info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . update ( id = 1 , name = \"newname\" ) json_response = response . json () print ( json_response )","title":"Update Space by id"},{"location":"docs/spaces/#delete-space-by-id","text":"Authorized Client() required. This method deletes space, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . spaces . delete ( id = 1 ) if response . status_code == 204 : print ( \"Space deleted successfully.\" )","title":"Delete Space by id"},{"location":"docs/spaces/#create-token-for-specified-space","text":"Authorized Client() required. This method creates new token for space, if found by its id. You can create temporary or permanent token as with any other type of tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . spaces . token ( id = 1 , permanent = True ) json_response = response . json () print ( json_response )","title":"Create Token for specified Space"},{"location":"docs/spaces/#spaces-full-list","text":"Authorized Client() required. This method returns full list of spaces. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . lists . spaces . all () json_response = response . json () print ( json_response )","title":"Spaces Full List"},{"location":"docs/stream-tokens/","text":"Stream-Tokens Basic concepts Stream-Tokens are used to authorize API calls from clients. There are account, space & manager stream_tokens: Account stream_tokens are used to access most of the API as \"default\" Space Space stream_tokens are just restricted for using with data inside that Space Manager stream_tokens are restricted for using only in IAM management API Although, there are 3 types of stream_tokens, you can use this same API for managing any of them. Platform will know which type of token you're referring to by looking at api_token that is in your Client() instance. You can have temporary (24 hours) or permanent token. Recommended way is to always use temporary stream_tokens inside your applications and rotate them periodically. In order to help enforcing this practice, permanent stream_tokens are restricted to maximum 5 of them per account/space. Create Token Authorized Client() required. This method creates new temporary or permanent token. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . streams . tokens . create ( permanent = True ) json_response = response . json () print ( json_response ) List Stream-Tokens Authorized Client() required. This method returns paginated list of stream_tokens. Can be filtered by permanence of stream_tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . streams . tokens . list ( permanent = False , limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response ) Get Stream-Token by id Authorized Client() required. This method returns stream-token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . streams . tokens . get ( token_id_or_key = 1 ) json_response = response . json () print ( json_response ) Update Stream-Token by id Authorized Client() required. This method updates stream-token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . streams . tokens . update ( token_id_or_key = 1 , is_active = False ) json_response = response . json () print ( json_response ) Delete Token by id Authorized Client() required. This method deletes token, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . streams . tokens . delete ( token_id_or_key = 1 ) if response . status_code == 204 : print ( \"Stream-Token deleted successfully.\" ) Delete List of Stream-Tokens Authorized Client() required. This method deletes many stream_tokens, if found by permanent filter. Rules of this filter are: * False - deletes only temporary stream_tokens * True - deletes only permanent stream_tokens * None - deletes all stream_tokens from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . streams . tokens . delete_list ( permanent = False ) if response . status_code == 204 : print ( \"Stream-Tokens deleted successfully.\" )","title":"Stream Tokens"},{"location":"docs/stream-tokens/#stream-tokens","text":"","title":"Stream-Tokens"},{"location":"docs/stream-tokens/#basic-concepts","text":"Stream-Tokens are used to authorize API calls from clients. There are account, space & manager stream_tokens: Account stream_tokens are used to access most of the API as \"default\" Space Space stream_tokens are just restricted for using with data inside that Space Manager stream_tokens are restricted for using only in IAM management API Although, there are 3 types of stream_tokens, you can use this same API for managing any of them. Platform will know which type of token you're referring to by looking at api_token that is in your Client() instance. You can have temporary (24 hours) or permanent token. Recommended way is to always use temporary stream_tokens inside your applications and rotate them periodically. In order to help enforcing this practice, permanent stream_tokens are restricted to maximum 5 of them per account/space.","title":"Basic concepts"},{"location":"docs/stream-tokens/#create-token","text":"Authorized Client() required. This method creates new temporary or permanent token. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . streams . tokens . create ( permanent = True ) json_response = response . json () print ( json_response )","title":"Create Token"},{"location":"docs/stream-tokens/#list-stream-tokens","text":"Authorized Client() required. This method returns paginated list of stream_tokens. Can be filtered by permanence of stream_tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . streams . tokens . list ( permanent = False , limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response )","title":"List Stream-Tokens"},{"location":"docs/stream-tokens/#get-stream-token-by-id","text":"Authorized Client() required. This method returns stream-token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . streams . tokens . get ( token_id_or_key = 1 ) json_response = response . json () print ( json_response )","title":"Get Stream-Token by id"},{"location":"docs/stream-tokens/#update-stream-token-by-id","text":"Authorized Client() required. This method updates stream-token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . streams . tokens . update ( token_id_or_key = 1 , is_active = False ) json_response = response . json () print ( json_response )","title":"Update Stream-Token by id"},{"location":"docs/stream-tokens/#delete-token-by-id","text":"Authorized Client() required. This method deletes token, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . streams . tokens . delete ( token_id_or_key = 1 ) if response . status_code == 204 : print ( \"Stream-Token deleted successfully.\" )","title":"Delete Token by id"},{"location":"docs/stream-tokens/#delete-list-of-stream-tokens","text":"Authorized Client() required. This method deletes many stream_tokens, if found by permanent filter. Rules of this filter are: * False - deletes only temporary stream_tokens * True - deletes only permanent stream_tokens * None - deletes all stream_tokens from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . streams . tokens . delete_list ( permanent = False ) if response . status_code == 204 : print ( \"Stream-Tokens deleted successfully.\" )","title":"Delete List of Stream-Tokens"},{"location":"docs/tokens/","text":"Tokens Basic concepts Tokens are used to authorize API calls from clients. There are account, space & manager tokens: Account tokens are used to access most of the API as \"default\" Space Space tokens are just restricted for using with data inside that Space Manager tokens are restricted for using only in IAM management API Although, there are 3 types of tokens, you can use this same API for managing any of them. Platform will know which type of token you're referring to by looking at api_token that is in your Client() instance. You can have temporary (24 hours) or permanent token. Recommended way is to always use temporary tokens inside your applications and rotate them periodically. In order to help enforcing this practice, permanent tokens are restricted to maximum 5 of them per account/space. Create Token Authorized Client() required. This method creates new temporary or permanent token. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . create ( permanent = True ) json_response = response . json () print ( json_response ) List Tokens Authorized Client() required. This method returns paginated list of tokens. Can be filtered by permanence of tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . list ( permanent = False , limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response ) Get Token by id Authorized Client() required. This method returns token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . get ( token_id_or_key = 1 ) json_response = response . json () print ( json_response ) Update Token by id Authorized Client() required. This method updates token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . update ( token_id_or_key = 1 , is_active = False ) json_response = response . json () print ( json_response ) Delete Token by id Authorized Client() required. This method deletes token, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . tokens . delete ( token_id_or_key = 1 ) if response . status_code == 204 : print ( \"Token deleted successfully.\" ) Delete List of Tokens Authorized Client() required. This method deletes many tokens, if found by permanent filter. Rules of this filter are: * False - deletes only temporary tokens * True - deletes only permanent tokens * None - deletes all tokens from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . tokens . delete_list ( permanent = False ) if response . status_code == 204 : print ( \"Tokens deleted successfully.\" )","title":"Tokens"},{"location":"docs/tokens/#tokens","text":"","title":"Tokens"},{"location":"docs/tokens/#basic-concepts","text":"Tokens are used to authorize API calls from clients. There are account, space & manager tokens: Account tokens are used to access most of the API as \"default\" Space Space tokens are just restricted for using with data inside that Space Manager tokens are restricted for using only in IAM management API Although, there are 3 types of tokens, you can use this same API for managing any of them. Platform will know which type of token you're referring to by looking at api_token that is in your Client() instance. You can have temporary (24 hours) or permanent token. Recommended way is to always use temporary tokens inside your applications and rotate them periodically. In order to help enforcing this practice, permanent tokens are restricted to maximum 5 of them per account/space.","title":"Basic concepts"},{"location":"docs/tokens/#create-token","text":"Authorized Client() required. This method creates new temporary or permanent token. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . create ( permanent = True ) json_response = response . json () print ( json_response )","title":"Create Token"},{"location":"docs/tokens/#list-tokens","text":"Authorized Client() required. This method returns paginated list of tokens. Can be filtered by permanence of tokens. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . list ( permanent = False , limit = 10 , offset = 5 ) json_response = response . json () # if response is 200, this is list of dicts print ( json_response )","title":"List Tokens"},{"location":"docs/tokens/#get-token-by-id","text":"Authorized Client() required. This method returns token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . get ( token_id_or_key = 1 ) json_response = response . json () print ( json_response )","title":"Get Token by id"},{"location":"docs/tokens/#update-token-by-id","text":"Authorized Client() required. This method updates token info, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . tokens . update ( token_id_or_key = 1 , is_active = False ) json_response = response . json () print ( json_response )","title":"Update Token by id"},{"location":"docs/tokens/#delete-token-by-id","text":"Authorized Client() required. This method deletes token, if found by its id. from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . tokens . delete ( token_id_or_key = 1 ) if response . status_code == 204 : print ( \"Token deleted successfully.\" )","title":"Delete Token by id"},{"location":"docs/tokens/#delete-list-of-tokens","text":"Authorized Client() required. This method deletes many tokens, if found by permanent filter. Rules of this filter are: * False - deletes only temporary tokens * True - deletes only permanent tokens * None - deletes all tokens from neuroio import Client c = Client ( api_token = \"abcd\" ) # NOTE: There is empty response in case of successful operation response = c . tokens . delete_list ( permanent = False ) if response . status_code == 204 : print ( \"Tokens deleted successfully.\" )","title":"Delete List of Tokens"},{"location":"docs/utility/","text":"Utility Basic concepts This section indicates those functions that are not directly related to the logic of the platform, but help in certain user scenarios. Compare two photos Authorized Client() required. This function compares images of faces in uploaded photos for belonging to the same person. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) with open ( \"image1.png\" , \"rb\" ) as f1 : with open ( \"image2.png\" , \"rb\" ) as f2 : response = c . utility . compare ( image1 = f1 , image2 = f2 , result = EntryResult . HA ) json_response = response . json () print ( json_response ) Age/Sex/Mood Authorized Client() required. This function returns age / gender / mood for the person on a given photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . utility . asm ( image = f ) json_response = response . json () print ( json_response )","title":"Utility"},{"location":"docs/utility/#utility","text":"","title":"Utility"},{"location":"docs/utility/#basic-concepts","text":"This section indicates those functions that are not directly related to the logic of the platform, but help in certain user scenarios.","title":"Basic concepts"},{"location":"docs/utility/#compare-two-photos","text":"Authorized Client() required. This function compares images of faces in uploaded photos for belonging to the same person. from neuroio import Client from neuroio.constants import EntryResult c = Client ( api_token = \"abcd\" ) with open ( \"image1.png\" , \"rb\" ) as f1 : with open ( \"image2.png\" , \"rb\" ) as f2 : response = c . utility . compare ( image1 = f1 , image2 = f2 , result = EntryResult . HA ) json_response = response . json () print ( json_response )","title":"Compare two photos"},{"location":"docs/utility/#agesexmood","text":"Authorized Client() required. This function returns age / gender / mood for the person on a given photo. from neuroio import Client c = Client ( api_token = \"abcd\" ) with open ( \"image.png\" , \"rb\" ) as f : response = c . utility . asm ( image = f ) json_response = response . json () print ( json_response )","title":"Age/Sex/Mood"},{"location":"docs/whoami/","text":"Who Am I Basic concepts If you want to know which type of account (and info on that account) you're using, use me method with some token. Get current account info Authorized Client() required. This method gets information about current user and space (or just space, if you're using space token). from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . whoami . me () json_response = response . json () print ( json_response )","title":"Whoami"},{"location":"docs/whoami/#who-am-i","text":"","title":"Who Am I"},{"location":"docs/whoami/#basic-concepts","text":"If you want to know which type of account (and info on that account) you're using, use me method with some token.","title":"Basic concepts"},{"location":"docs/whoami/#get-current-account-info","text":"Authorized Client() required. This method gets information about current user and space (or just space, if you're using space token). from neuroio import Client c = Client ( api_token = \"abcd\" ) response = c . whoami . me () json_response = response . json () print ( json_response )","title":"Get current account info"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to neuroio-python Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting neuroio-python set up for local development The first step when contributing to any project is getting it set up on your local machine. neuroio-python aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.7+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/neuroio-python.git cd neuroio-python poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the coding standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by neuroio-python contributors like you . Thank you!","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-neuroio-python","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to neuroio-python"},{"location":"docs/contributing/1.-contributing-guide/#getting-neuroio-python-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. neuroio-python aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.7+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/neuroio-python.git cd neuroio-python poetry install","title":"Getting neuroio-python set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the coding standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by neuroio-python contributors like you . Thank you!","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"Introduction This document gives coding conventions for the code in this repository. Optionally, projects that use this package are encouraged to follow this document and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. Descriptive Variable names Naming things is hard. This project has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to this project should be formatted using Black and isort. Black should be run with the line length set to 79, and isort with Black compatible settings in place. Automated Code Linting All code submitted should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the code in this repository. Optionally, projects that use this package are encouraged to follow this document and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. This project has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to this project should be formatted using Black and isort. Black should be run with the line length set to 79, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"Abstract Defines the Code of Conduct for this and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here For answers to common questions about this code of conduct, see","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for this and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available here For answers to common questions about this code of conduct, see","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Lev Rubel (@levchik) Notable Bug Reporters - Code Contributors - Documenters - A sincere thanks to everyone who helps make neuroio-python into a great project! ~Lev Rubel","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Lev Rubel (@levchik)","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"-","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"- A sincere thanks to everyone who helps make neuroio-python into a great project! ~Lev Rubel","title":"Documenters"},{"location":"reference/neuroio/","text":"Module neuroio neuroio-python A Python package for interacting with the NeuroIO API View Source \"\"\"**neuroio-python** A Python package for interacting with the NeuroIO API \"\"\" from .clients import AsyncClient , Client from .listeners import EventListener __version__ : str = \"0.1.0\" __all__ = [ \"__version__\" , \"Client\" , \"AsyncClient\" , \"EventListener\" ] Sub-modules neuroio.auth neuroio.auth_token neuroio.base neuroio.billing neuroio.clients neuroio.constants neuroio.entries neuroio.groups neuroio.licenses neuroio.listeners neuroio.lists neuroio.notifications neuroio.persons neuroio.settings neuroio.sources neuroio.spaces neuroio.streams neuroio.tokens neuroio.utility neuroio.utils neuroio.whoami Variables __version__ Classes AsyncClient class AsyncClient ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class AsyncClient ( Client ): pass Ancestors (in MRO) neuroio.Client Instance variables common_headers is_async Methods client_settings def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] View Source def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings init def init ( self ) -> None View Source def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ] Client class Client ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_version = api_version self . csettings = self . client_settings ( timeout = timeout , token = api_token ) self . init () def init ( self ) -> None : self . api_atrr_names = [ \"sources\", \"entries\", \"streams\", \"utility\", \"settings\", \"groups\", \"persons\", \"notifications\", ] self . iam_atrr_names = [ \"auth\", \"spaces\", \"lists\", \"licenses\", \"whoami\", \"tokens\", \"billing\", ] @cached_property def is_async ( self ) -> bool : return self . __class__ . __name__ == \"AsyncClient\" @property def common_headers ( self ) -> dict : root = \"neuroio-python\" if self . is_async : root = \"neuroio-async-python\" return { \"User-Agent\" : f \"{root}/{get_package_version()}\" } def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any, Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings def __getattr__ ( self , item : str ) -> Any : if item in self . api_atrr_names + self . iam_atrr_names : return Catcher ( prev = item , is_async = self . is_async , settings = self . csettings , api_version = self . api_version , ) else : # Default behaviour raise AttributeError Descendants neuroio.AsyncClient Instance variables common_headers is_async Methods client_settings def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] View Source def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings init def init ( self ) -> None View Source def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ] EventListener class EventListener ( api_token : str , event_handler_func : Callable [[ str ], Awaitable [ NoneType ]], timeout : Optional [ float ] = 4.0 ) View Source class EventListener : def __init__ ( self , api_token : str , event_handler_func : Callable [[ str ], Awaitable [ None ]], timeout : Optional [ float ] = constants . HTTP_CLIENT_TIMEOUT , ) -> None : \"\"\" Creates and manages single WebSocket Client object, that is used to send & receive messages in Events service. \"\"\" self . api_token = api_token self . event_handler_func = event_handler_func self . timeout = timeout self . websocket : Optional [ WebSocketClientProtocol ] = None async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data )) async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} ) async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" }) Methods authorize def authorize ( self ) -> None View Source async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} ) listen def listen ( self ) -> None View Source async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue ping def ping ( self ) -> None View Source async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" }) send_json def send_json ( self , data : Union [ List , Dict ] ) -> None View Source async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data ))","title":"Index"},{"location":"reference/neuroio/#module-neuroio","text":"neuroio-python A Python package for interacting with the NeuroIO API View Source \"\"\"**neuroio-python** A Python package for interacting with the NeuroIO API \"\"\" from .clients import AsyncClient , Client from .listeners import EventListener __version__ : str = \"0.1.0\" __all__ = [ \"__version__\" , \"Client\" , \"AsyncClient\" , \"EventListener\" ]","title":"Module neuroio"},{"location":"reference/neuroio/#sub-modules","text":"neuroio.auth neuroio.auth_token neuroio.base neuroio.billing neuroio.clients neuroio.constants neuroio.entries neuroio.groups neuroio.licenses neuroio.listeners neuroio.lists neuroio.notifications neuroio.persons neuroio.settings neuroio.sources neuroio.spaces neuroio.streams neuroio.tokens neuroio.utility neuroio.utils neuroio.whoami","title":"Sub-modules"},{"location":"reference/neuroio/#variables","text":"__version__","title":"Variables"},{"location":"reference/neuroio/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/#asyncclient","text":"class AsyncClient ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class AsyncClient ( Client ): pass","title":"AsyncClient"},{"location":"reference/neuroio/#ancestors-in-mro","text":"neuroio.Client","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/#instance-variables","text":"common_headers is_async","title":"Instance variables"},{"location":"reference/neuroio/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/#client_settings","text":"def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] View Source def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings","title":"client_settings"},{"location":"reference/neuroio/#init","text":"def init ( self ) -> None View Source def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ]","title":"init"},{"location":"reference/neuroio/#client","text":"class Client ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_version = api_version self . csettings = self . client_settings ( timeout = timeout , token = api_token ) self . init () def init ( self ) -> None : self . api_atrr_names = [ \"sources\", \"entries\", \"streams\", \"utility\", \"settings\", \"groups\", \"persons\", \"notifications\", ] self . iam_atrr_names = [ \"auth\", \"spaces\", \"lists\", \"licenses\", \"whoami\", \"tokens\", \"billing\", ] @cached_property def is_async ( self ) -> bool : return self . __class__ . __name__ == \"AsyncClient\" @property def common_headers ( self ) -> dict : root = \"neuroio-python\" if self . is_async : root = \"neuroio-async-python\" return { \"User-Agent\" : f \"{root}/{get_package_version()}\" } def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any, Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings def __getattr__ ( self , item : str ) -> Any : if item in self . api_atrr_names + self . iam_atrr_names : return Catcher ( prev = item , is_async = self . is_async , settings = self . csettings , api_version = self . api_version , ) else : # Default behaviour raise AttributeError","title":"Client"},{"location":"reference/neuroio/#descendants","text":"neuroio.AsyncClient","title":"Descendants"},{"location":"reference/neuroio/#instance-variables_1","text":"common_headers is_async","title":"Instance variables"},{"location":"reference/neuroio/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/#client_settings_1","text":"def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] View Source def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings","title":"client_settings"},{"location":"reference/neuroio/#init_1","text":"def init ( self ) -> None View Source def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ]","title":"init"},{"location":"reference/neuroio/#eventlistener","text":"class EventListener ( api_token : str , event_handler_func : Callable [[ str ], Awaitable [ NoneType ]], timeout : Optional [ float ] = 4.0 ) View Source class EventListener : def __init__ ( self , api_token : str , event_handler_func : Callable [[ str ], Awaitable [ None ]], timeout : Optional [ float ] = constants . HTTP_CLIENT_TIMEOUT , ) -> None : \"\"\" Creates and manages single WebSocket Client object, that is used to send & receive messages in Events service. \"\"\" self . api_token = api_token self . event_handler_func = event_handler_func self . timeout = timeout self . websocket : Optional [ WebSocketClientProtocol ] = None async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data )) async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} ) async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" })","title":"EventListener"},{"location":"reference/neuroio/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/#authorize","text":"def authorize ( self ) -> None View Source async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} )","title":"authorize"},{"location":"reference/neuroio/#listen","text":"def listen ( self ) -> None View Source async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue","title":"listen"},{"location":"reference/neuroio/#ping","text":"def ping ( self ) -> None View Source async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" })","title":"ping"},{"location":"reference/neuroio/#send_json","text":"def send_json ( self , data : Union [ List , Dict ] ) -> None View Source async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data ))","title":"send_json"},{"location":"reference/neuroio/auth_token/","text":"Module neuroio.auth_token None None View Source import typing from httpx import Auth , Request , Response class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token : str , header_name : str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token { self . api_token } \" yield request Classes AuthorizationTokenAuth class AuthorizationTokenAuth ( api_token : str , header_name : str = None ) View Source class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token: str , header_name: str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request: Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request Ancestors (in MRO) httpx.Auth Class variables requires_request_body requires_response_body Methods async_auth_flow def async_auth_flow ( self , request : httpx . Request ) -> AsyncGenerator [ httpx . Request , httpx . Response ] Execute the authentication flow asynchronously. By default, this defers to .auth_flow() . You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. View Source async def async_auth_flow ( self , request : Request ) -> typing . AsyncGenerator [ Request , Response ] : \"\"\" Execute the authentication flow asynchronously. By default, this defers to `.auth_flow()`. You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. \"\"\" if self . requires_request_body : await request . aread () flow = self . auth_flow ( request ) request = next ( flow ) while True : response = yield request if self . requires_response_body : await response . aread () try : request = flow . send ( response ) except StopIteration : break auth_flow def auth_flow ( self , request : httpx . Request ) -> Generator [ httpx . Request , httpx . Response , NoneType ] Execute the authentication flow. To dispatch a request, yield it: yield request The client will .send() the response back into the flow generator. You can access it like so: response = yield request A return (or reaching the end of the generator) will result in the client returning the last response obtained from the server. You can dispatch as many requests as is necessary. View Source def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ] : request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request sync_auth_flow def sync_auth_flow ( self , request : httpx . Request ) -> Generator [ httpx . Request , httpx . Response , NoneType ] Execute the authentication flow synchronously. By default, this defers to .auth_flow() . You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. View Source def sync_auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ] : \"\"\" Execute the authentication flow synchronously. By default, this defers to `.auth_flow()`. You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. \"\"\" if self . requires_request_body : request . read () flow = self . auth_flow ( request ) request = next ( flow ) while True : response = yield request if self . requires_response_body : response . read () try : request = flow . send ( response ) except StopIteration : break","title":"Auth Token"},{"location":"reference/neuroio/auth_token/#module-neuroioauth_token","text":"None None View Source import typing from httpx import Auth , Request , Response class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token : str , header_name : str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token { self . api_token } \" yield request","title":"Module neuroio.auth_token"},{"location":"reference/neuroio/auth_token/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/auth_token/#authorizationtokenauth","text":"class AuthorizationTokenAuth ( api_token : str , header_name : str = None ) View Source class AuthorizationTokenAuth ( Auth ): \"\"\"Describes an API Token requests authentication.\"\"\" def __init__ ( self , api_token: str , header_name: str = None ): \"\"\" :param api_token: The API token that will be sent. :param header_name: Name of the header field. \"\"\" self . api_token = api_token self . header_name = header_name or \"Authorization\" def auth_flow ( self , request: Request ) -> typing . Generator [ Request , Response , None ]: request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request","title":"AuthorizationTokenAuth"},{"location":"reference/neuroio/auth_token/#ancestors-in-mro","text":"httpx.Auth","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/auth_token/#class-variables","text":"requires_request_body requires_response_body","title":"Class variables"},{"location":"reference/neuroio/auth_token/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/auth_token/#async_auth_flow","text":"def async_auth_flow ( self , request : httpx . Request ) -> AsyncGenerator [ httpx . Request , httpx . Response ] Execute the authentication flow asynchronously. By default, this defers to .auth_flow() . You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. View Source async def async_auth_flow ( self , request : Request ) -> typing . AsyncGenerator [ Request , Response ] : \"\"\" Execute the authentication flow asynchronously. By default, this defers to `.auth_flow()`. You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. \"\"\" if self . requires_request_body : await request . aread () flow = self . auth_flow ( request ) request = next ( flow ) while True : response = yield request if self . requires_response_body : await response . aread () try : request = flow . send ( response ) except StopIteration : break","title":"async_auth_flow"},{"location":"reference/neuroio/auth_token/#auth_flow","text":"def auth_flow ( self , request : httpx . Request ) -> Generator [ httpx . Request , httpx . Response , NoneType ] Execute the authentication flow. To dispatch a request, yield it: yield request The client will .send() the response back into the flow generator. You can access it like so: response = yield request A return (or reaching the end of the generator) will result in the client returning the last response obtained from the server. You can dispatch as many requests as is necessary. View Source def auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ] : request . headers [ self . header_name ] = f \"Token {self.api_token}\" yield request","title":"auth_flow"},{"location":"reference/neuroio/auth_token/#sync_auth_flow","text":"def sync_auth_flow ( self , request : httpx . Request ) -> Generator [ httpx . Request , httpx . Response , NoneType ] Execute the authentication flow synchronously. By default, this defers to .auth_flow() . You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. View Source def sync_auth_flow ( self , request : Request ) -> typing . Generator [ Request , Response , None ] : \"\"\" Execute the authentication flow synchronously. By default, this defers to `.auth_flow()`. You should override this method when the authentication scheme does I/O and/or uses concurrency primitives. \"\"\" if self . requires_request_body : request . read () flow = self . auth_flow ( request ) request = next ( flow ) while True : response = yield request if self . requires_response_body : response . read () try : request = flow . send ( response ) except StopIteration : break","title":"sync_auth_flow"},{"location":"reference/neuroio/base/","text":"Module neuroio.base None None View Source import abc from httpx import AsyncClient , Client from neuroio import constants class Base : def __init__ ( self , settings : dict ) -> None : self . settings = settings class APIBaseBase : base_url = constants . API_BASE_URL class IAMBaseBase : base_url = constants . IAM_BASE_URL class APIBase ( abc . ABC , Base , APIBaseBase ): def get_client ( self ) -> Client : return Client ( ** self . settings ) class APIBaseAsync ( abc . ABC , Base , APIBaseBase ): def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) class IAMBase ( abc . ABC , Base , IAMBaseBase ): def get_client ( self ) -> Client : return Client ( ** self . settings ) class IAMBaseAsync ( abc . ABC , Base , IAMBaseBase ): def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) Classes APIBase class APIBase ( settings : dict ) View Source class APIBase ( abc . ABC , Base , APIBaseBase ): def get_client ( self ) -> Client: return Client (** self . settings ) Ancestors (in MRO) abc.ABC neuroio.base.Base neuroio.base.APIBaseBase Descendants neuroio.entries.v1.Impl neuroio.groups.v1.Impl neuroio.notifications.v1.Impl neuroio.persons.v1.Impl neuroio.settings.v1.Impl neuroio.sources.v1.Impl neuroio.streams.tokens.v1.Impl neuroio.utility.v1.Impl Class variables base_url Methods get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) APIBaseAsync class APIBaseAsync ( settings : dict ) View Source class APIBaseAsync ( abc . ABC , Base , APIBaseBase ): def get_client ( self ) -> AsyncClient: return AsyncClient (** self . settings ) Ancestors (in MRO) abc.ABC neuroio.base.Base neuroio.base.APIBaseBase Descendants neuroio.entries.v1.ImplAsync neuroio.groups.v1.ImplAsync neuroio.notifications.v1.ImplAsync neuroio.persons.v1.ImplAsync neuroio.settings.v1.ImplAsync neuroio.sources.v1.ImplAsync neuroio.streams.tokens.v1.ImplAsync neuroio.utility.v1.ImplAsync Class variables base_url Methods get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) APIBaseBase class APIBaseBase ( / , * args , ** kwargs ) View Source class APIBaseBase : base_url = constants . API_BASE_URL Descendants neuroio.base.APIBase neuroio.base.APIBaseAsync neuroio.entries.v1.EntriesBase neuroio.groups.v1.GroupsBase neuroio.notifications.v1.NotificationsBase neuroio.persons.v1.PersonsBase neuroio.settings.v1.SettingsBase neuroio.sources.v1.SourcesBase neuroio.streams.tokens.v1.StreamTokensBase neuroio.utility.v1.UtilityBase Class variables base_url Base class Base ( settings : dict ) View Source class Base: def __init__ ( self , settings: dict ) -> None: self . settings = settings Descendants neuroio.base.APIBase neuroio.base.APIBaseAsync neuroio.base.IAMBase neuroio.base.IAMBaseAsync IAMBase class IAMBase ( settings : dict ) View Source class IAMBase ( abc . ABC , Base , IAMBaseBase ): def get_client ( self ) -> Client: return Client (** self . settings ) Ancestors (in MRO) abc.ABC neuroio.base.Base neuroio.base.IAMBaseBase Descendants neuroio.auth.v1.Impl neuroio.billing.v1.Impl neuroio.licenses.sources.v1.Impl neuroio.lists.spaces.v1.Impl neuroio.spaces.v1.Impl neuroio.tokens.v1.Impl neuroio.whoami.v1.Impl Class variables base_url Methods get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) IAMBaseAsync class IAMBaseAsync ( settings : dict ) View Source class IAMBaseAsync ( abc . ABC , Base , IAMBaseBase ): def get_client ( self ) -> AsyncClient: return AsyncClient (** self . settings ) Ancestors (in MRO) abc.ABC neuroio.base.Base neuroio.base.IAMBaseBase Descendants neuroio.auth.v1.ImplAsync neuroio.billing.v1.ImplAsync neuroio.licenses.sources.v1.ImplAsync neuroio.lists.spaces.v1.ImplAsync neuroio.spaces.v1.ImplAsync neuroio.tokens.v1.ImplAsync neuroio.whoami.v1.ImplAsync Class variables base_url Methods get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) IAMBaseBase class IAMBaseBase ( / , * args , ** kwargs ) View Source class IAMBaseBase : base_url = constants . IAM_BASE_URL Descendants neuroio.base.IAMBase neuroio.base.IAMBaseAsync neuroio.auth.v1.AuthBase neuroio.billing.v1.BillingBase neuroio.licenses.sources.v1.LicensesBase neuroio.lists.spaces.v1.ListsSpacesBase neuroio.spaces.v1.SpacesBase neuroio.tokens.v1.TokensBase neuroio.whoami.v1.WhoamiBase Class variables base_url","title":"Base"},{"location":"reference/neuroio/base/#module-neuroiobase","text":"None None View Source import abc from httpx import AsyncClient , Client from neuroio import constants class Base : def __init__ ( self , settings : dict ) -> None : self . settings = settings class APIBaseBase : base_url = constants . API_BASE_URL class IAMBaseBase : base_url = constants . IAM_BASE_URL class APIBase ( abc . ABC , Base , APIBaseBase ): def get_client ( self ) -> Client : return Client ( ** self . settings ) class APIBaseAsync ( abc . ABC , Base , APIBaseBase ): def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) class IAMBase ( abc . ABC , Base , IAMBaseBase ): def get_client ( self ) -> Client : return Client ( ** self . settings ) class IAMBaseAsync ( abc . ABC , Base , IAMBaseBase ): def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"Module neuroio.base"},{"location":"reference/neuroio/base/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/base/#apibase","text":"class APIBase ( settings : dict ) View Source class APIBase ( abc . ABC , Base , APIBaseBase ): def get_client ( self ) -> Client: return Client (** self . settings )","title":"APIBase"},{"location":"reference/neuroio/base/#ancestors-in-mro","text":"abc.ABC neuroio.base.Base neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/base/#descendants","text":"neuroio.entries.v1.Impl neuroio.groups.v1.Impl neuroio.notifications.v1.Impl neuroio.persons.v1.Impl neuroio.settings.v1.Impl neuroio.sources.v1.Impl neuroio.streams.tokens.v1.Impl neuroio.utility.v1.Impl","title":"Descendants"},{"location":"reference/neuroio/base/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/base/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/base/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/base/#apibaseasync","text":"class APIBaseAsync ( settings : dict ) View Source class APIBaseAsync ( abc . ABC , Base , APIBaseBase ): def get_client ( self ) -> AsyncClient: return AsyncClient (** self . settings )","title":"APIBaseAsync"},{"location":"reference/neuroio/base/#ancestors-in-mro_1","text":"abc.ABC neuroio.base.Base neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/base/#descendants_1","text":"neuroio.entries.v1.ImplAsync neuroio.groups.v1.ImplAsync neuroio.notifications.v1.ImplAsync neuroio.persons.v1.ImplAsync neuroio.settings.v1.ImplAsync neuroio.sources.v1.ImplAsync neuroio.streams.tokens.v1.ImplAsync neuroio.utility.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/base/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/base/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/base/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/base/#apibasebase","text":"class APIBaseBase ( / , * args , ** kwargs ) View Source class APIBaseBase : base_url = constants . API_BASE_URL","title":"APIBaseBase"},{"location":"reference/neuroio/base/#descendants_2","text":"neuroio.base.APIBase neuroio.base.APIBaseAsync neuroio.entries.v1.EntriesBase neuroio.groups.v1.GroupsBase neuroio.notifications.v1.NotificationsBase neuroio.persons.v1.PersonsBase neuroio.settings.v1.SettingsBase neuroio.sources.v1.SourcesBase neuroio.streams.tokens.v1.StreamTokensBase neuroio.utility.v1.UtilityBase","title":"Descendants"},{"location":"reference/neuroio/base/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/base/#base","text":"class Base ( settings : dict ) View Source class Base: def __init__ ( self , settings: dict ) -> None: self . settings = settings","title":"Base"},{"location":"reference/neuroio/base/#descendants_3","text":"neuroio.base.APIBase neuroio.base.APIBaseAsync neuroio.base.IAMBase neuroio.base.IAMBaseAsync","title":"Descendants"},{"location":"reference/neuroio/base/#iambase","text":"class IAMBase ( settings : dict ) View Source class IAMBase ( abc . ABC , Base , IAMBaseBase ): def get_client ( self ) -> Client: return Client (** self . settings )","title":"IAMBase"},{"location":"reference/neuroio/base/#ancestors-in-mro_2","text":"abc.ABC neuroio.base.Base neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/base/#descendants_4","text":"neuroio.auth.v1.Impl neuroio.billing.v1.Impl neuroio.licenses.sources.v1.Impl neuroio.lists.spaces.v1.Impl neuroio.spaces.v1.Impl neuroio.tokens.v1.Impl neuroio.whoami.v1.Impl","title":"Descendants"},{"location":"reference/neuroio/base/#class-variables_3","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/base/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/base/#get_client_2","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/base/#iambaseasync","text":"class IAMBaseAsync ( settings : dict ) View Source class IAMBaseAsync ( abc . ABC , Base , IAMBaseBase ): def get_client ( self ) -> AsyncClient: return AsyncClient (** self . settings )","title":"IAMBaseAsync"},{"location":"reference/neuroio/base/#ancestors-in-mro_3","text":"abc.ABC neuroio.base.Base neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/base/#descendants_5","text":"neuroio.auth.v1.ImplAsync neuroio.billing.v1.ImplAsync neuroio.licenses.sources.v1.ImplAsync neuroio.lists.spaces.v1.ImplAsync neuroio.spaces.v1.ImplAsync neuroio.tokens.v1.ImplAsync neuroio.whoami.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/base/#class-variables_4","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/base/#methods_3","text":"","title":"Methods"},{"location":"reference/neuroio/base/#get_client_3","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/base/#iambasebase","text":"class IAMBaseBase ( / , * args , ** kwargs ) View Source class IAMBaseBase : base_url = constants . IAM_BASE_URL","title":"IAMBaseBase"},{"location":"reference/neuroio/base/#descendants_6","text":"neuroio.base.IAMBase neuroio.base.IAMBaseAsync neuroio.auth.v1.AuthBase neuroio.billing.v1.BillingBase neuroio.licenses.sources.v1.LicensesBase neuroio.lists.spaces.v1.ListsSpacesBase neuroio.spaces.v1.SpacesBase neuroio.tokens.v1.TokensBase neuroio.whoami.v1.WhoamiBase","title":"Descendants"},{"location":"reference/neuroio/base/#class-variables_5","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/clients/","text":"Module neuroio.clients None None View Source from importlib import import_module from typing import Any , Dict , Optional from neuroio import constants from neuroio . auth_token import AuthorizationTokenAuth from neuroio . utils import cached_property , get_package_version class Catcher : def __ init__ ( self , prev : str , is_async: bool , settings : dict , api_version: int ) -> None : self . prev = prev self . settings = settings self . is_async = is_async self . api_version = api_version def __ getattr__ ( self , item : str ) -> Any : return Catcher ( prev = f \"{self.prev}.{item}\" , is_async = self . is_async , settings = self . settings , api_version = self . api_version , ) def __ call__ ( self , * args : list , ** kwargs : dict ) -> Any : method = self . prev . split ( \".\" )[ - 1 ] path = \".\" . join ( self . prev . split ( \".\" )[:- 1 ]) module_path = f \"neuroio.{path}.v{self.api_version}\" v1_module = import_module ( module_path ) if v1_module: cls = getattr ( v1_module , ( \"ImplAsync\" if self . is_async else \"Impl\" ) ) inst = cls ( settings = self . settings ) if inst : return getattr ( inst , method )( * args , **kwargs ) class Client : def __ init__ ( self , api_token: Optional [ str ] = None , api_version: int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_version = api_version self . csettings = self . client_settings ( timeout = timeout , token = api_token ) self . init () def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ] @cached_property def is_async ( self ) -> bool : return self . __ class__ . __ name__ == \"AsyncClient\" @property def common_headers ( self ) -> dict : root = \"neuroio-python\" if self . is_async: root = \"neuroio-async-python\" return { \"User-Agent\" : f \"{root}/{get_package_version()}\" } def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings def __ getattr__ ( self , item : str ) -> Any : if item in self . api_atrr_names + self . iam_atrr_names: return Catcher ( prev = item , is_async = self . is_async , settings = self . csettings , api_version = self . api_version , ) else : # Default behaviour raise AttributeError class AsyncClient ( Client ) : pass Classes AsyncClient class AsyncClient ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class AsyncClient ( Client ): pass Ancestors (in MRO) neuroio.clients.Client Instance variables common_headers is_async Methods client_settings def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] View Source def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings init def init ( self ) -> None View Source def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ] Catcher class Catcher ( prev : str , is_async : bool , settings : dict , api_version : int ) View Source class Catcher : def __ init__ ( self , prev : str , is_async: bool , settings : dict , api_version: int ) -> None : self . prev = prev self . settings = settings self . is_async = is_async self . api_version = api_version def __ getattr__ ( self , item : str ) -> Any : return Catcher ( prev = f \"{self.prev}.{item}\" , is_async = self . is_async , settings = self . settings , api_version = self . api_version , ) def __ call__ ( self , * args : list , ** kwargs : dict ) -> Any : method = self . prev . split ( \".\" )[ - 1 ] path = \".\" . join ( self . prev . split ( \".\" )[:- 1 ]) module_path = f \"neuroio.{path}.v{self.api_version}\" v1_module = import_module ( module_path ) if v1_module: cls = getattr ( v1_module , ( \"ImplAsync\" if self . is_async else \"Impl\" ) ) inst = cls ( settings = self . settings ) if inst : return getattr ( inst , method )( * args , **kwargs ) Client class Client ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_version = api_version self . csettings = self . client_settings ( timeout = timeout , token = api_token ) self . init () def init ( self ) -> None : self . api_atrr_names = [ \"sources\", \"entries\", \"streams\", \"utility\", \"settings\", \"groups\", \"persons\", \"notifications\", ] self . iam_atrr_names = [ \"auth\", \"spaces\", \"lists\", \"licenses\", \"whoami\", \"tokens\", \"billing\", ] @cached_property def is_async ( self ) -> bool : return self . __class__ . __name__ == \"AsyncClient\" @property def common_headers ( self ) -> dict : root = \"neuroio-python\" if self . is_async : root = \"neuroio-async-python\" return { \"User-Agent\" : f \"{root}/{get_package_version()}\" } def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any, Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings def __getattr__ ( self , item : str ) -> Any : if item in self . api_atrr_names + self . iam_atrr_names : return Catcher ( prev = item , is_async = self . is_async , settings = self . csettings , api_version = self . api_version , ) else : # Default behaviour raise AttributeError Descendants neuroio.clients.AsyncClient Instance variables common_headers is_async Methods client_settings def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] View Source def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings init def init ( self ) -> None View Source def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ]","title":"Clients"},{"location":"reference/neuroio/clients/#module-neuroioclients","text":"None None View Source from importlib import import_module from typing import Any , Dict , Optional from neuroio import constants from neuroio . auth_token import AuthorizationTokenAuth from neuroio . utils import cached_property , get_package_version class Catcher : def __ init__ ( self , prev : str , is_async: bool , settings : dict , api_version: int ) -> None : self . prev = prev self . settings = settings self . is_async = is_async self . api_version = api_version def __ getattr__ ( self , item : str ) -> Any : return Catcher ( prev = f \"{self.prev}.{item}\" , is_async = self . is_async , settings = self . settings , api_version = self . api_version , ) def __ call__ ( self , * args : list , ** kwargs : dict ) -> Any : method = self . prev . split ( \".\" )[ - 1 ] path = \".\" . join ( self . prev . split ( \".\" )[:- 1 ]) module_path = f \"neuroio.{path}.v{self.api_version}\" v1_module = import_module ( module_path ) if v1_module: cls = getattr ( v1_module , ( \"ImplAsync\" if self . is_async else \"Impl\" ) ) inst = cls ( settings = self . settings ) if inst : return getattr ( inst , method )( * args , **kwargs ) class Client : def __ init__ ( self , api_token: Optional [ str ] = None , api_version: int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_version = api_version self . csettings = self . client_settings ( timeout = timeout , token = api_token ) self . init () def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ] @cached_property def is_async ( self ) -> bool : return self . __ class__ . __ name__ == \"AsyncClient\" @property def common_headers ( self ) -> dict : root = \"neuroio-python\" if self . is_async: root = \"neuroio-async-python\" return { \"User-Agent\" : f \"{root}/{get_package_version()}\" } def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings def __ getattr__ ( self , item : str ) -> Any : if item in self . api_atrr_names + self . iam_atrr_names: return Catcher ( prev = item , is_async = self . is_async , settings = self . csettings , api_version = self . api_version , ) else : # Default behaviour raise AttributeError class AsyncClient ( Client ) : pass","title":"Module neuroio.clients"},{"location":"reference/neuroio/clients/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/clients/#asyncclient","text":"class AsyncClient ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class AsyncClient ( Client ): pass","title":"AsyncClient"},{"location":"reference/neuroio/clients/#ancestors-in-mro","text":"neuroio.clients.Client","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/clients/#instance-variables","text":"common_headers is_async","title":"Instance variables"},{"location":"reference/neuroio/clients/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/clients/#client_settings","text":"def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] View Source def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings","title":"client_settings"},{"location":"reference/neuroio/clients/#init","text":"def init ( self ) -> None View Source def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ]","title":"init"},{"location":"reference/neuroio/clients/#catcher","text":"class Catcher ( prev : str , is_async : bool , settings : dict , api_version : int ) View Source class Catcher : def __ init__ ( self , prev : str , is_async: bool , settings : dict , api_version: int ) -> None : self . prev = prev self . settings = settings self . is_async = is_async self . api_version = api_version def __ getattr__ ( self , item : str ) -> Any : return Catcher ( prev = f \"{self.prev}.{item}\" , is_async = self . is_async , settings = self . settings , api_version = self . api_version , ) def __ call__ ( self , * args : list , ** kwargs : dict ) -> Any : method = self . prev . split ( \".\" )[ - 1 ] path = \".\" . join ( self . prev . split ( \".\" )[:- 1 ]) module_path = f \"neuroio.{path}.v{self.api_version}\" v1_module = import_module ( module_path ) if v1_module: cls = getattr ( v1_module , ( \"ImplAsync\" if self . is_async else \"Impl\" ) ) inst = cls ( settings = self . settings ) if inst : return getattr ( inst , method )( * args , **kwargs )","title":"Catcher"},{"location":"reference/neuroio/clients/#client","text":"class Client ( api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = 4.0 ) View Source class Client : def __init__ ( self , api_token : Optional [ str ] = None , api_version : int = 1 , timeout : float = constants . HTTP_CLIENT_TIMEOUT , ) : \"\"\" Creates and manages singleton of HTTP client, that is used to make request to API. \"\"\" self . api_version = api_version self . csettings = self . client_settings ( timeout = timeout , token = api_token ) self . init () def init ( self ) -> None : self . api_atrr_names = [ \"sources\", \"entries\", \"streams\", \"utility\", \"settings\", \"groups\", \"persons\", \"notifications\", ] self . iam_atrr_names = [ \"auth\", \"spaces\", \"lists\", \"licenses\", \"whoami\", \"tokens\", \"billing\", ] @cached_property def is_async ( self ) -> bool : return self . __class__ . __name__ == \"AsyncClient\" @property def common_headers ( self ) -> dict : root = \"neuroio-python\" if self . is_async : root = \"neuroio-async-python\" return { \"User-Agent\" : f \"{root}/{get_package_version()}\" } def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any, Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings def __getattr__ ( self , item : str ) -> Any : if item in self . api_atrr_names + self . iam_atrr_names : return Catcher ( prev = item , is_async = self . is_async , settings = self . csettings , api_version = self . api_version , ) else : # Default behaviour raise AttributeError","title":"Client"},{"location":"reference/neuroio/clients/#descendants","text":"neuroio.clients.AsyncClient","title":"Descendants"},{"location":"reference/neuroio/clients/#instance-variables_1","text":"common_headers is_async","title":"Instance variables"},{"location":"reference/neuroio/clients/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/clients/#client_settings_1","text":"def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] View Source def client_settings ( self , timeout : float , token : str = None ) -> Dict [ Any , Any ] : settings = { \"timeout\" : timeout , \"headers\" : self . common_headers , } if token : settings [ \"auth\" ] = AuthorizationTokenAuth ( api_token = token ) return settings","title":"client_settings"},{"location":"reference/neuroio/clients/#init_1","text":"def init ( self ) -> None View Source def init ( self ) -> None : self . api_atrr_names = [ \"sources\" , \"entries\" , \"streams\" , \"utility\" , \"settings\" , \"groups\" , \"persons\" , \"notifications\" , ] self . iam_atrr_names = [ \"auth\" , \"spaces\" , \"lists\" , \"licenses\" , \"whoami\" , \"tokens\" , \"billing\" , ]","title":"init"},{"location":"reference/neuroio/constants/","text":"Module neuroio.constants None None View Source from enum import Enum API_BASE_URL : str = \"https://api.neuroio.com\" IAM_BASE_URL : str = \"https://iam.neuroio.com\" EVENTS_BASE_URL : str = \"wss://events.neuroio.com\" HTTP_CLIENT_TIMEOUT : float = 4.0 sentinel = object () class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\" class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\" class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\" class Sex ( int , Enum ): MALE = 0 FEMALE = 1 class HttpMethod ( int , Enum ): POST = 0 GET = 1 DEFAULT_EXACT_THRESHOLD = 79.3 DEFAULT_HA_THRESHOLD = 75.5 DEFAULT_JUNK_THRESHOLD = 68.84 Variables API_BASE_URL DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD EVENTS_BASE_URL HTTP_CLIENT_TIMEOUT IAM_BASE_URL sentinel Classes EntryLiveness class EntryLiveness ( / , * args , ** kwargs ) View Source class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\" Ancestors (in MRO) builtins.str enum.Enum Class variables FAILED PASSED UNDETERMINED name value EntryMood class EntryMood ( / , * args , ** kwargs ) View Source class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\" Ancestors (in MRO) builtins.str enum.Enum Class variables ANGER CONTEMPT DET DISGUST FEAR HAPPINESS NEUTRAL NM SADNESS SURPRISE name value EntryResult class EntryResult ( / , * args , ** kwargs ) View Source class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\" Ancestors (in MRO) builtins.str enum.Enum Class variables DET EXACT HA JUNK NEW NM REINIT name value HttpMethod class HttpMethod ( / , * args , ** kwargs ) View Source class HttpMethod ( int , Enum ): POST = 0 GET = 1 Ancestors (in MRO) builtins.int enum.Enum Class variables GET POST name value Sex class Sex ( / , * args , ** kwargs ) View Source class Sex ( int , Enum ): MALE = 0 FEMALE = 1 Ancestors (in MRO) builtins.int enum.Enum Class variables FEMALE MALE name value","title":"Constants"},{"location":"reference/neuroio/constants/#module-neuroioconstants","text":"None None View Source from enum import Enum API_BASE_URL : str = \"https://api.neuroio.com\" IAM_BASE_URL : str = \"https://iam.neuroio.com\" EVENTS_BASE_URL : str = \"wss://events.neuroio.com\" HTTP_CLIENT_TIMEOUT : float = 4.0 sentinel = object () class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\" class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\" class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\" class Sex ( int , Enum ): MALE = 0 FEMALE = 1 class HttpMethod ( int , Enum ): POST = 0 GET = 1 DEFAULT_EXACT_THRESHOLD = 79.3 DEFAULT_HA_THRESHOLD = 75.5 DEFAULT_JUNK_THRESHOLD = 68.84","title":"Module neuroio.constants"},{"location":"reference/neuroio/constants/#variables","text":"API_BASE_URL DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD EVENTS_BASE_URL HTTP_CLIENT_TIMEOUT IAM_BASE_URL sentinel","title":"Variables"},{"location":"reference/neuroio/constants/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/constants/#entryliveness","text":"class EntryLiveness ( / , * args , ** kwargs ) View Source class EntryLiveness ( str , Enum ): PASSED = \"passed\" FAILED = \"failed\" UNDETERMINED = \"undetermined\"","title":"EntryLiveness"},{"location":"reference/neuroio/constants/#ancestors-in-mro","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables","text":"FAILED PASSED UNDETERMINED name value","title":"Class variables"},{"location":"reference/neuroio/constants/#entrymood","text":"class EntryMood ( / , * args , ** kwargs ) View Source class EntryMood ( str , Enum ): NEUTRAL = \"neutral\" ANGER = \"anger\" CONTEMPT = \"contempt\" DISGUST = \"disgust\" FEAR = \"fear\" HAPPINESS = \"happiness\" SADNESS = \"sadness\" SURPRISE = \"surprise\" NM = \"nm\" DET = \"det\"","title":"EntryMood"},{"location":"reference/neuroio/constants/#ancestors-in-mro_1","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_1","text":"ANGER CONTEMPT DET DISGUST FEAR HAPPINESS NEUTRAL NM SADNESS SURPRISE name value","title":"Class variables"},{"location":"reference/neuroio/constants/#entryresult","text":"class EntryResult ( / , * args , ** kwargs ) View Source class EntryResult ( str , Enum ): NEW = \"new\" REINIT = \"reinit\" EXACT = \"exact\" HA = \"ha\" JUNK = \"junk\" NM = \"nm\" DET = \"det\"","title":"EntryResult"},{"location":"reference/neuroio/constants/#ancestors-in-mro_2","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_2","text":"DET EXACT HA JUNK NEW NM REINIT name value","title":"Class variables"},{"location":"reference/neuroio/constants/#httpmethod","text":"class HttpMethod ( / , * args , ** kwargs ) View Source class HttpMethod ( int , Enum ): POST = 0 GET = 1","title":"HttpMethod"},{"location":"reference/neuroio/constants/#ancestors-in-mro_3","text":"builtins.int enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_3","text":"GET POST name value","title":"Class variables"},{"location":"reference/neuroio/constants/#sex","text":"class Sex ( / , * args , ** kwargs ) View Source class Sex ( int , Enum ): MALE = 0 FEMALE = 1","title":"Sex"},{"location":"reference/neuroio/constants/#ancestors-in-mro_4","text":"builtins.int enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/constants/#class-variables_4","text":"FEMALE MALE name value","title":"Class variables"},{"location":"reference/neuroio/listeners/","text":"Module neuroio.listeners None None View Source import asyncio import json from typing import Awaitable , Callable , Dict , List , Optional , Union from websockets.exceptions import ConnectionClosed from websockets.legacy.client import WebSocketClientProtocol , connect from neuroio import constants from neuroio.utils import repeat class EventListener : def __init__ ( self , api_token : str , event_handler_func : Callable [[ str ], Awaitable [ None ]], timeout : Optional [ float ] = constants . HTTP_CLIENT_TIMEOUT , ) -> None : \"\"\" Creates and manages single WebSocket Client object, that is used to send & receive messages in Events service. \"\"\" self . api_token = api_token self . event_handler_func = event_handler_func self . timeout = timeout self . websocket : Optional [ WebSocketClientProtocol ] = None async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data )) async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} ) async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" }) Classes EventListener class EventListener ( api_token : str , event_handler_func : Callable [[ str ], Awaitable [ NoneType ]], timeout : Optional [ float ] = 4.0 ) View Source class EventListener : def __init__ ( self , api_token : str , event_handler_func : Callable [[ str ], Awaitable [ None ]], timeout : Optional [ float ] = constants . HTTP_CLIENT_TIMEOUT , ) -> None : \"\"\" Creates and manages single WebSocket Client object, that is used to send & receive messages in Events service. \"\"\" self . api_token = api_token self . event_handler_func = event_handler_func self . timeout = timeout self . websocket : Optional [ WebSocketClientProtocol ] = None async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data )) async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} ) async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" }) Methods authorize def authorize ( self ) -> None View Source async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} ) listen def listen ( self ) -> None View Source async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue ping def ping ( self ) -> None View Source async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" }) send_json def send_json ( self , data : Union [ List , Dict ] ) -> None View Source async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data ))","title":"Listeners"},{"location":"reference/neuroio/listeners/#module-neuroiolisteners","text":"None None View Source import asyncio import json from typing import Awaitable , Callable , Dict , List , Optional , Union from websockets.exceptions import ConnectionClosed from websockets.legacy.client import WebSocketClientProtocol , connect from neuroio import constants from neuroio.utils import repeat class EventListener : def __init__ ( self , api_token : str , event_handler_func : Callable [[ str ], Awaitable [ None ]], timeout : Optional [ float ] = constants . HTTP_CLIENT_TIMEOUT , ) -> None : \"\"\" Creates and manages single WebSocket Client object, that is used to send & receive messages in Events service. \"\"\" self . api_token = api_token self . event_handler_func = event_handler_func self . timeout = timeout self . websocket : Optional [ WebSocketClientProtocol ] = None async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data )) async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} ) async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" })","title":"Module neuroio.listeners"},{"location":"reference/neuroio/listeners/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/listeners/#eventlistener","text":"class EventListener ( api_token : str , event_handler_func : Callable [[ str ], Awaitable [ NoneType ]], timeout : Optional [ float ] = 4.0 ) View Source class EventListener : def __init__ ( self , api_token : str , event_handler_func : Callable [[ str ], Awaitable [ None ]], timeout : Optional [ float ] = constants . HTTP_CLIENT_TIMEOUT , ) -> None : \"\"\" Creates and manages single WebSocket Client object, that is used to send & receive messages in Events service. \"\"\" self . api_token = api_token self . event_handler_func = event_handler_func self . timeout = timeout self . websocket : Optional [ WebSocketClientProtocol ] = None async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data )) async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} ) async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" })","title":"EventListener"},{"location":"reference/neuroio/listeners/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/listeners/#authorize","text":"def authorize ( self ) -> None View Source async def authorize ( self ) -> None : await self . send_json ( { \"action\" : \"AUTH\" , \"data\" : { \"token\" : self . api_token }} )","title":"authorize"},{"location":"reference/neuroio/listeners/#listen","text":"def listen ( self ) -> None View Source async def listen ( self ) -> None : async for websocket in connect ( constants . EVENTS_BASE_URL , open_timeout = self . timeout ): try : self . websocket = websocket await self . authorize () asyncio . create_task ( repeat ( 5 , self . ping )) async for message in websocket : if not isinstance ( message , bytes ): await self . event_handler_func ( message ) except ConnectionClosed : self . websocket = None continue","title":"listen"},{"location":"reference/neuroio/listeners/#ping","text":"def ping ( self ) -> None View Source async def ping ( self ) -> None : await self . send_json ({ \"action\" : \"PING\" })","title":"ping"},{"location":"reference/neuroio/listeners/#send_json","text":"def send_json ( self , data : Union [ List , Dict ] ) -> None View Source async def send_json ( self , data : Union [ List , Dict ]) -> None : if self . websocket is not None : await self . websocket . send ( json . dumps ( data ))","title":"send_json"},{"location":"reference/neuroio/utils/","text":"Module neuroio.utils None None View Source import asyncio import datetime import functools import io from typing import ( Any , BinaryIO , Callable , List , Optional , Tuple , TypeVar , Union , ) import _io from neuroio.constants import sentinel ImageType = Union [ BinaryIO , Tuple [ str , io . BytesIO ], bytes ] def validate_month_str ( month_str : str ) -> None : try : datetime . datetime . strptime ( month_str , \"%Y-%m\" ) except ValueError : raise ValueError ( f \"Incorrect month format in { month_str } , should be YYYY-MM\" ) def get_package_version () -> str : from neuroio import __version__ return __version__ F = TypeVar ( \"F\" , bound = Callable [ ... , Any ]) def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f )) def prepare_image_processing ( image : ImageType , filename : str = \"image\" ) -> dict : if isinstance ( image , ( bytes , bytearray )): image_data = io . BytesIO ( image ) elif isinstance ( image , _io . BufferedReader ): image_data = image filename = image . name elif isinstance ( image , tuple ): filename , image_data = image else : raise Exception ( \"Wrong image datatype\" ) return { \"image\" : ( filename , image_data )} def process_query_params ( params : dict ) -> dict : for key , item in params . items (): if isinstance ( item , list ): params [ key ] = \",\" . join ( map ( str , item )) return params def request_dict_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict : inner_exclude : List [ str ] = [ \"self\" ] if exclude is not None : inner_exclude . extend ( exclude ) return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in inner_exclude , local_items . items (), ) ) def request_query_processing ( local_items : dict , exclude : Union [ List [ str ], None ] = None ) -> dict : if exclude is None : exclude = [] return process_query_params ( request_dict_processing ( local_items , exclude )) def request_form_processing ( local_items : dict , exclude : Union [ List [ str ], None ] = None ) -> dict : if exclude is None : exclude = [] return { key : str ( value ) for key , value in request_dict_processing ( local_items , exclude ) . items () } async def repeat ( interval : float , func : Callable , * args : Any , ** kwargs : Any , ) -> None : \"\"\"Run func every interval seconds. If func has not finished before *interval*, will run again immediately when the previous iteration finished. *args and **kwargs are passed as the arguments to func. \"\"\" while True : await asyncio . gather ( func ( * args , ** kwargs ), asyncio . sleep ( interval ), ) Variables F ImageType sentinel Functions cached_property def cached_property ( f : ~ F ) -> property View Source def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f )) get_package_version def get_package_version ( ) -> str View Source def get_package_version () -> str : from neuroio import __version__ return __version__ prepare_image_processing def prepare_image_processing ( image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], filename : str = 'image' ) -> dict View Source def prepare_image_processing ( image : ImageType , filename : str = \"image\" ) -> dict : if isinstance ( image , ( bytes , bytearray )) : image_data = io . BytesIO ( image ) elif isinstance ( image , _io . BufferedReader ) : image_data = image filename = image . name elif isinstance ( image , tuple ) : filename , image_data = image else : raise Exception ( \"Wrong image datatype\" ) return { \"image\" : ( filename , image_data )} process_query_params def process_query_params ( params : dict ) -> dict View Source def process_query_params ( params : dict ) -> dict : for key , item in params . items () : if isinstance ( item , list ) : params [ key ] = \",\" . join ( map ( str , item )) return params repeat def repeat ( interval : float , func : Callable , * args : Any , ** kwargs : Any ) -> None Run func every interval seconds. If func has not finished before interval , will run again immediately when the previous iteration finished. args and *kwargs are passed as the arguments to func. View Source async def repeat ( interval : float , func : Callable , * args : Any , ** kwargs : Any , ) -> None : \"\"\"Run func every interval seconds. If func has not finished before *interval*, will run again immediately when the previous iteration finished. *args and **kwargs are passed as the arguments to func. \"\"\" while True : await asyncio . gather ( func ( * args , ** kwargs ), asyncio . sleep ( interval ), ) request_dict_processing def request_dict_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_dict_processing ( local_items : dict , exclude : Optional [ List[str ] ] = None ) -> dict : inner_exclude : List [ str ] = [ \"self\" ] if exclude is not None : inner_exclude . extend ( exclude ) return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in inner_exclude , local_items . items (), ) ) request_form_processing def request_form_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_form_processing ( local_items : dict , exclude : Union [ List[str ] , None ] = None ) -> dict : if exclude is None : exclude = [] return { key : str ( value ) for key , value in request_dict_processing ( local_items , exclude ). items () } request_query_processing def request_query_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_query_processing ( local_items : dict , exclude : Union [ List[str ] , None ] = None ) -> dict : if exclude is None : exclude = [] return process_query_params ( request_dict_processing ( local_items , exclude )) validate_month_str def validate_month_str ( month_str : str ) -> None View Source def validate_month_str ( month_str : str ) -> None : try : datetime . datetime . strptime ( month_str , \"%Y-%m\" ) except ValueError : raise ValueError ( f \"Incorrect month format in {month_str}, should be YYYY-MM\" )","title":"Utils"},{"location":"reference/neuroio/utils/#module-neuroioutils","text":"None None View Source import asyncio import datetime import functools import io from typing import ( Any , BinaryIO , Callable , List , Optional , Tuple , TypeVar , Union , ) import _io from neuroio.constants import sentinel ImageType = Union [ BinaryIO , Tuple [ str , io . BytesIO ], bytes ] def validate_month_str ( month_str : str ) -> None : try : datetime . datetime . strptime ( month_str , \"%Y-%m\" ) except ValueError : raise ValueError ( f \"Incorrect month format in { month_str } , should be YYYY-MM\" ) def get_package_version () -> str : from neuroio import __version__ return __version__ F = TypeVar ( \"F\" , bound = Callable [ ... , Any ]) def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f )) def prepare_image_processing ( image : ImageType , filename : str = \"image\" ) -> dict : if isinstance ( image , ( bytes , bytearray )): image_data = io . BytesIO ( image ) elif isinstance ( image , _io . BufferedReader ): image_data = image filename = image . name elif isinstance ( image , tuple ): filename , image_data = image else : raise Exception ( \"Wrong image datatype\" ) return { \"image\" : ( filename , image_data )} def process_query_params ( params : dict ) -> dict : for key , item in params . items (): if isinstance ( item , list ): params [ key ] = \",\" . join ( map ( str , item )) return params def request_dict_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict : inner_exclude : List [ str ] = [ \"self\" ] if exclude is not None : inner_exclude . extend ( exclude ) return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in inner_exclude , local_items . items (), ) ) def request_query_processing ( local_items : dict , exclude : Union [ List [ str ], None ] = None ) -> dict : if exclude is None : exclude = [] return process_query_params ( request_dict_processing ( local_items , exclude )) def request_form_processing ( local_items : dict , exclude : Union [ List [ str ], None ] = None ) -> dict : if exclude is None : exclude = [] return { key : str ( value ) for key , value in request_dict_processing ( local_items , exclude ) . items () } async def repeat ( interval : float , func : Callable , * args : Any , ** kwargs : Any , ) -> None : \"\"\"Run func every interval seconds. If func has not finished before *interval*, will run again immediately when the previous iteration finished. *args and **kwargs are passed as the arguments to func. \"\"\" while True : await asyncio . gather ( func ( * args , ** kwargs ), asyncio . sleep ( interval ), )","title":"Module neuroio.utils"},{"location":"reference/neuroio/utils/#variables","text":"F ImageType sentinel","title":"Variables"},{"location":"reference/neuroio/utils/#functions","text":"","title":"Functions"},{"location":"reference/neuroio/utils/#cached_property","text":"def cached_property ( f : ~ F ) -> property View Source def cached_property ( f : F ) -> property : return property ( functools . lru_cache ()( f ))","title":"cached_property"},{"location":"reference/neuroio/utils/#get_package_version","text":"def get_package_version ( ) -> str View Source def get_package_version () -> str : from neuroio import __version__ return __version__","title":"get_package_version"},{"location":"reference/neuroio/utils/#prepare_image_processing","text":"def prepare_image_processing ( image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], filename : str = 'image' ) -> dict View Source def prepare_image_processing ( image : ImageType , filename : str = \"image\" ) -> dict : if isinstance ( image , ( bytes , bytearray )) : image_data = io . BytesIO ( image ) elif isinstance ( image , _io . BufferedReader ) : image_data = image filename = image . name elif isinstance ( image , tuple ) : filename , image_data = image else : raise Exception ( \"Wrong image datatype\" ) return { \"image\" : ( filename , image_data )}","title":"prepare_image_processing"},{"location":"reference/neuroio/utils/#process_query_params","text":"def process_query_params ( params : dict ) -> dict View Source def process_query_params ( params : dict ) -> dict : for key , item in params . items () : if isinstance ( item , list ) : params [ key ] = \",\" . join ( map ( str , item )) return params","title":"process_query_params"},{"location":"reference/neuroio/utils/#repeat","text":"def repeat ( interval : float , func : Callable , * args : Any , ** kwargs : Any ) -> None Run func every interval seconds. If func has not finished before interval , will run again immediately when the previous iteration finished. args and *kwargs are passed as the arguments to func. View Source async def repeat ( interval : float , func : Callable , * args : Any , ** kwargs : Any , ) -> None : \"\"\"Run func every interval seconds. If func has not finished before *interval*, will run again immediately when the previous iteration finished. *args and **kwargs are passed as the arguments to func. \"\"\" while True : await asyncio . gather ( func ( * args , ** kwargs ), asyncio . sleep ( interval ), )","title":"repeat"},{"location":"reference/neuroio/utils/#request_dict_processing","text":"def request_dict_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_dict_processing ( local_items : dict , exclude : Optional [ List[str ] ] = None ) -> dict : inner_exclude : List [ str ] = [ \"self\" ] if exclude is not None : inner_exclude . extend ( exclude ) return dict ( filter ( lambda kwarg : kwarg [ 1 ] is not sentinel and kwarg [ 0 ] not in inner_exclude , local_items . items (), ) )","title":"request_dict_processing"},{"location":"reference/neuroio/utils/#request_form_processing","text":"def request_form_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_form_processing ( local_items : dict , exclude : Union [ List[str ] , None ] = None ) -> dict : if exclude is None : exclude = [] return { key : str ( value ) for key , value in request_dict_processing ( local_items , exclude ). items () }","title":"request_form_processing"},{"location":"reference/neuroio/utils/#request_query_processing","text":"def request_query_processing ( local_items : dict , exclude : Optional [ List [ str ]] = None ) -> dict View Source def request_query_processing ( local_items : dict , exclude : Union [ List[str ] , None ] = None ) -> dict : if exclude is None : exclude = [] return process_query_params ( request_dict_processing ( local_items , exclude ))","title":"request_query_processing"},{"location":"reference/neuroio/utils/#validate_month_str","text":"def validate_month_str ( month_str : str ) -> None View Source def validate_month_str ( month_str : str ) -> None : try : datetime . datetime . strptime ( month_str , \"%Y-%m\" ) except ValueError : raise ValueError ( f \"Incorrect month format in {month_str}, should be YYYY-MM\" )","title":"validate_month_str"},{"location":"reference/neuroio/auth/","text":"Module neuroio.auth None None Sub-modules neuroio.auth.v1","title":"Index"},{"location":"reference/neuroio/auth/#module-neuroioauth","text":"None None","title":"Module neuroio.auth"},{"location":"reference/neuroio/auth/#sub-modules","text":"neuroio.auth.v1","title":"Sub-modules"},{"location":"reference/neuroio/auth/v1/","text":"Module neuroio.auth.v1 None None View Source from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class AuthBase ( IAMBaseBase ): def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/auth/ { key } /\" class Impl ( IAMBase , AuthBase ): def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } with self . get_client () as client : return client . post ( url = self . get_url ( \"token\" ), json = data ) def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client : return client . post ( url = self . get_url ( \"password/change\" ), json = data ) class ImplAsync ( IAMBaseAsync , AuthBase ): async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"token\" ), json = data ) async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"password/change\" ), json = data ) Classes AuthBase class AuthBase ( / , * args , ** kwargs ) View Source class AuthBase ( IAMBaseBase ): def get_url ( self , key: str ) -> str: return self . base_url + f \"/v1/auth/{key}/\" Ancestors (in MRO) neuroio.base.IAMBaseBase Descendants neuroio.auth.v1.Impl neuroio.auth.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/auth/{key}/\" Impl class Impl ( settings : dict ) View Source class Impl ( IAMBase , AuthBase ): def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } with self . get_client () as client: return client . post ( url = self . get_url ( \"token\" ), json = data ) def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client: return client . post ( url = self . get_url ( \"password/change\" ), json = data ) Ancestors (in MRO) neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.auth.v1.AuthBase neuroio.base.IAMBaseBase Class variables base_url Methods get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/auth/{key}/\" login def login ( self , username : str , password : str ) -> httpx . Response View Source def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } with self . get_client () as client : return client . post ( url = self . get_url ( \"token\" ), json = data ) password_change def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . Response View Source def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client : return client . post ( url = self . get_url ( \"password/change\" ), json = data ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , AuthBase ): async def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } async with self . get_client () as client: return await client . post ( url = self . get_url ( \"token\" ), json = data ) async def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client: return await client . post ( url = self . get_url ( \"password/change\" ), json = data ) Ancestors (in MRO) neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.auth.v1.AuthBase neuroio.base.IAMBaseBase Class variables base_url Methods get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/auth/{key}/\" login def login ( self , username : str , password : str ) -> httpx . Response View Source async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"token\" ), json = data ) password_change def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . Response View Source async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"password/change\" ), json = data )","title":"V1"},{"location":"reference/neuroio/auth/v1/#module-neuroioauthv1","text":"None None View Source from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class AuthBase ( IAMBaseBase ): def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/auth/ { key } /\" class Impl ( IAMBase , AuthBase ): def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } with self . get_client () as client : return client . post ( url = self . get_url ( \"token\" ), json = data ) def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client : return client . post ( url = self . get_url ( \"password/change\" ), json = data ) class ImplAsync ( IAMBaseAsync , AuthBase ): async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"token\" ), json = data ) async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"password/change\" ), json = data )","title":"Module neuroio.auth.v1"},{"location":"reference/neuroio/auth/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/auth/v1/#authbase","text":"class AuthBase ( / , * args , ** kwargs ) View Source class AuthBase ( IAMBaseBase ): def get_url ( self , key: str ) -> str: return self . base_url + f \"/v1/auth/{key}/\"","title":"AuthBase"},{"location":"reference/neuroio/auth/v1/#ancestors-in-mro","text":"neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/auth/v1/#descendants","text":"neuroio.auth.v1.Impl neuroio.auth.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/auth/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/auth/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/auth/v1/#get_url","text":"def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/auth/{key}/\"","title":"get_url"},{"location":"reference/neuroio/auth/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( IAMBase , AuthBase ): def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } with self . get_client () as client: return client . post ( url = self . get_url ( \"token\" ), json = data ) def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client: return client . post ( url = self . get_url ( \"password/change\" ), json = data )","title":"Impl"},{"location":"reference/neuroio/auth/v1/#ancestors-in-mro_1","text":"neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.auth.v1.AuthBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/auth/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/auth/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/auth/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/auth/v1/#get_url_1","text":"def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/auth/{key}/\"","title":"get_url"},{"location":"reference/neuroio/auth/v1/#login","text":"def login ( self , username : str , password : str ) -> httpx . Response View Source def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } with self . get_client () as client : return client . post ( url = self . get_url ( \"token\" ), json = data )","title":"login"},{"location":"reference/neuroio/auth/v1/#password_change","text":"def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . Response View Source def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } with self . get_client () as client : return client . post ( url = self . get_url ( \"password/change\" ), json = data )","title":"password_change"},{"location":"reference/neuroio/auth/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , AuthBase ): async def login ( self , username: str , password: str ) -> Response: data = { \"username\" : username , \"password\" : password } async with self . get_client () as client: return await client . post ( url = self . get_url ( \"token\" ), json = data ) async def password_change ( self , old_password: str , new_password: str , reset_tokens: bool = False ) -> Response: data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client: return await client . post ( url = self . get_url ( \"password/change\" ), json = data )","title":"ImplAsync"},{"location":"reference/neuroio/auth/v1/#ancestors-in-mro_2","text":"neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.auth.v1.AuthBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/auth/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/auth/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/auth/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/auth/v1/#get_url_2","text":"def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/auth/{key}/\"","title":"get_url"},{"location":"reference/neuroio/auth/v1/#login_1","text":"def login ( self , username : str , password : str ) -> httpx . Response View Source async def login ( self , username : str , password : str ) -> Response : data = { \"username\" : username , \"password\" : password } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"token\" ), json = data )","title":"login"},{"location":"reference/neuroio/auth/v1/#password_change_1","text":"def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> httpx . Response View Source async def password_change ( self , old_password : str , new_password : str , reset_tokens : bool = False ) -> Response : data = { \"old_password\" : old_password , \"password\" : new_password , \"password2\" : new_password , \"reset_tokens\" : reset_tokens , } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"password/change\" ), json = data )","title":"password_change"},{"location":"reference/neuroio/billing/","text":"Module neuroio.billing None None Sub-modules neuroio.billing.v1","title":"Index"},{"location":"reference/neuroio/billing/#module-neuroiobilling","text":"None None","title":"Module neuroio.billing"},{"location":"reference/neuroio/billing/#sub-modules","text":"neuroio.billing.v1","title":"Sub-modules"},{"location":"reference/neuroio/billing/v1/","text":"Module neuroio.billing.v1 None None View Source from typing import List , Union , cast from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase from neuroio.constants import sentinel from neuroio.utils import request_query_processing , validate_month_str class BillingBase ( IAMBaseBase ): def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/billing/ { key } /\" class Impl ( IAMBase , BillingBase ): def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List [ int ], object ] = sentinel , event_types : Union [ List [ int ], object ] = sentinel , month_from : Union [ str , object ] = sentinel , month_to : Union [ str , object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage\" ), params = data ) def usage_total ( self , spaces_ids : Union [ List [ int ], object ] = sentinel , event_types : Union [ List [ int ], object ] = sentinel , month_from : Union [ str , object ] = sentinel , month_to : Union [ str , object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage/total\" ), params = data ) class ImplAsync ( IAMBaseAsync , BillingBase ): async def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List [ int ], object ] = sentinel , event_types : Union [ List [ int ], object ] = sentinel , month_from : Union [ str , object ] = sentinel , month_to : Union [ str , object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage\" ), params = data ) async def usage_total ( self , spaces_ids : Union [ List [ int ], object ] = sentinel , event_types : Union [ List [ int ], object ] = sentinel , month_from : Union [ str , object ] = sentinel , month_to : Union [ str , object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage/total\" ), params = data ) Variables sentinel Classes BillingBase class BillingBase ( / , * args , ** kwargs ) View Source class BillingBase ( IAMBaseBase ): def get_url ( self , key: str ) -> str: return self . base_url + f \"/v1/billing/{key}/\" Ancestors (in MRO) neuroio.base.IAMBaseBase Descendants neuroio.billing.v1.Impl neuroio.billing.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/billing/{key}/\" Impl class Impl ( settings : dict ) View Source class Impl ( IAMBase , BillingBase ) : def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage\" ), params = data ) def usage_total ( self , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage/total\" ), params = data ) Ancestors (in MRO) neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.billing.v1.BillingBase neuroio.base.IAMBaseBase Class variables base_url Methods get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/billing/{key}/\" usage def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , event_types : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , month_from : Union [ str , object ] = < object object at 0x10c207fb0 > , month_to : Union [ str , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage\" ), params = data ) usage_total def usage_total ( self , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , event_types : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , month_from : Union [ str , object ] = < object object at 0x10c207fb0 > , month_to : Union [ str , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def usage_total ( self , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage/total\" ), params = data ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , BillingBase ) : async def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage\" ), params = data ) async def usage_total ( self , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage/total\" ), params = data ) Ancestors (in MRO) neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.billing.v1.BillingBase neuroio.base.IAMBaseBase Class variables base_url Methods get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/billing/{key}/\" usage def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , event_types : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , month_from : Union [ str , object ] = < object object at 0x10c207fb0 > , month_to : Union [ str , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage\" ), params = data ) usage_total def usage_total ( self , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , event_types : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , month_from : Union [ str , object ] = < object object at 0x10c207fb0 > , month_to : Union [ str , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def usage_total ( self , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage/total\" ), params = data )","title":"V1"},{"location":"reference/neuroio/billing/v1/#module-neuroiobillingv1","text":"None None View Source from typing import List , Union , cast from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase from neuroio.constants import sentinel from neuroio.utils import request_query_processing , validate_month_str class BillingBase ( IAMBaseBase ): def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/billing/ { key } /\" class Impl ( IAMBase , BillingBase ): def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List [ int ], object ] = sentinel , event_types : Union [ List [ int ], object ] = sentinel , month_from : Union [ str , object ] = sentinel , month_to : Union [ str , object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage\" ), params = data ) def usage_total ( self , spaces_ids : Union [ List [ int ], object ] = sentinel , event_types : Union [ List [ int ], object ] = sentinel , month_from : Union [ str , object ] = sentinel , month_to : Union [ str , object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage/total\" ), params = data ) class ImplAsync ( IAMBaseAsync , BillingBase ): async def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List [ int ], object ] = sentinel , event_types : Union [ List [ int ], object ] = sentinel , month_from : Union [ str , object ] = sentinel , month_to : Union [ str , object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage\" ), params = data ) async def usage_total ( self , spaces_ids : Union [ List [ int ], object ] = sentinel , event_types : Union [ List [ int ], object ] = sentinel , month_from : Union [ str , object ] = sentinel , month_to : Union [ str , object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage/total\" ), params = data )","title":"Module neuroio.billing.v1"},{"location":"reference/neuroio/billing/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/billing/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/billing/v1/#billingbase","text":"class BillingBase ( / , * args , ** kwargs ) View Source class BillingBase ( IAMBaseBase ): def get_url ( self , key: str ) -> str: return self . base_url + f \"/v1/billing/{key}/\"","title":"BillingBase"},{"location":"reference/neuroio/billing/v1/#ancestors-in-mro","text":"neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/billing/v1/#descendants","text":"neuroio.billing.v1.Impl neuroio.billing.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/billing/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/billing/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/billing/v1/#get_url","text":"def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/billing/{key}/\"","title":"get_url"},{"location":"reference/neuroio/billing/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( IAMBase , BillingBase ) : def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage\" ), params = data ) def usage_total ( self , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage/total\" ), params = data )","title":"Impl"},{"location":"reference/neuroio/billing/v1/#ancestors-in-mro_1","text":"neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.billing.v1.BillingBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/billing/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/billing/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/billing/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/billing/v1/#get_url_1","text":"def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/billing/{key}/\"","title":"get_url"},{"location":"reference/neuroio/billing/v1/#usage","text":"def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , event_types : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , month_from : Union [ str , object ] = < object object at 0x10c207fb0 > , month_to : Union [ str , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage\" ), params = data )","title":"usage"},{"location":"reference/neuroio/billing/v1/#usage_total","text":"def usage_total ( self , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , event_types : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , month_from : Union [ str , object ] = < object object at 0x10c207fb0 > , month_to : Union [ str , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def usage_total ( self , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( \"usage/total\" ), params = data )","title":"usage_total"},{"location":"reference/neuroio/billing/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , BillingBase ) : async def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage\" ), params = data ) async def usage_total ( self , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage/total\" ), params = data )","title":"ImplAsync"},{"location":"reference/neuroio/billing/v1/#ancestors-in-mro_2","text":"neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.billing.v1.BillingBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/billing/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/billing/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/billing/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/billing/v1/#get_url_2","text":"def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/billing/{key}/\"","title":"get_url"},{"location":"reference/neuroio/billing/v1/#usage_1","text":"def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , event_types : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , month_from : Union [ str , object ] = < object object at 0x10c207fb0 > , month_to : Union [ str , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def usage ( self , limit : int = 20 , offset : int = 0 , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage\" ), params = data )","title":"usage"},{"location":"reference/neuroio/billing/v1/#usage_total_1","text":"def usage_total ( self , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , event_types : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , month_from : Union [ str , object ] = < object object at 0x10c207fb0 > , month_to : Union [ str , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def usage_total ( self , spaces_ids : Union [ List[int ] , object ] = sentinel , event_types : Union [ List[int ] , object ] = sentinel , month_from : Union [ str, object ] = sentinel , month_to : Union [ str, object ] = sentinel , ) -> Response : if month_to != sentinel : validate_month_str ( cast ( str , month_to )) if month_from != sentinel : validate_month_str ( cast ( str , month_from )) data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( \"usage/total\" ), params = data )","title":"usage_total"},{"location":"reference/neuroio/entries/","text":"Module neuroio.entries None None Sub-modules neuroio.entries.v1","title":"Index"},{"location":"reference/neuroio/entries/#module-neuroioentries","text":"None None","title":"Module neuroio.entries"},{"location":"reference/neuroio/entries/#sub-modules","text":"neuroio.entries.v1","title":"Sub-modules"},{"location":"reference/neuroio/entries/v1/","text":"Module neuroio.entries.v1 None None View Source from datetime import datetime from typing import List , Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import EntryLiveness , EntryMood , EntryResult , sentinel from neuroio.utils import request_query_processing class EntriesBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/entries/ { key } /\" else : return self . base_url + \"/v1/entries/\" class Impl ( APIBase , EntriesBase ): def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"stats/pid/ { pid } \" )) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) class ImplAsync ( APIBaseAsync , EntriesBase ): async def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"stats/pid/ { pid } \" )) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" )) Variables sentinel Classes EntriesBase class EntriesBase ( / , * args , ** kwargs ) View Source class EntriesBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/entries/{key}/\" else: return self . base_url + \"/v1/entries/\" Ancestors (in MRO) neuroio.base.APIBaseBase Descendants neuroio.entries.v1.Impl neuroio.entries.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/entries/{key}/\" else : return self . base_url + \"/v1/entries/\" Impl class Impl ( settings : dict ) View Source class Impl ( APIBase , EntriesBase ) : def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"stats/pid/{pid}\" )) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) Ancestors (in MRO) neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.entries.v1.EntriesBase neuroio.base.APIBaseBase Class variables base_url Methods delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , pid : str ) -> httpx . Response View Source def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"stats/pid/{pid}\" )) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/entries/{key}/\" else : return self . base_url + \"/v1/entries/\" list def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ int , object ] = < object object at 0x10c207fb0 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , EntriesBase ) : async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"stats/pid/{pid}\" )) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) Ancestors (in MRO) neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.entries.v1.EntriesBase neuroio.base.APIBaseBase Class variables base_url Methods delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , pid : str ) -> httpx . Response View Source async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"stats/pid/{pid}\" )) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/entries/{key}/\" else : return self . base_url + \"/v1/entries/\" list def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ int , object ] = < object object at 0x10c207fb0 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data )","title":"V1"},{"location":"reference/neuroio/entries/v1/#module-neuroioentriesv1","text":"None None View Source from datetime import datetime from typing import List , Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import EntryLiveness , EntryMood , EntryResult , sentinel from neuroio.utils import request_query_processing class EntriesBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/entries/ { key } /\" else : return self . base_url + \"/v1/entries/\" class Impl ( APIBase , EntriesBase ): def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"stats/pid/ { pid } \" )) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) class ImplAsync ( APIBaseAsync , EntriesBase ): async def list ( self , pid : Union [ List [ str ], object ] = sentinel , result : Union [ List [ EntryResult ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ int , object ] = sentinel , mood : Union [ List [ EntryMood ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , sources_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"stats/pid/ { pid } \" )) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" ))","title":"Module neuroio.entries.v1"},{"location":"reference/neuroio/entries/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/entries/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/entries/v1/#entriesbase","text":"class EntriesBase ( / , * args , ** kwargs ) View Source class EntriesBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/entries/{key}/\" else: return self . base_url + \"/v1/entries/\"","title":"EntriesBase"},{"location":"reference/neuroio/entries/v1/#ancestors-in-mro","text":"neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/entries/v1/#descendants","text":"neuroio.entries.v1.Impl neuroio.entries.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/entries/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/entries/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/entries/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/entries/{key}/\" else : return self . base_url + \"/v1/entries/\"","title":"get_url"},{"location":"reference/neuroio/entries/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( APIBase , EntriesBase ) : def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"stats/pid/{pid}\" )) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" ))","title":"Impl"},{"location":"reference/neuroio/entries/v1/#ancestors-in-mro_1","text":"neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.entries.v1.EntriesBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/entries/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/entries/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/entries/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/entries/v1/#get","text":"def get ( self , pid : str ) -> httpx . Response View Source def get ( self , pid : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"stats/pid/{pid}\" ))","title":"get"},{"location":"reference/neuroio/entries/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/entries/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/entries/{key}/\" else : return self . base_url + \"/v1/entries/\"","title":"get_url"},{"location":"reference/neuroio/entries/v1/#list","text":"def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ int , object ] = < object object at 0x10c207fb0 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/entries/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , EntriesBase ) : async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"stats/pid/{pid}\" )) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" ))","title":"ImplAsync"},{"location":"reference/neuroio/entries/v1/#ancestors-in-mro_2","text":"neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.entries.v1.EntriesBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/entries/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/entries/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/entries/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/entries/v1/#get_1","text":"def get ( self , pid : str ) -> httpx . Response View Source async def get ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"stats/pid/{pid}\" ))","title":"get"},{"location":"reference/neuroio/entries/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/entries/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/entries/{key}/\" else : return self . base_url + \"/v1/entries/\"","title":"get_url"},{"location":"reference/neuroio/entries/v1/#list_1","text":"def list ( self , pid : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , result : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ int , object ] = < object object at 0x10c207fb0 > , mood : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , sources_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , date_from : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , pid : Union [ List[str ] , object ] = sentinel , result : Union [ List[EntryResult ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ int, object ] = sentinel , mood : Union [ List[EntryMood ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , sources_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , date_from : Union [ datetime, object ] = sentinel , date_to : Union [ datetime, object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/groups/","text":"Module neuroio.groups None None Sub-modules neuroio.groups.v1","title":"Index"},{"location":"reference/neuroio/groups/#module-neuroiogroups","text":"None None","title":"Module neuroio.groups"},{"location":"reference/neuroio/groups/#sub-modules","text":"neuroio.groups.v1","title":"Sub-modules"},{"location":"reference/neuroio/groups/v1/","text":"Module neuroio.groups.v1 None None View Source from typing import List , Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import sentinel from neuroio.utils import request_query_processing class GroupsBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/groups/persons/ { key } /\" else : return self . base_url + \"/v1/groups/persons/\" class Impl ( APIBase , GroupsBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } /pids\" ), params = data ) def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = self . get_url ( \"pids\" ), json = data ) def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data ) class ImplAsync ( APIBaseAsync , GroupsBase ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" )) async def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } /pids\" ), params = data ) async def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"pids\" ), json = data ) async def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data ) Variables sentinel Classes GroupsBase class GroupsBase ( / , * args , ** kwargs ) View Source class GroupsBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/groups/persons/{key}/\" else: return self . base_url + \"/v1/groups/persons/\" Ancestors (in MRO) neuroio.base.APIBaseBase Descendants neuroio.groups.v1.Impl neuroio.groups.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/groups/persons/{key}/\" else : return self . base_url + \"/v1/groups/persons/\" Impl class Impl ( settings : dict ) View Source class Impl ( APIBase , GroupsBase ) : def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}/pids\" ), params = data ) def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = self . get_url ( \"pids\" ), json = data ) def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data ) Ancestors (in MRO) neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.groups.v1.GroupsBase neuroio.base.APIBaseBase Class variables base_url Methods add def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = self . get_url ( \"pids\" ), json = data ) create def create ( self , name : str ) -> httpx . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/groups/persons/{key}/\" else : return self . base_url + \"/v1/groups/persons/\" list def list ( self , q : Union [ str , object ] = < object object at 0x10c207fb0 > , pids_include : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) persons def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}/pids\" ), params = data ) remove def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data ) update def update ( self , id : int , name : str ) -> httpx . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , GroupsBase ) : async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}/pids\" ), params = data ) async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"pids\" ), json = data ) async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data ) Ancestors (in MRO) neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.groups.v1.GroupsBase neuroio.base.APIBaseBase Class variables base_url Methods add def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"pids\" ), json = data ) create def create ( self , name : str ) -> httpx . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/groups/persons/{key}/\" else : return self . base_url + \"/v1/groups/persons/\" list def list ( self , q : Union [ str , object ] = < object object at 0x10c207fb0 > , pids_include : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) persons def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}/pids\" ), params = data ) remove def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data ) update def update ( self , id : int , name : str ) -> httpx . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"V1"},{"location":"reference/neuroio/groups/v1/#module-neuroiogroupsv1","text":"None None View Source from typing import List , Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import sentinel from neuroio.utils import request_query_processing class GroupsBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/groups/persons/ { key } /\" else : return self . base_url + \"/v1/groups/persons/\" class Impl ( APIBase , GroupsBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } /pids\" ), params = data ) def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = self . get_url ( \"pids\" ), json = data ) def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data ) class ImplAsync ( APIBaseAsync , GroupsBase ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : Union [ str , object ] = sentinel , pids_include : Union [ List [ str ], object ] = sentinel , pids_exclude : Union [ List [ str ], object ] = sentinel , groups_ids : Union [ List [ int ], object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" )) async def persons ( self , id : int , pids : Union [ List [ str ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } /pids\" ), params = data ) async def add ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"pids\" ), json = data ) async def remove ( self , pids : List [ str ], groups_ids : List [ int ]) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data )","title":"Module neuroio.groups.v1"},{"location":"reference/neuroio/groups/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/groups/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/groups/v1/#groupsbase","text":"class GroupsBase ( / , * args , ** kwargs ) View Source class GroupsBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/groups/persons/{key}/\" else: return self . base_url + \"/v1/groups/persons/\"","title":"GroupsBase"},{"location":"reference/neuroio/groups/v1/#ancestors-in-mro","text":"neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/groups/v1/#descendants","text":"neuroio.groups.v1.Impl neuroio.groups.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/groups/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/groups/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/groups/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/groups/persons/{key}/\" else : return self . base_url + \"/v1/groups/persons/\"","title":"get_url"},{"location":"reference/neuroio/groups/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( APIBase , GroupsBase ) : def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}/pids\" ), params = data ) def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = self . get_url ( \"pids\" ), json = data ) def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data )","title":"Impl"},{"location":"reference/neuroio/groups/v1/#ancestors-in-mro_1","text":"neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.groups.v1.GroupsBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/groups/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/groups/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/groups/v1/#add","text":"def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . post ( url = self . get_url ( \"pids\" ), json = data )","title":"add"},{"location":"reference/neuroio/groups/v1/#create","text":"def create ( self , name : str ) -> httpx . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/groups/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/groups/v1/#get","text":"def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/groups/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/groups/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/groups/persons/{key}/\" else : return self . base_url + \"/v1/groups/persons/\"","title":"get_url"},{"location":"reference/neuroio/groups/v1/#list","text":"def list ( self , q : Union [ str , object ] = < object object at 0x10c207fb0 > , pids_include : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/groups/v1/#persons","text":"def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}/pids\" ), params = data )","title":"persons"},{"location":"reference/neuroio/groups/v1/#remove","text":"def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } with self . get_client () as client : return client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data )","title":"remove"},{"location":"reference/neuroio/groups/v1/#update","text":"def update ( self , id : int , name : str ) -> httpx . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/groups/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , GroupsBase ) : async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}/pids\" ), params = data ) async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"pids\" ), json = data ) async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data )","title":"ImplAsync"},{"location":"reference/neuroio/groups/v1/#ancestors-in-mro_2","text":"neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.groups.v1.GroupsBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/groups/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/groups/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/groups/v1/#add_1","text":"def add ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source async def add ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"pids\" ), json = data )","title":"add"},{"location":"reference/neuroio/groups/v1/#create_1","text":"def create ( self , name : str ) -> httpx . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/groups/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/groups/v1/#get_1","text":"def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/groups/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/groups/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/groups/persons/{key}/\" else : return self . base_url + \"/v1/groups/persons/\"","title":"get_url"},{"location":"reference/neuroio/groups/v1/#list_1","text":"def list ( self , q : Union [ str , object ] = < object object at 0x10c207fb0 > , pids_include : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , pids_exclude : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , groups_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , pids_include : Union [ List[str ] , object ] = sentinel , pids_exclude : Union [ List[str ] , object ] = sentinel , groups_ids : Union [ List[int ] , object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/groups/v1/#persons_1","text":"def persons ( self , id : int , pids : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def persons ( self , id : int , pids : Union [ List[str ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}/pids\" ), params = data )","title":"persons"},{"location":"reference/neuroio/groups/v1/#remove_1","text":"def remove ( self , pids : List [ str ], groups_ids : List [ int ] ) -> httpx . Response View Source async def remove ( self , pids : List [ str ] , groups_ids : List [ int ] ) -> Response : data = { \"pids\" : pids , \"groups_ids\" : groups_ids } async with self . get_client () as client : return await client . request ( \"DELETE\" , url = self . get_url ( \"pids\" ), json = data )","title":"remove"},{"location":"reference/neuroio/groups/v1/#update_1","text":"def update ( self , id : int , name : str ) -> httpx . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/licenses/","text":"Module neuroio.licenses None None Sub-modules neuroio.licenses.sources","title":"Index"},{"location":"reference/neuroio/licenses/#module-neuroiolicenses","text":"None None","title":"Module neuroio.licenses"},{"location":"reference/neuroio/licenses/#sub-modules","text":"neuroio.licenses.sources","title":"Sub-modules"},{"location":"reference/neuroio/licenses/sources/","text":"Module neuroio.licenses.sources None None Sub-modules neuroio.licenses.sources.v1","title":"Index"},{"location":"reference/neuroio/licenses/sources/#module-neuroiolicensessources","text":"None None","title":"Module neuroio.licenses.sources"},{"location":"reference/neuroio/licenses/sources/#sub-modules","text":"neuroio.licenses.sources.v1","title":"Sub-modules"},{"location":"reference/neuroio/licenses/sources/v1/","text":"Module neuroio.licenses.sources.v1 None None View Source from datetime import datetime from typing import Union from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase from neuroio.constants import sentinel from neuroio.utils import request_dict_processing , request_query_processing class LicensesBase ( IAMBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/licenses/sources/ { key } /\" else : return self . base_url + \"/v1/licenses/sources/\" class Impl ( IAMBase , LicensesBase ): def create ( self , name : str , entry_storage_days : int = 1 ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : str = \"\" , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , is_bound : Union [ bool , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) class ImplAsync ( IAMBaseAsync , LicensesBase ): async def create ( self , name : str , entry_storage_days : int = 1 ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : str = \"\" , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , is_bound : Union [ bool , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) Variables sentinel Classes Impl class Impl ( settings : dict ) View Source class Impl ( IAMBase , LicensesBase ): def create ( self , name: str , entry_storage_days: int = 1 ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . post ( url = self . get_url (), json = data ) def list ( self , q: str = \"\", date_from: Union[datetime, object] = sentinel , date_to: Union [ datetime , object ] = sentinel , is_bound: Union [ bool , object ] = sentinel , limit: int = 20 , offset: int = 0 , ) -> Response: data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . get ( url = self . get_url (), params = data ) def get ( self , id: str ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id: int , name: str , is_active: bool = True , entry_storage_days: int = 1 , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client: return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) Ancestors (in MRO) neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.licenses.sources.v1.LicensesBase neuroio.base.IAMBaseBase Class variables base_url Methods create def create ( self , name : str , entry_storage_days : int = 1 ) -> httpx . Response View Source def create ( self , name : str , entry_storage_days : int = 1 ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) get def get ( self , id : str ) -> httpx . Response View Source def get ( self , id : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/licenses/sources/{key}/\" else : return self . base_url + \"/v1/licenses/sources/\" list def list ( self , q : str = '' , date_from : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , is_bound : Union [ bool , object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = \"\" , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , is_bound : Union [ bool , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) update def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 ) -> httpx . Response View Source def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , LicensesBase ): async def create ( self , name: str , entry_storage_days: int = 1 ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . post ( url = self . get_url (), json = data ) async def list ( self , q: str = \"\", date_from: Union[datetime, object] = sentinel , date_to: Union [ datetime , object ] = sentinel , is_bound: Union [ bool , object ] = sentinel , limit: int = 20 , offset: int = 0 , ) -> Response: data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . get ( url = self . get_url (), params = data ) async def get ( self , id: int ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id: int , name: str , is_active: bool = True , entry_storage_days: int = 1 , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client: return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) Ancestors (in MRO) neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.licenses.sources.v1.LicensesBase neuroio.base.IAMBaseBase Class variables base_url Methods create def create ( self , name : str , entry_storage_days : int = 1 ) -> httpx . Response View Source async def create ( self , name : str , entry_storage_days : int = 1 ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) get def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/licenses/sources/{key}/\" else : return self . base_url + \"/v1/licenses/sources/\" list def list ( self , q : str = '' , date_from : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , is_bound : Union [ bool , object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = \"\" , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , is_bound : Union [ bool , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) update def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 ) -> httpx . Response View Source async def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) LicensesBase class LicensesBase ( / , * args , ** kwargs ) View Source class LicensesBase ( IAMBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/licenses/sources/{key}/\" else: return self . base_url + \"/v1/licenses/sources/\" Ancestors (in MRO) neuroio.base.IAMBaseBase Descendants neuroio.licenses.sources.v1.Impl neuroio.licenses.sources.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/licenses/sources/{key}/\" else : return self . base_url + \"/v1/licenses/sources/\"","title":"V1"},{"location":"reference/neuroio/licenses/sources/v1/#module-neuroiolicensessourcesv1","text":"None None View Source from datetime import datetime from typing import Union from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase from neuroio.constants import sentinel from neuroio.utils import request_dict_processing , request_query_processing class LicensesBase ( IAMBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/licenses/sources/ { key } /\" else : return self . base_url + \"/v1/licenses/sources/\" class Impl ( IAMBase , LicensesBase ): def create ( self , name : str , entry_storage_days : int = 1 ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : str = \"\" , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , is_bound : Union [ bool , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) class ImplAsync ( IAMBaseAsync , LicensesBase ): async def create ( self , name : str , entry_storage_days : int = 1 ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : str = \"\" , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , is_bound : Union [ bool , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data )","title":"Module neuroio.licenses.sources.v1"},{"location":"reference/neuroio/licenses/sources/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/licenses/sources/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/licenses/sources/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( IAMBase , LicensesBase ): def create ( self , name: str , entry_storage_days: int = 1 ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . post ( url = self . get_url (), json = data ) def list ( self , q: str = \"\", date_from: Union[datetime, object] = sentinel , date_to: Union [ datetime , object ] = sentinel , is_bound: Union [ bool , object ] = sentinel , limit: int = 20 , offset: int = 0 , ) -> Response: data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . get ( url = self . get_url (), params = data ) def get ( self , id: str ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id: int , name: str , is_active: bool = True , entry_storage_days: int = 1 , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client: return client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"Impl"},{"location":"reference/neuroio/licenses/sources/v1/#ancestors-in-mro","text":"neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.licenses.sources.v1.LicensesBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/licenses/sources/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/licenses/sources/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/licenses/sources/v1/#create","text":"def create ( self , name : str , entry_storage_days : int = 1 ) -> httpx . Response View Source def create ( self , name : str , entry_storage_days : int = 1 ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/licenses/sources/v1/#get","text":"def get ( self , id : str ) -> httpx . Response View Source def get ( self , id : str ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/licenses/sources/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/licenses/sources/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/licenses/sources/{key}/\" else : return self . base_url + \"/v1/licenses/sources/\"","title":"get_url"},{"location":"reference/neuroio/licenses/sources/v1/#list","text":"def list ( self , q : str = '' , date_from : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , is_bound : Union [ bool , object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = \"\" , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , is_bound : Union [ bool , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/licenses/sources/v1/#update","text":"def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 ) -> httpx . Response View Source def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/licenses/sources/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , LicensesBase ): async def create ( self , name: str , entry_storage_days: int = 1 ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . post ( url = self . get_url (), json = data ) async def list ( self , q: str = \"\", date_from: Union[datetime, object] = sentinel , date_to: Union [ datetime , object ] = sentinel , is_bound: Union [ bool , object ] = sentinel , limit: int = 20 , offset: int = 0 , ) -> Response: data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . get ( url = self . get_url (), params = data ) async def get ( self , id: int ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id: int , name: str , is_active: bool = True , entry_storage_days: int = 1 , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client: return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"ImplAsync"},{"location":"reference/neuroio/licenses/sources/v1/#ancestors-in-mro_1","text":"neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.licenses.sources.v1.LicensesBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/licenses/sources/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/licenses/sources/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/licenses/sources/v1/#create_1","text":"def create ( self , name : str , entry_storage_days : int = 1 ) -> httpx . Response View Source async def create ( self , name : str , entry_storage_days : int = 1 ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/licenses/sources/v1/#get_1","text":"def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/licenses/sources/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/licenses/sources/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/licenses/sources/{key}/\" else : return self . base_url + \"/v1/licenses/sources/\"","title":"get_url"},{"location":"reference/neuroio/licenses/sources/v1/#list_1","text":"def list ( self , q : str = '' , date_from : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , date_to : Union [ datetime . datetime , object ] = < object object at 0x10c207fb0 > , is_bound : Union [ bool , object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = \"\" , date_from : Union [ datetime , object ] = sentinel , date_to : Union [ datetime , object ] = sentinel , is_bound : Union [ bool , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/licenses/sources/v1/#update_1","text":"def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 ) -> httpx . Response View Source async def update ( self , id : int , name : str , is_active : bool = True , entry_storage_days : int = 1 , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/licenses/sources/v1/#licensesbase","text":"class LicensesBase ( / , * args , ** kwargs ) View Source class LicensesBase ( IAMBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/licenses/sources/{key}/\" else: return self . base_url + \"/v1/licenses/sources/\"","title":"LicensesBase"},{"location":"reference/neuroio/licenses/sources/v1/#ancestors-in-mro_2","text":"neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/licenses/sources/v1/#descendants","text":"neuroio.licenses.sources.v1.Impl neuroio.licenses.sources.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/licenses/sources/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/licenses/sources/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/licenses/sources/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/licenses/sources/{key}/\" else : return self . base_url + \"/v1/licenses/sources/\"","title":"get_url"},{"location":"reference/neuroio/lists/","text":"Module neuroio.lists None None Sub-modules neuroio.lists.spaces","title":"Index"},{"location":"reference/neuroio/lists/#module-neuroiolists","text":"None None","title":"Module neuroio.lists"},{"location":"reference/neuroio/lists/#sub-modules","text":"neuroio.lists.spaces","title":"Sub-modules"},{"location":"reference/neuroio/lists/spaces/","text":"Module neuroio.lists.spaces None None Sub-modules neuroio.lists.spaces.v1","title":"Index"},{"location":"reference/neuroio/lists/spaces/#module-neuroiolistsspaces","text":"None None","title":"Module neuroio.lists.spaces"},{"location":"reference/neuroio/lists/spaces/#sub-modules","text":"neuroio.lists.spaces.v1","title":"Sub-modules"},{"location":"reference/neuroio/lists/spaces/v1/","text":"Module neuroio.lists.spaces.v1 None None View Source from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class ListsSpacesBase ( IAMBaseBase ): def get_url ( self ) -> str : return self . base_url + \"/v1/lists/spaces/\" class Impl ( IAMBase , ListsSpacesBase ): def all ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ()) class ImplAsync ( IAMBaseAsync , ListsSpacesBase ): async def all ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ()) Classes Impl class Impl ( settings : dict ) View Source class Impl ( IAMBase , ListsSpacesBase ): def all ( self ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ()) Ancestors (in MRO) neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.lists.spaces.v1.ListsSpacesBase neuroio.base.IAMBaseBase Class variables base_url Methods all def all ( self ) -> httpx . Response View Source def all ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ()) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/lists/spaces/\" ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , ListsSpacesBase ): async def all ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ()) Ancestors (in MRO) neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.lists.spaces.v1.ListsSpacesBase neuroio.base.IAMBaseBase Class variables base_url Methods all def all ( self ) -> httpx . Response View Source async def all ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ()) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/lists/spaces/\" ListsSpacesBase class ListsSpacesBase ( / , * args , ** kwargs ) View Source class ListsSpacesBase ( IAMBaseBase ): def get_url ( self ) -> str: return self . base_url + \"/v1/lists/spaces/\" Ancestors (in MRO) neuroio.base.IAMBaseBase Descendants neuroio.lists.spaces.v1.Impl neuroio.lists.spaces.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/lists/spaces/\"","title":"V1"},{"location":"reference/neuroio/lists/spaces/v1/#module-neuroiolistsspacesv1","text":"None None View Source from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class ListsSpacesBase ( IAMBaseBase ): def get_url ( self ) -> str : return self . base_url + \"/v1/lists/spaces/\" class Impl ( IAMBase , ListsSpacesBase ): def all ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ()) class ImplAsync ( IAMBaseAsync , ListsSpacesBase ): async def all ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ())","title":"Module neuroio.lists.spaces.v1"},{"location":"reference/neuroio/lists/spaces/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/lists/spaces/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( IAMBase , ListsSpacesBase ): def all ( self ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ())","title":"Impl"},{"location":"reference/neuroio/lists/spaces/v1/#ancestors-in-mro","text":"neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.lists.spaces.v1.ListsSpacesBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/lists/spaces/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/lists/spaces/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/lists/spaces/v1/#all","text":"def all ( self ) -> httpx . Response View Source def all ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ())","title":"all"},{"location":"reference/neuroio/lists/spaces/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/lists/spaces/v1/#get_url","text":"def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/lists/spaces/\"","title":"get_url"},{"location":"reference/neuroio/lists/spaces/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , ListsSpacesBase ): async def all ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ())","title":"ImplAsync"},{"location":"reference/neuroio/lists/spaces/v1/#ancestors-in-mro_1","text":"neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.lists.spaces.v1.ListsSpacesBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/lists/spaces/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/lists/spaces/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/lists/spaces/v1/#all_1","text":"def all ( self ) -> httpx . Response View Source async def all ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ())","title":"all"},{"location":"reference/neuroio/lists/spaces/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/lists/spaces/v1/#get_url_1","text":"def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/lists/spaces/\"","title":"get_url"},{"location":"reference/neuroio/lists/spaces/v1/#listsspacesbase","text":"class ListsSpacesBase ( / , * args , ** kwargs ) View Source class ListsSpacesBase ( IAMBaseBase ): def get_url ( self ) -> str: return self . base_url + \"/v1/lists/spaces/\"","title":"ListsSpacesBase"},{"location":"reference/neuroio/lists/spaces/v1/#ancestors-in-mro_2","text":"neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/lists/spaces/v1/#descendants","text":"neuroio.lists.spaces.v1.Impl neuroio.lists.spaces.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/lists/spaces/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/lists/spaces/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/lists/spaces/v1/#get_url_2","text":"def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/lists/spaces/\"","title":"get_url"},{"location":"reference/neuroio/notifications/","text":"Module neuroio.notifications None None Sub-modules neuroio.notifications.v1","title":"Index"},{"location":"reference/neuroio/notifications/#module-neuroionotifications","text":"None None","title":"Module neuroio.notifications"},{"location":"reference/neuroio/notifications/#sub-modules","text":"neuroio.notifications.v1","title":"Sub-modules"},{"location":"reference/neuroio/notifications/v1/","text":"Module neuroio.notifications.v1 None None View Source from typing import List , Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , sentinel , ) from neuroio.utils import request_dict_processing , request_query_processing class NotificationsBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/notifications/ { key } /\" else : return self . base_url + \"/v1/notifications/\" class Impl ( APIBase , NotificationsBase ): def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) class ImplAsync ( APIBaseAsync , NotificationsBase ): async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" )) Variables sentinel Classes Impl class Impl ( settings : dict ) View Source class Impl ( APIBase , NotificationsBase ) : def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) Ancestors (in MRO) neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.notifications.v1.NotificationsBase neuroio.base.APIBaseBase Class variables base_url Methods create def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10c207fb0 > , sources : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/notifications/{key}/\" else : return self . base_url + \"/v1/notifications/\" list def list ( self , q : Union [ str , object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) update def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10c207fb0 > , sources : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , NotificationsBase ) : async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) Ancestors (in MRO) neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.notifications.v1.NotificationsBase neuroio.base.APIBaseBase Class variables base_url Methods create def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10c207fb0 > , sources : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/notifications/{key}/\" else : return self . base_url + \"/v1/notifications/\" list def list ( self , q : Union [ str , object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) update def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10c207fb0 > , sources : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) NotificationsBase class NotificationsBase ( / , * args , ** kwargs ) View Source class NotificationsBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/notifications/{key}/\" else: return self . base_url + \"/v1/notifications/\" Ancestors (in MRO) neuroio.base.APIBaseBase Descendants neuroio.notifications.v1.Impl neuroio.notifications.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/notifications/{key}/\" else : return self . base_url + \"/v1/notifications/\"","title":"V1"},{"location":"reference/neuroio/notifications/v1/#module-neuroionotificationsv1","text":"None None View Source from typing import List , Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import ( EntryLiveness , EntryMood , EntryResult , HttpMethod , Sex , sentinel , ) from neuroio.utils import request_dict_processing , request_query_processing class NotificationsBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/notifications/ { key } /\" else : return self . base_url + \"/v1/notifications/\" class Impl ( APIBase , NotificationsBase ): def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) class ImplAsync ( APIBaseAsync , NotificationsBase ): async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : Union [ str , object ] = sentinel , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ EntryMood ], object ] = sentinel , results : Union [ List [ EntryResult ], object ] = sentinel , liveness : Union [ List [ EntryLiveness ], object ] = sentinel , age_from : Union [ int , object ] = sentinel , age_to : Union [ int , object ] = sentinel , sex : Union [ List [ Sex ], object ] = sentinel , sources : Union [ List [ int ], object ] = sentinel , persons_groups : Union [ List [ int ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" , \"id\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" ))","title":"Module neuroio.notifications.v1"},{"location":"reference/neuroio/notifications/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/notifications/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/notifications/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( APIBase , NotificationsBase ) : def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" ))","title":"Impl"},{"location":"reference/neuroio/notifications/v1/#ancestors-in-mro","text":"neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.notifications.v1.NotificationsBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/notifications/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/notifications/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/notifications/v1/#create","text":"def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10c207fb0 > , sources : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/notifications/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/notifications/v1/#get","text":"def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/notifications/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/notifications/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/notifications/{key}/\" else : return self . base_url + \"/v1/notifications/\"","title":"get_url"},{"location":"reference/neuroio/notifications/v1/#list","text":"def list ( self , q : Union [ str , object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/notifications/v1/#update","text":"def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10c207fb0 > , sources : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/notifications/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , NotificationsBase ) : async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" ))","title":"ImplAsync"},{"location":"reference/neuroio/notifications/v1/#ancestors-in-mro_1","text":"neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.notifications.v1.NotificationsBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/notifications/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/notifications/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/notifications/v1/#create_1","text":"def create ( self , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10c207fb0 > , sources : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def create ( self , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/notifications/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/notifications/v1/#get_1","text":"def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/notifications/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/notifications/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/notifications/{key}/\" else : return self . base_url + \"/v1/notifications/\"","title":"get_url"},{"location":"reference/neuroio/notifications/v1/#list_1","text":"def list ( self , q : Union [ str , object ] = < object object at 0x10c207fb0 > , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : Union [ str, object ] = sentinel , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/notifications/v1/#update_1","text":"def update ( self , id : int , name : str , http_method : neuroio . constants . HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List [ neuroio . constants . EntryMood ], object ] = < object object at 0x10c207fb0 > , results : Union [ List [ neuroio . constants . EntryResult ], object ] = < object object at 0x10c207fb0 > , liveness : Union [ List [ neuroio . constants . EntryLiveness ], object ] = < object object at 0x10c207fb0 > , age_from : Union [ int , object ] = < object object at 0x10c207fb0 > , age_to : Union [ int , object ] = < object object at 0x10c207fb0 > , sex : Union [ List [ neuroio . constants . Sex ], object ] = < object object at 0x10c207fb0 > , sources : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , persons_groups : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def update ( self , id : int , name : str , http_method : HttpMethod , destination_url : str , is_active : bool = True , moods : Union [ List[EntryMood ] , object ] = sentinel , results : Union [ List[EntryResult ] , object ] = sentinel , liveness : Union [ List[EntryLiveness ] , object ] = sentinel , age_from : Union [ int, object ] = sentinel , age_to : Union [ int, object ] = sentinel , sex : Union [ List[Sex ] , object ] = sentinel , sources : Union [ List[int ] , object ] = sentinel , persons_groups : Union [ List[int ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\", \"id\" ] ) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/notifications/v1/#notificationsbase","text":"class NotificationsBase ( / , * args , ** kwargs ) View Source class NotificationsBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/notifications/{key}/\" else: return self . base_url + \"/v1/notifications/\"","title":"NotificationsBase"},{"location":"reference/neuroio/notifications/v1/#ancestors-in-mro_2","text":"neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/notifications/v1/#descendants","text":"neuroio.notifications.v1.Impl neuroio.notifications.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/notifications/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/notifications/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/notifications/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/notifications/{key}/\" else : return self . base_url + \"/v1/notifications/\"","title":"get_url"},{"location":"reference/neuroio/persons/","text":"Module neuroio.persons None None Sub-modules neuroio.persons.v1","title":"Index"},{"location":"reference/neuroio/persons/#module-neuroiopersons","text":"None None","title":"Module neuroio.persons"},{"location":"reference/neuroio/persons/#sub-modules","text":"neuroio.persons.v1","title":"Sub-modules"},{"location":"reference/neuroio/persons/v1/","text":"Module neuroio.persons.v1 None None View Source from typing import Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import EntryResult , sentinel from neuroio.utils import ( ImageType , prepare_image_processing , request_dict_processing , request_form_processing , ) class PersonsBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/persons/ { key } /\" else : return self . base_url + \"/v1/persons/\" class Impl ( APIBase , PersonsBase ): def create ( self , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) with self . get_client () as client : return client . post ( url = self . get_url (), data = data , files = files ) def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url ( \"entry\" ), json = data ) def reinit ( self , id : int ) -> Response : with self . get_client () as client : return client . post ( url = self . get_url ( \"reinit\" ), json = { \"id\" : id }) def reinit_by_photo ( self , pid : str , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals ()) files = prepare_image_processing ( image ) with self . get_client () as client : return client . post ( url = self . get_url ( f \"reinit/ { pid } \" ), data = data , files = files ) def search ( self , image : ImageType , identify_asm : bool = False , ) -> Response : files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client : return client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) def delete ( self , pid : str ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { pid } \" )) class ImplAsync ( APIBaseAsync , PersonsBase ): async def create ( self , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client : return await client . post ( url = self . get_url (), data = data , files = files ) async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url ( \"entry\" ), json = data ) async def reinit ( self , id : int ) -> Response : async with self . get_client () as client : return await client . post ( url = self . get_url ( \"reinit\" ), json = { \"id\" : id } ) async def reinit_by_photo ( self , pid : str , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client : return await client . post ( url = self . get_url ( f \"reinit/ { pid } \" ), data = data , files = files ) async def search ( self , image : ImageType , identify_asm : bool = False , ) -> Response : files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client : return await client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) async def delete ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { pid } \" )) Variables sentinel Classes Impl class Impl ( settings : dict ) View Source class Impl ( APIBase , PersonsBase ): def create ( self , image: ImageType , source: str , facesize: Union [ int , object ] = sentinel , create_on_ha: Union [ bool , object ] = sentinel , create_on_junk: Union [ bool , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) with self . get_client () as client: return client . post ( url = self . get_url (), data = data , files = files ) def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . post ( url = self . get_url ( \"entry\" ), json = data ) def reinit ( self , id: int ) -> Response: with self . get_client () as client: return client . post ( url = self . get_url ( \"reinit\" ), json ={ \"id\" : id }) def reinit_by_photo ( self , pid: str , image: ImageType , source: str , facesize: Union [ int , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , result: str = EntryResult . HA , ) -> Response: data = request_form_processing ( locals ()) files = prepare_image_processing ( image ) with self . get_client () as client: return client . post ( url = self . get_url ( f \"reinit/{pid}\" ), data = data , files = files ) def search ( self , image: ImageType , identify_asm: bool = False , ) -> Response: files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client: return client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) def delete ( self , pid: str ) -> Response: with self . get_client () as client: return client . delete ( url = self . get_url ( f \"{pid}\" )) Ancestors (in MRO) neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.persons.v1.PersonsBase neuroio.base.APIBaseBase Class variables base_url Methods create def create ( self , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], source : str , facesize : Union [ int , object ] = < object object at 0x10c207fb0 > , create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def create ( self , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) with self . get_client () as client : return client . post ( url = self . get_url (), data = data , files = files ) create_by_entry def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . Response View Source def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url ( \"entry\" ), json = data ) delete def delete ( self , pid : str ) -> httpx . Response View Source def delete ( self , pid : str ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{pid}\" )) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/persons/{key}/\" else : return self . base_url + \"/v1/persons/\" reinit def reinit ( self , id : int ) -> httpx . Response View Source def reinit ( self , id : int ) -> Response : with self . get_client () as client : return client . post ( url = self . get_url ( \"reinit\" ), json = { \"id\" : id }) reinit_by_photo def reinit_by_photo ( self , pid : str , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], source : str , facesize : Union [ int , object ] = < object object at 0x10c207fb0 > , identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source def reinit_by_photo ( self , pid : str , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals ()) files = prepare_image_processing ( image ) with self . get_client () as client : return client . post ( url = self . get_url ( f \"reinit/{pid}\" ), data = data , files = files ) search def search ( self , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], identify_asm : bool = False ) -> httpx . Response View Source def search ( self , image : ImageType , identify_asm : bool = False , ) -> Response : files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client : return client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , PersonsBase ): async def create ( self , image: ImageType , source: str , facesize: Union [ int , object ] = sentinel , create_on_ha: Union [ bool , object ] = sentinel , create_on_junk: Union [ bool , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client: return await client . post ( url = self . get_url (), data = data , files = files ) async def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . post ( url = self . get_url ( \"entry\" ), json = data ) async def reinit ( self , id: int ) -> Response: async with self . get_client () as client: return await client . post ( url = self . get_url ( \"reinit\" ), json ={ \"id\" : id } ) async def reinit_by_photo ( self , pid: str , image: ImageType , source: str , facesize: Union [ int , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , result: str = EntryResult . HA , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client: return await client . post ( url = self . get_url ( f \"reinit/{pid}\" ), data = data , files = files ) async def search ( self , image: ImageType , identify_asm: bool = False , ) -> Response: files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client: return await client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) async def delete ( self , pid: str ) -> Response: async with self . get_client () as client: return await client . delete ( url = self . get_url ( f \"{pid}\" )) Ancestors (in MRO) neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.persons.v1.PersonsBase neuroio.base.APIBaseBase Class variables base_url Methods create def create ( self , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], source : str , facesize : Union [ int , object ] = < object object at 0x10c207fb0 > , create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def create ( self , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client : return await client . post ( url = self . get_url (), data = data , files = files ) create_by_entry def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . Response View Source async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url ( \"entry\" ), json = data ) delete def delete ( self , pid : str ) -> httpx . Response View Source async def delete ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{pid}\" )) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/persons/{key}/\" else : return self . base_url + \"/v1/persons/\" reinit def reinit ( self , id : int ) -> httpx . Response View Source async def reinit ( self , id : int ) -> Response : async with self . get_client () as client : return await client . post ( url = self . get_url ( \"reinit\" ), json = { \"id\" : id } ) reinit_by_photo def reinit_by_photo ( self , pid : str , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], source : str , facesize : Union [ int , object ] = < object object at 0x10c207fb0 > , identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source async def reinit_by_photo ( self , pid : str , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client : return await client . post ( url = self . get_url ( f \"reinit/{pid}\" ), data = data , files = files ) search def search ( self , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], identify_asm : bool = False ) -> httpx . Response View Source async def search ( self , image : ImageType , identify_asm : bool = False , ) -> Response : files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client : return await client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) PersonsBase class PersonsBase ( / , * args , ** kwargs ) View Source class PersonsBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/persons/{key}/\" else: return self . base_url + \"/v1/persons/\" Ancestors (in MRO) neuroio.base.APIBaseBase Descendants neuroio.persons.v1.Impl neuroio.persons.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/persons/{key}/\" else : return self . base_url + \"/v1/persons/\"","title":"V1"},{"location":"reference/neuroio/persons/v1/#module-neuroiopersonsv1","text":"None None View Source from typing import Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import EntryResult , sentinel from neuroio.utils import ( ImageType , prepare_image_processing , request_dict_processing , request_form_processing , ) class PersonsBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/persons/ { key } /\" else : return self . base_url + \"/v1/persons/\" class Impl ( APIBase , PersonsBase ): def create ( self , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) with self . get_client () as client : return client . post ( url = self . get_url (), data = data , files = files ) def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url ( \"entry\" ), json = data ) def reinit ( self , id : int ) -> Response : with self . get_client () as client : return client . post ( url = self . get_url ( \"reinit\" ), json = { \"id\" : id }) def reinit_by_photo ( self , pid : str , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals ()) files = prepare_image_processing ( image ) with self . get_client () as client : return client . post ( url = self . get_url ( f \"reinit/ { pid } \" ), data = data , files = files ) def search ( self , image : ImageType , identify_asm : bool = False , ) -> Response : files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client : return client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) def delete ( self , pid : str ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { pid } \" )) class ImplAsync ( APIBaseAsync , PersonsBase ): async def create ( self , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client : return await client . post ( url = self . get_url (), data = data , files = files ) async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url ( \"entry\" ), json = data ) async def reinit ( self , id : int ) -> Response : async with self . get_client () as client : return await client . post ( url = self . get_url ( \"reinit\" ), json = { \"id\" : id } ) async def reinit_by_photo ( self , pid : str , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client : return await client . post ( url = self . get_url ( f \"reinit/ { pid } \" ), data = data , files = files ) async def search ( self , image : ImageType , identify_asm : bool = False , ) -> Response : files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client : return await client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) async def delete ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { pid } \" ))","title":"Module neuroio.persons.v1"},{"location":"reference/neuroio/persons/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/persons/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/persons/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( APIBase , PersonsBase ): def create ( self , image: ImageType , source: str , facesize: Union [ int , object ] = sentinel , create_on_ha: Union [ bool , object ] = sentinel , create_on_junk: Union [ bool , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) with self . get_client () as client: return client . post ( url = self . get_url (), data = data , files = files ) def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . post ( url = self . get_url ( \"entry\" ), json = data ) def reinit ( self , id: int ) -> Response: with self . get_client () as client: return client . post ( url = self . get_url ( \"reinit\" ), json ={ \"id\" : id }) def reinit_by_photo ( self , pid: str , image: ImageType , source: str , facesize: Union [ int , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , result: str = EntryResult . HA , ) -> Response: data = request_form_processing ( locals ()) files = prepare_image_processing ( image ) with self . get_client () as client: return client . post ( url = self . get_url ( f \"reinit/{pid}\" ), data = data , files = files ) def search ( self , image: ImageType , identify_asm: bool = False , ) -> Response: files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client: return client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) def delete ( self , pid: str ) -> Response: with self . get_client () as client: return client . delete ( url = self . get_url ( f \"{pid}\" ))","title":"Impl"},{"location":"reference/neuroio/persons/v1/#ancestors-in-mro","text":"neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.persons.v1.PersonsBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/persons/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/persons/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/persons/v1/#create","text":"def create ( self , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], source : str , facesize : Union [ int , object ] = < object object at 0x10c207fb0 > , create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def create ( self , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) with self . get_client () as client : return client . post ( url = self . get_url (), data = data , files = files )","title":"create"},{"location":"reference/neuroio/persons/v1/#create_by_entry","text":"def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . Response View Source def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url ( \"entry\" ), json = data )","title":"create_by_entry"},{"location":"reference/neuroio/persons/v1/#delete","text":"def delete ( self , pid : str ) -> httpx . Response View Source def delete ( self , pid : str ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{pid}\" ))","title":"delete"},{"location":"reference/neuroio/persons/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/persons/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/persons/{key}/\" else : return self . base_url + \"/v1/persons/\"","title":"get_url"},{"location":"reference/neuroio/persons/v1/#reinit","text":"def reinit ( self , id : int ) -> httpx . Response View Source def reinit ( self , id : int ) -> Response : with self . get_client () as client : return client . post ( url = self . get_url ( \"reinit\" ), json = { \"id\" : id })","title":"reinit"},{"location":"reference/neuroio/persons/v1/#reinit_by_photo","text":"def reinit_by_photo ( self , pid : str , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], source : str , facesize : Union [ int , object ] = < object object at 0x10c207fb0 > , identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source def reinit_by_photo ( self , pid : str , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals ()) files = prepare_image_processing ( image ) with self . get_client () as client : return client . post ( url = self . get_url ( f \"reinit/{pid}\" ), data = data , files = files )","title":"reinit_by_photo"},{"location":"reference/neuroio/persons/v1/#search","text":"def search ( self , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], identify_asm : bool = False ) -> httpx . Response View Source def search ( self , image : ImageType , identify_asm : bool = False , ) -> Response : files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} with self . get_client () as client : return client . post ( url = self . get_url ( \"search\" ), data = data , files = files )","title":"search"},{"location":"reference/neuroio/persons/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , PersonsBase ): async def create ( self , image: ImageType , source: str , facesize: Union [ int , object ] = sentinel , create_on_ha: Union [ bool , object ] = sentinel , create_on_junk: Union [ bool , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client: return await client . post ( url = self . get_url (), data = data , files = files ) async def create_by_entry ( self , id: int , create_on_ha: bool , create_on_junk: bool ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . post ( url = self . get_url ( \"entry\" ), json = data ) async def reinit ( self , id: int ) -> Response: async with self . get_client () as client: return await client . post ( url = self . get_url ( \"reinit\" ), json ={ \"id\" : id } ) async def reinit_by_photo ( self , pid: str , image: ImageType , source: str , facesize: Union [ int , object ] = sentinel , identify_asm: Union [ bool , object ] = sentinel , result: str = EntryResult . HA , ) -> Response: data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client: return await client . post ( url = self . get_url ( f \"reinit/{pid}\" ), data = data , files = files ) async def search ( self , image: ImageType , identify_asm: bool = False , ) -> Response: files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client: return await client . post ( url = self . get_url ( \"search\" ), data = data , files = files ) async def delete ( self , pid: str ) -> Response: async with self . get_client () as client: return await client . delete ( url = self . get_url ( f \"{pid}\" ))","title":"ImplAsync"},{"location":"reference/neuroio/persons/v1/#ancestors-in-mro_1","text":"neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.persons.v1.PersonsBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/persons/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/persons/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/persons/v1/#create_1","text":"def create ( self , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], source : str , facesize : Union [ int , object ] = < object object at 0x10c207fb0 > , create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def create ( self , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , create_on_ha : Union [ bool , object ] = sentinel , create_on_junk : Union [ bool , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client : return await client . post ( url = self . get_url (), data = data , files = files )","title":"create"},{"location":"reference/neuroio/persons/v1/#create_by_entry_1","text":"def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> httpx . Response View Source async def create_by_entry ( self , id : int , create_on_ha : bool , create_on_junk : bool ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url ( \"entry\" ), json = data )","title":"create_by_entry"},{"location":"reference/neuroio/persons/v1/#delete_1","text":"def delete ( self , pid : str ) -> httpx . Response View Source async def delete ( self , pid : str ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{pid}\" ))","title":"delete"},{"location":"reference/neuroio/persons/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/persons/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/persons/{key}/\" else : return self . base_url + \"/v1/persons/\"","title":"get_url"},{"location":"reference/neuroio/persons/v1/#reinit_1","text":"def reinit ( self , id : int ) -> httpx . Response View Source async def reinit ( self , id : int ) -> Response : async with self . get_client () as client : return await client . post ( url = self . get_url ( \"reinit\" ), json = { \"id\" : id } )","title":"reinit"},{"location":"reference/neuroio/persons/v1/#reinit_by_photo_1","text":"def reinit_by_photo ( self , pid : str , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], source : str , facesize : Union [ int , object ] = < object object at 0x10c207fb0 > , identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source async def reinit_by_photo ( self , pid : str , image : ImageType , source : str , facesize : Union [ int , object ] = sentinel , identify_asm : Union [ bool , object ] = sentinel , result : str = EntryResult . HA , ) -> Response : data = request_form_processing ( locals (), [ \"self\" , \"image\" , \"pid\" ]) files = prepare_image_processing ( image ) async with self . get_client () as client : return await client . post ( url = self . get_url ( f \"reinit/{pid}\" ), data = data , files = files )","title":"reinit_by_photo"},{"location":"reference/neuroio/persons/v1/#search_1","text":"def search ( self , image : Union [ BinaryIO , Tuple [ str , _io . BytesIO ], bytes ], identify_asm : bool = False ) -> httpx . Response View Source async def search ( self , image : ImageType , identify_asm : bool = False , ) -> Response : files = prepare_image_processing ( image ) data = { \"identify_asm\" : str ( identify_asm )} async with self . get_client () as client : return await client . post ( url = self . get_url ( \"search\" ), data = data , files = files )","title":"search"},{"location":"reference/neuroio/persons/v1/#personsbase","text":"class PersonsBase ( / , * args , ** kwargs ) View Source class PersonsBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/persons/{key}/\" else: return self . base_url + \"/v1/persons/\"","title":"PersonsBase"},{"location":"reference/neuroio/persons/v1/#ancestors-in-mro_2","text":"neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/persons/v1/#descendants","text":"neuroio.persons.v1.Impl neuroio.persons.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/persons/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/persons/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/persons/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/persons/{key}/\" else : return self . base_url + \"/v1/persons/\"","title":"get_url"},{"location":"reference/neuroio/settings/","text":"Module neuroio.settings None None Sub-modules neuroio.settings.v1","title":"Index"},{"location":"reference/neuroio/settings/#module-neuroiosettings","text":"None None","title":"Module neuroio.settings"},{"location":"reference/neuroio/settings/#sub-modules","text":"neuroio.settings.v1","title":"Sub-modules"},{"location":"reference/neuroio/settings/v1/","text":"Module neuroio.settings.v1 None None View Source from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import ( DEFAULT_EXACT_THRESHOLD , DEFAULT_HA_THRESHOLD , DEFAULT_JUNK_THRESHOLD , ) from neuroio.utils import request_dict_processing class SettingsBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/settings/thresholds/ { key } /\" else : return self . base_url + \"/v1/settings/thresholds/\" class Impl ( APIBase , SettingsBase ): def get ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ()) def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . patch ( url = self . get_url (), data = data ) def reset ( self ) -> Response : with self . get_client () as client : return client . post ( url = self . get_url ( \"reset\" )) class ImplAsync ( APIBaseAsync , SettingsBase ): async def get ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ()) async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url (), data = data ) async def reset ( self ) -> Response : async with self . get_client () as client : return await client . post ( url = self . get_url ( \"reset\" )) Variables DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD Classes Impl class Impl ( settings : dict ) View Source class Impl ( APIBase , SettingsBase ): def get ( self ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ()) def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . patch ( url = self . get_url (), data = data ) def reset ( self ) -> Response: with self . get_client () as client: return client . post ( url = self . get_url ( \"reset\" )) Ancestors (in MRO) neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.settings.v1.SettingsBase neuroio.base.APIBaseBase Class variables base_url Methods get def get ( self ) -> httpx . Response View Source def get ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ()) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/settings/thresholds/{key}/\" else : return self . base_url + \"/v1/settings/thresholds/\" reset def reset ( self ) -> httpx . Response View Source def reset ( self ) -> Response : with self . get_client () as client : return client . post ( url = self . get_url ( \"reset\" )) update def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . Response View Source def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . patch ( url = self . get_url (), data = data ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , SettingsBase ): async def get ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ()) async def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . patch ( url = self . get_url (), data = data ) async def reset ( self ) -> Response: async with self . get_client () as client: return await client . post ( url = self . get_url ( \"reset\" )) Ancestors (in MRO) neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.settings.v1.SettingsBase neuroio.base.APIBaseBase Class variables base_url Methods get def get ( self ) -> httpx . Response View Source async def get ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ()) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/settings/thresholds/{key}/\" else : return self . base_url + \"/v1/settings/thresholds/\" reset def reset ( self ) -> httpx . Response View Source async def reset ( self ) -> Response : async with self . get_client () as client : return await client . post ( url = self . get_url ( \"reset\" )) update def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . Response View Source async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url (), data = data ) SettingsBase class SettingsBase ( / , * args , ** kwargs ) View Source class SettingsBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/settings/thresholds/{key}/\" else: return self . base_url + \"/v1/settings/thresholds/\" Ancestors (in MRO) neuroio.base.APIBaseBase Descendants neuroio.settings.v1.Impl neuroio.settings.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/settings/thresholds/{key}/\" else : return self . base_url + \"/v1/settings/thresholds/\"","title":"V1"},{"location":"reference/neuroio/settings/v1/#module-neuroiosettingsv1","text":"None None View Source from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import ( DEFAULT_EXACT_THRESHOLD , DEFAULT_HA_THRESHOLD , DEFAULT_JUNK_THRESHOLD , ) from neuroio.utils import request_dict_processing class SettingsBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/settings/thresholds/ { key } /\" else : return self . base_url + \"/v1/settings/thresholds/\" class Impl ( APIBase , SettingsBase ): def get ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ()) def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . patch ( url = self . get_url (), data = data ) def reset ( self ) -> Response : with self . get_client () as client : return client . post ( url = self . get_url ( \"reset\" )) class ImplAsync ( APIBaseAsync , SettingsBase ): async def get ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ()) async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url (), data = data ) async def reset ( self ) -> Response : async with self . get_client () as client : return await client . post ( url = self . get_url ( \"reset\" ))","title":"Module neuroio.settings.v1"},{"location":"reference/neuroio/settings/v1/#variables","text":"DEFAULT_EXACT_THRESHOLD DEFAULT_HA_THRESHOLD DEFAULT_JUNK_THRESHOLD","title":"Variables"},{"location":"reference/neuroio/settings/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/settings/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( APIBase , SettingsBase ): def get ( self ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ()) def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client: return client . patch ( url = self . get_url (), data = data ) def reset ( self ) -> Response: with self . get_client () as client: return client . post ( url = self . get_url ( \"reset\" ))","title":"Impl"},{"location":"reference/neuroio/settings/v1/#ancestors-in-mro","text":"neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.settings.v1.SettingsBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/settings/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/settings/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/settings/v1/#get","text":"def get ( self ) -> httpx . Response View Source def get ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ())","title":"get"},{"location":"reference/neuroio/settings/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/settings/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/settings/thresholds/{key}/\" else : return self . base_url + \"/v1/settings/thresholds/\"","title":"get_url"},{"location":"reference/neuroio/settings/v1/#reset","text":"def reset ( self ) -> httpx . Response View Source def reset ( self ) -> Response : with self . get_client () as client : return client . post ( url = self . get_url ( \"reset\" ))","title":"reset"},{"location":"reference/neuroio/settings/v1/#update","text":"def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . Response View Source def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . patch ( url = self . get_url (), data = data )","title":"update"},{"location":"reference/neuroio/settings/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , SettingsBase ): async def get ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ()) async def update ( self , exact: float = DEFAULT_EXACT_THRESHOLD , ha: float = DEFAULT_HA_THRESHOLD , junk: float = DEFAULT_JUNK_THRESHOLD , ) -> Response: data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client: return await client . patch ( url = self . get_url (), data = data ) async def reset ( self ) -> Response: async with self . get_client () as client: return await client . post ( url = self . get_url ( \"reset\" ))","title":"ImplAsync"},{"location":"reference/neuroio/settings/v1/#ancestors-in-mro_1","text":"neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.settings.v1.SettingsBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/settings/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/settings/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/settings/v1/#get_1","text":"def get ( self ) -> httpx . Response View Source async def get ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ())","title":"get"},{"location":"reference/neuroio/settings/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/settings/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/settings/thresholds/{key}/\" else : return self . base_url + \"/v1/settings/thresholds/\"","title":"get_url"},{"location":"reference/neuroio/settings/v1/#reset_1","text":"def reset ( self ) -> httpx . Response View Source async def reset ( self ) -> Response : async with self . get_client () as client : return await client . post ( url = self . get_url ( \"reset\" ))","title":"reset"},{"location":"reference/neuroio/settings/v1/#update_1","text":"def update ( self , exact : float = 79.3 , ha : float = 75.5 , junk : float = 68.84 ) -> httpx . Response View Source async def update ( self , exact : float = DEFAULT_EXACT_THRESHOLD , ha : float = DEFAULT_HA_THRESHOLD , junk : float = DEFAULT_JUNK_THRESHOLD , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url (), data = data )","title":"update"},{"location":"reference/neuroio/settings/v1/#settingsbase","text":"class SettingsBase ( / , * args , ** kwargs ) View Source class SettingsBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/settings/thresholds/{key}/\" else: return self . base_url + \"/v1/settings/thresholds/\"","title":"SettingsBase"},{"location":"reference/neuroio/settings/v1/#ancestors-in-mro_2","text":"neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/settings/v1/#descendants","text":"neuroio.settings.v1.Impl neuroio.settings.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/settings/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/settings/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/settings/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/settings/thresholds/{key}/\" else : return self . base_url + \"/v1/settings/thresholds/\"","title":"get_url"},{"location":"reference/neuroio/sources/","text":"Module neuroio.sources None None Sub-modules neuroio.sources.v1","title":"Index"},{"location":"reference/neuroio/sources/#module-neuroiosources","text":"None None","title":"Module neuroio.sources"},{"location":"reference/neuroio/sources/#sub-modules","text":"neuroio.sources.v1","title":"Sub-modules"},{"location":"reference/neuroio/sources/v1/","text":"Module neuroio.sources.v1 None None View Source from typing import List , Optional , Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import sentinel from neuroio.utils import request_dict_processing , request_query_processing class SourcesBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/sources/ { key } /\" else : return self . base_url + \"/v1/sources/\" class Impl ( APIBase , SourcesBase ): def create ( self , name : str , license_id : Optional [ Union [ str , object ]] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : Optional [ Union [ str , object ]] = sentinel , license_id : Optional [ Union [ str , object ]] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) class ImplAsync ( APIBaseAsync , SourcesBase ): async def create ( self , name : str , license_id : Optional [ Union [ str , object ]] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : Optional [ Union [ str , object ]] = sentinel , license_id : Optional [ Union [ str , object ]] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" )) Variables sentinel Classes Impl class Impl ( settings : dict ) View Source class Impl ( APIBase , SourcesBase ) : def create ( self , name : str , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id : int , name : Optional [ Union[str, object ] ] = sentinel , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) Ancestors (in MRO) neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.sources.v1.SourcesBase neuroio.base.APIBaseBase Class variables base_url Methods create def create ( self , name : str , license_id : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def create ( self , name : str , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/sources/{key}/\" else : return self . base_url + \"/v1/sources/\" list def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) update def update ( self , id : int , name : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , license_id : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , use_pps_time : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_persons : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def update ( self , id : int , name : Optional [ Union[str, object ] ] = sentinel , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , SourcesBase ) : async def create ( self , name : str , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id : int , name : Optional [ Union[str, object ] ] = sentinel , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) Ancestors (in MRO) neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.sources.v1.SourcesBase neuroio.base.APIBaseBase Class variables base_url Methods create def create ( self , name : str , license_id : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def create ( self , name : str , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/sources/{key}/\" else : return self . base_url + \"/v1/sources/\" list def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) update def update ( self , id : int , name : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , license_id : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , use_pps_time : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_persons : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def update ( self , id : int , name : Optional [ Union[str, object ] ] = sentinel , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) SourcesBase class SourcesBase ( / , * args , ** kwargs ) View Source class SourcesBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/sources/{key}/\" else: return self . base_url + \"/v1/sources/\" Ancestors (in MRO) neuroio.base.APIBaseBase Descendants neuroio.sources.v1.Impl neuroio.sources.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/sources/{key}/\" else : return self . base_url + \"/v1/sources/\"","title":"V1"},{"location":"reference/neuroio/sources/v1/#module-neuroiosourcesv1","text":"None None View Source from typing import List , Optional , Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import sentinel from neuroio.utils import request_dict_processing , request_query_processing class SourcesBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/sources/ { key } /\" else : return self . base_url + \"/v1/sources/\" class Impl ( APIBase , SourcesBase ): def create ( self , name : str , license_id : Optional [ Union [ str , object ]] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : Optional [ Union [ str , object ]] = sentinel , license_id : Optional [ Union [ str , object ]] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) class ImplAsync ( APIBaseAsync , SourcesBase ): async def create ( self , name : str , license_id : Optional [ Union [ str , object ]] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional [ List [ str ]], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ]) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : Optional [ Union [ str , object ]] = sentinel , license_id : Optional [ Union [ str , object ]] = sentinel , identify_facesize_threshold : Union [ int , object ] = sentinel , use_pps_time : Union [ bool , object ] = sentinel , manual_create_facesize_threshold : Union [ int , object ] = sentinel , manual_create_on_ha : Union [ bool , object ] = sentinel , manual_create_on_junk : Union [ bool , object ] = sentinel , manual_identify_asm : Union [ bool , object ] = sentinel , auto_create_persons : Union [ bool , object ] = sentinel , auto_create_facesize_threshold : Union [ int , object ] = sentinel , auto_create_check_blur : Union [ bool , object ] = sentinel , auto_create_check_exposure : Union [ bool , object ] = sentinel , auto_create_on_ha : Union [ bool , object ] = sentinel , auto_create_on_junk : Union [ bool , object ] = sentinel , auto_check_face_angle : Union [ bool , object ] = sentinel , auto_check_liveness : Union [ bool , object ] = sentinel , auto_create_liveness_only : Union [ bool , object ] = sentinel , auto_identify_asm : Union [ bool , object ] = sentinel , store_images_for_results : Union [ List [ str ], object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\" , \"self\" ]) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" ))","title":"Module neuroio.sources.v1"},{"location":"reference/neuroio/sources/v1/#variables","text":"sentinel","title":"Variables"},{"location":"reference/neuroio/sources/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/sources/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( APIBase , SourcesBase ) : def create ( self , name : str , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id : int , name : Optional [ Union[str, object ] ] = sentinel , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" ))","title":"Impl"},{"location":"reference/neuroio/sources/v1/#ancestors-in-mro","text":"neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.sources.v1.SourcesBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/sources/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/sources/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/sources/v1/#create","text":"def create ( self , name : str , license_id : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def create ( self , name : str , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/sources/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/sources/v1/#get","text":"def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/sources/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/sources/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/sources/{key}/\" else : return self . base_url + \"/v1/sources/\"","title":"get_url"},{"location":"reference/neuroio/sources/v1/#list","text":"def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) with self . get_client () as client : return client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/sources/v1/#update","text":"def update ( self , id : int , name : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , license_id : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , use_pps_time : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_persons : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source def update ( self , id : int , name : Optional [ Union[str, object ] ] = sentinel , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/sources/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , SourcesBase ) : async def create ( self , name : str , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id : int , name : Optional [ Union[str, object ] ] = sentinel , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" ))","title":"ImplAsync"},{"location":"reference/neuroio/sources/v1/#ancestors-in-mro_1","text":"neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.sources.v1.SourcesBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/sources/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/sources/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/sources/v1/#create_1","text":"def create ( self , name : str , license_id : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ List [ str ], NoneType , object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def create ( self , name : str , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : int = 7000 , use_pps_time : bool = False , manual_create_facesize_threshold : int = 25000 , manual_create_on_ha : bool = False , manual_create_on_junk : bool = False , manual_identify_asm : bool = True , auto_create_persons : bool = False , auto_create_facesize_threshold : int = 25000 , auto_create_check_blur : bool = True , auto_create_check_exposure : bool = True , auto_create_on_ha : bool = False , auto_create_on_junk : bool = False , auto_check_face_angle : bool = True , auto_check_liveness : bool = False , auto_create_liveness_only : bool = True , auto_identify_asm : bool = True , store_images_for_results : Union [ Optional[List[str ] ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/sources/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/sources/v1/#get_1","text":"def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/sources/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/sources/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/sources/{key}/\" else : return self . base_url + \"/v1/sources/\"","title":"get_url"},{"location":"reference/neuroio/sources/v1/#list_1","text":"def list ( self , q : str = None , spaces_ids : Union [ List [ int ], object ] = < object object at 0x10c207fb0 > , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = None , spaces_ids : Union [ List[int ] , object ] = sentinel , limit : int = 20 , offset : int = 0 , ) -> Response : data = request_query_processing ( locals (), [ \"self\" ] ) async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/sources/v1/#update_1","text":"def update ( self , id : int , name : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , license_id : Union [ str , object , NoneType ] = < object object at 0x10c207fb0 > , identify_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , use_pps_time : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_create_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , manual_create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , manual_identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_persons : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_facesize_threshold : Union [ int , object ] = < object object at 0x10c207fb0 > , auto_create_check_blur : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_check_exposure : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_on_ha : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_on_junk : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_check_face_angle : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_check_liveness : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_create_liveness_only : Union [ bool , object ] = < object object at 0x10c207fb0 > , auto_identify_asm : Union [ bool , object ] = < object object at 0x10c207fb0 > , store_images_for_results : Union [ List [ str ], object ] = < object object at 0x10c207fb0 > ) -> httpx . Response View Source async def update ( self , id : int , name : Optional [ Union[str, object ] ] = sentinel , license_id : Optional [ Union[str, object ] ] = sentinel , identify_facesize_threshold : Union [ int, object ] = sentinel , use_pps_time : Union [ bool, object ] = sentinel , manual_create_facesize_threshold : Union [ int, object ] = sentinel , manual_create_on_ha : Union [ bool, object ] = sentinel , manual_create_on_junk : Union [ bool, object ] = sentinel , manual_identify_asm : Union [ bool, object ] = sentinel , auto_create_persons : Union [ bool, object ] = sentinel , auto_create_facesize_threshold : Union [ int, object ] = sentinel , auto_create_check_blur : Union [ bool, object ] = sentinel , auto_create_check_exposure : Union [ bool, object ] = sentinel , auto_create_on_ha : Union [ bool, object ] = sentinel , auto_create_on_junk : Union [ bool, object ] = sentinel , auto_check_face_angle : Union [ bool, object ] = sentinel , auto_check_liveness : Union [ bool, object ] = sentinel , auto_create_liveness_only : Union [ bool, object ] = sentinel , auto_identify_asm : Union [ bool, object ] = sentinel , store_images_for_results : Union [ List[str ] , object ] = sentinel , ) -> Response : data = request_dict_processing ( locals (), [ \"id\", \"self\" ] ) async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/sources/v1/#sourcesbase","text":"class SourcesBase ( / , * args , ** kwargs ) View Source class SourcesBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/sources/{key}/\" else: return self . base_url + \"/v1/sources/\"","title":"SourcesBase"},{"location":"reference/neuroio/sources/v1/#ancestors-in-mro_2","text":"neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/sources/v1/#descendants","text":"neuroio.sources.v1.Impl neuroio.sources.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/sources/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/sources/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/sources/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/sources/{key}/\" else : return self . base_url + \"/v1/sources/\"","title":"get_url"},{"location":"reference/neuroio/spaces/","text":"Module neuroio.spaces None None Sub-modules neuroio.spaces.v1","title":"Index"},{"location":"reference/neuroio/spaces/#module-neuroiospaces","text":"None None","title":"Module neuroio.spaces"},{"location":"reference/neuroio/spaces/#sub-modules","text":"neuroio.spaces.v1","title":"Sub-modules"},{"location":"reference/neuroio/spaces/v1/","text":"Module neuroio.spaces.v1 None None View Source from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class SpacesBase ( IAMBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/spaces/ { key } /\" else : return self . base_url + \"/v1/spaces/\" class Impl ( IAMBase , SpacesBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url ( f \" { id } /tokens\" ), json = data ) class ImplAsync ( IAMBaseAsync , SpacesBase ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" )) async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url ( f \" { id } /tokens\" ), json = data ) Classes Impl class Impl ( settings : dict ) View Source class Impl ( IAMBase , SpacesBase ): def create ( self , name: str ) -> Response: data = { \"name\" : name } with self . get_client () as client: return client . post ( url = self . get_url (), json = data ) def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } with self . get_client () as client: return client . get ( url = self . get_url (), params = data ) def get ( self , id: int ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } with self . get_client () as client: return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) def delete ( self , id: int ) -> Response: with self . get_client () as client: return client . delete ( url = self . get_url ( f \"{id}\" )) def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } with self . get_client () as client: return client . post ( url = self . get_url ( f \"{id}/tokens\" ), json = data ) Ancestors (in MRO) neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.spaces.v1.SpacesBase neuroio.base.IAMBaseBase Class variables base_url Methods create def create ( self , name : str ) -> httpx . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/spaces/{key}/\" else : return self . base_url + \"/v1/spaces/\" list def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) token def token ( self , id : int , permanent : bool = False ) -> httpx . Response View Source def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url ( f \"{id}/tokens\" ), json = data ) update def update ( self , id : int , name : str ) -> httpx . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , SpacesBase ): async def create ( self , name: str ) -> Response: data = { \"name\" : name } async with self . get_client () as client: return await client . post ( url = self . get_url (), json = data ) async def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = self . get_url (), params = data ) async def get ( self , id: int ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } async with self . get_client () as client: return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) async def delete ( self , id: int ) -> Response: async with self . get_client () as client: return await client . delete ( url = self . get_url ( f \"{id}\" )) async def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } async with self . get_client () as client: return await client . post ( url = self . get_url ( f \"{id}/tokens\" ), json = data ) Ancestors (in MRO) neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.spaces.v1.SpacesBase neuroio.base.IAMBaseBase Class variables base_url Methods create def create ( self , name : str ) -> httpx . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) delete def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" )) get def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" )) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/spaces/{key}/\" else : return self . base_url + \"/v1/spaces/\" list def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) token def token ( self , id : int , permanent : bool = False ) -> httpx . Response View Source async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url ( f \"{id}/tokens\" ), json = data ) update def update ( self , id : int , name : str ) -> httpx . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) SpacesBase class SpacesBase ( / , * args , ** kwargs ) View Source class SpacesBase ( IAMBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/spaces/{key}/\" else: return self . base_url + \"/v1/spaces/\" Ancestors (in MRO) neuroio.base.IAMBaseBase Descendants neuroio.spaces.v1.Impl neuroio.spaces.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/spaces/{key}/\" else : return self . base_url + \"/v1/spaces/\"","title":"V1"},{"location":"reference/neuroio/spaces/v1/#module-neuroiospacesv1","text":"None None View Source from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class SpacesBase ( IAMBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/spaces/ { key } /\" else : return self . base_url + \"/v1/spaces/\" class Impl ( IAMBase , SpacesBase ): def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { id } \" )) def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { id } \" )) def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url ( f \" { id } /tokens\" ), json = data ) class ImplAsync ( IAMBaseAsync , SpacesBase ): async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { id } \" )) async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { id } \" ), json = data ) async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { id } \" )) async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url ( f \" { id } /tokens\" ), json = data )","title":"Module neuroio.spaces.v1"},{"location":"reference/neuroio/spaces/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/spaces/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( IAMBase , SpacesBase ): def create ( self , name: str ) -> Response: data = { \"name\" : name } with self . get_client () as client: return client . post ( url = self . get_url (), json = data ) def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } with self . get_client () as client: return client . get ( url = self . get_url (), params = data ) def get ( self , id: int ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ( f \"{id}\" )) def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } with self . get_client () as client: return client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) def delete ( self , id: int ) -> Response: with self . get_client () as client: return client . delete ( url = self . get_url ( f \"{id}\" )) def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } with self . get_client () as client: return client . post ( url = self . get_url ( f \"{id}/tokens\" ), json = data )","title":"Impl"},{"location":"reference/neuroio/spaces/v1/#ancestors-in-mro","text":"neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.spaces.v1.SpacesBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/spaces/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/spaces/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/spaces/v1/#create","text":"def create ( self , name : str ) -> httpx . Response View Source def create ( self , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/spaces/v1/#delete","text":"def delete ( self , id : int ) -> httpx . Response View Source def delete ( self , id : int ) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/spaces/v1/#get","text":"def get ( self , id : int ) -> httpx . Response View Source def get ( self , id : int ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/spaces/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/spaces/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/spaces/{key}/\" else : return self . base_url + \"/v1/spaces/\"","title":"get_url"},{"location":"reference/neuroio/spaces/v1/#list","text":"def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/spaces/v1/#token","text":"def token ( self , id : int , permanent : bool = False ) -> httpx . Response View Source def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url ( f \"{id}/tokens\" ), json = data )","title":"token"},{"location":"reference/neuroio/spaces/v1/#update","text":"def update ( self , id : int , name : str ) -> httpx . Response View Source def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/spaces/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , SpacesBase ): async def create ( self , name: str ) -> Response: data = { \"name\" : name } async with self . get_client () as client: return await client . post ( url = self . get_url (), json = data ) async def list ( self , q: str = None, limit: int = 20 , offset: int = 0 ) -> Response: data = { \"q\" : q, \"limit\": limit, \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = self . get_url (), params = data ) async def get ( self , id: int ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ( f \"{id}\" )) async def update ( self , id: int , name: str ) -> Response: data = { \"name\" : name } async with self . get_client () as client: return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data ) async def delete ( self , id: int ) -> Response: async with self . get_client () as client: return await client . delete ( url = self . get_url ( f \"{id}\" )) async def token ( self , id: int , permanent: bool = False ) -> Response: data = { \"permanent\": permanent } async with self . get_client () as client: return await client . post ( url = self . get_url ( f \"{id}/tokens\" ), json = data )","title":"ImplAsync"},{"location":"reference/neuroio/spaces/v1/#ancestors-in-mro_1","text":"neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.spaces.v1.SpacesBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/spaces/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/spaces/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/spaces/v1/#create_1","text":"def create ( self , name : str ) -> httpx . Response View Source async def create ( self , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/spaces/v1/#delete_1","text":"def delete ( self , id : int ) -> httpx . Response View Source async def delete ( self , id : int ) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{id}\" ))","title":"delete"},{"location":"reference/neuroio/spaces/v1/#get_1","text":"def get ( self , id : int ) -> httpx . Response View Source async def get ( self , id : int ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{id}\" ))","title":"get"},{"location":"reference/neuroio/spaces/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/spaces/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/spaces/{key}/\" else : return self . base_url + \"/v1/spaces/\"","title":"get_url"},{"location":"reference/neuroio/spaces/v1/#list_1","text":"def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , q : str = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"q\" : q , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/spaces/v1/#token_1","text":"def token ( self , id : int , permanent : bool = False ) -> httpx . Response View Source async def token ( self , id : int , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url ( f \"{id}/tokens\" ), json = data )","title":"token"},{"location":"reference/neuroio/spaces/v1/#update_1","text":"def update ( self , id : int , name : str ) -> httpx . Response View Source async def update ( self , id : int , name : str ) -> Response : data = { \"name\" : name } async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{id}\" ), json = data )","title":"update"},{"location":"reference/neuroio/spaces/v1/#spacesbase","text":"class SpacesBase ( / , * args , ** kwargs ) View Source class SpacesBase ( IAMBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/spaces/{key}/\" else: return self . base_url + \"/v1/spaces/\"","title":"SpacesBase"},{"location":"reference/neuroio/spaces/v1/#ancestors-in-mro_2","text":"neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/spaces/v1/#descendants","text":"neuroio.spaces.v1.Impl neuroio.spaces.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/spaces/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/spaces/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/spaces/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/spaces/{key}/\" else : return self . base_url + \"/v1/spaces/\"","title":"get_url"},{"location":"reference/neuroio/streams/","text":"Module neuroio.streams None None Sub-modules neuroio.streams.tokens","title":"Index"},{"location":"reference/neuroio/streams/#module-neuroiostreams","text":"None None","title":"Module neuroio.streams"},{"location":"reference/neuroio/streams/#sub-modules","text":"neuroio.streams.tokens","title":"Sub-modules"},{"location":"reference/neuroio/streams/tokens/","text":"Module neuroio.streams.tokens None None Sub-modules neuroio.streams.tokens.v1","title":"Index"},{"location":"reference/neuroio/streams/tokens/#module-neuroiostreamstokens","text":"None None","title":"Module neuroio.streams.tokens"},{"location":"reference/neuroio/streams/tokens/#sub-modules","text":"neuroio.streams.tokens.v1","title":"Sub-modules"},{"location":"reference/neuroio/streams/tokens/v1/","text":"Module neuroio.streams.tokens.v1 None None View Source from typing import Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase class StreamTokensBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/streams/tokens/ { key } /\" else : return self . base_url + \"/v1/streams/tokens/\" class Impl ( APIBase , StreamTokensBase ): def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { token_id_or_key } \" )) def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { token_id_or_key } \" ), data = { \"is_active\" : is_active }, ) def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = self . get_url (), params = data ) def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { token_id_or_key } \" )) class ImplAsync ( APIBaseAsync , StreamTokensBase ): async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { token_id_or_key } \" )) async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { token_id_or_key } \" ), data = { \"is_active\" : is_active }, ) async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = self . get_url (), params = data ) async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { token_id_or_key } \" )) Classes Impl class Impl ( settings : dict ) View Source class Impl ( APIBase , StreamTokensBase ): def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } with self . get_client () as client: return client . post ( url = self . get_url (), json = data ) def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client: return client . get ( url = self . get_url (), params = data ) def get ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: with self . get_client () as client: return client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data ={ \"is_active\" : is_active }, ) def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client: return client . delete ( url = self . get_url (), params = data ) def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . delete ( url = self . get_url ( f \"{token_id_or_key}\" )) Ancestors (in MRO) neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.streams.tokens.v1.StreamTokensBase neuroio.base.APIBaseBase Class variables base_url Methods create def create ( self , permanent : bool = False ) -> httpx . Response View Source def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) delete def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{token_id_or_key}\" )) delete_list def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = self . get_url (), params = data ) get def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/streams/tokens/{key}/\" else : return self . base_url + \"/v1/streams/tokens/\" list def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) update def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data = { \"is_active\" : is_active }, ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , StreamTokensBase ): async def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } async with self . get_client () as client: return await client . post ( url = self . get_url (), json = data ) async def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = self . get_url (), params = data ) async def get ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) async def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: async with self . get_client () as client: return await client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data ={ \"is_active\" : is_active }, ) async def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client: return await client . delete ( url = self . get_url (), params = data ) async def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . delete ( url = self . get_url ( f \"{token_id_or_key}\" )) Ancestors (in MRO) neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.streams.tokens.v1.StreamTokensBase neuroio.base.APIBaseBase Class variables base_url Methods create def create ( self , permanent : bool = False ) -> httpx . Response View Source async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) delete def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{token_id_or_key}\" )) delete_list def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = self . get_url (), params = data ) get def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/streams/tokens/{key}/\" else : return self . base_url + \"/v1/streams/tokens/\" list def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) update def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data = { \"is_active\" : is_active }, ) StreamTokensBase class StreamTokensBase ( / , * args , ** kwargs ) View Source class StreamTokensBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/streams/tokens/{key}/\" else: return self . base_url + \"/v1/streams/tokens/\" Ancestors (in MRO) neuroio.base.APIBaseBase Descendants neuroio.streams.tokens.v1.Impl neuroio.streams.tokens.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/streams/tokens/{key}/\" else : return self . base_url + \"/v1/streams/tokens/\"","title":"V1"},{"location":"reference/neuroio/streams/tokens/v1/#module-neuroiostreamstokensv1","text":"None None View Source from typing import Union from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase class StreamTokensBase ( APIBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/streams/tokens/ { key } /\" else : return self . base_url + \"/v1/streams/tokens/\" class Impl ( APIBase , StreamTokensBase ): def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { token_id_or_key } \" )) def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { token_id_or_key } \" ), data = { \"is_active\" : is_active }, ) def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = self . get_url (), params = data ) def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { token_id_or_key } \" )) class ImplAsync ( APIBaseAsync , StreamTokensBase ): async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { token_id_or_key } \" )) async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { token_id_or_key } \" ), data = { \"is_active\" : is_active }, ) async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = self . get_url (), params = data ) async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { token_id_or_key } \" ))","title":"Module neuroio.streams.tokens.v1"},{"location":"reference/neuroio/streams/tokens/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/streams/tokens/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( APIBase , StreamTokensBase ): def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } with self . get_client () as client: return client . post ( url = self . get_url (), json = data ) def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client: return client . get ( url = self . get_url (), params = data ) def get ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: with self . get_client () as client: return client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data ={ \"is_active\" : is_active }, ) def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client: return client . delete ( url = self . get_url (), params = data ) def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . delete ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"Impl"},{"location":"reference/neuroio/streams/tokens/v1/#ancestors-in-mro","text":"neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.streams.tokens.v1.StreamTokensBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/streams/tokens/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/streams/tokens/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/streams/tokens/v1/#create","text":"def create ( self , permanent : bool = False ) -> httpx . Response View Source def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/streams/tokens/v1/#delete","text":"def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"delete"},{"location":"reference/neuroio/streams/tokens/v1/#delete_list","text":"def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = self . get_url (), params = data )","title":"delete_list"},{"location":"reference/neuroio/streams/tokens/v1/#get","text":"def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"get"},{"location":"reference/neuroio/streams/tokens/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/streams/tokens/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/streams/tokens/{key}/\" else : return self . base_url + \"/v1/streams/tokens/\"","title":"get_url"},{"location":"reference/neuroio/streams/tokens/v1/#list","text":"def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/streams/tokens/v1/#update","text":"def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data = { \"is_active\" : is_active }, )","title":"update"},{"location":"reference/neuroio/streams/tokens/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , StreamTokensBase ): async def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } async with self . get_client () as client: return await client . post ( url = self . get_url (), json = data ) async def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = self . get_url (), params = data ) async def get ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) async def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: async with self . get_client () as client: return await client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data ={ \"is_active\" : is_active }, ) async def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client: return await client . delete ( url = self . get_url (), params = data ) async def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . delete ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"ImplAsync"},{"location":"reference/neuroio/streams/tokens/v1/#ancestors-in-mro_1","text":"neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.streams.tokens.v1.StreamTokensBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/streams/tokens/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/streams/tokens/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/streams/tokens/v1/#create_1","text":"def create ( self , permanent : bool = False ) -> httpx . Response View Source async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/streams/tokens/v1/#delete_1","text":"def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"delete"},{"location":"reference/neuroio/streams/tokens/v1/#delete_list_1","text":"def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = self . get_url (), params = data )","title":"delete_list"},{"location":"reference/neuroio/streams/tokens/v1/#get_1","text":"def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"get"},{"location":"reference/neuroio/streams/tokens/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/streams/tokens/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/streams/tokens/{key}/\" else : return self . base_url + \"/v1/streams/tokens/\"","title":"get_url"},{"location":"reference/neuroio/streams/tokens/v1/#list_1","text":"def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/streams/tokens/v1/#update_1","text":"def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data = { \"is_active\" : is_active }, )","title":"update"},{"location":"reference/neuroio/streams/tokens/v1/#streamtokensbase","text":"class StreamTokensBase ( / , * args , ** kwargs ) View Source class StreamTokensBase ( APIBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/streams/tokens/{key}/\" else: return self . base_url + \"/v1/streams/tokens/\"","title":"StreamTokensBase"},{"location":"reference/neuroio/streams/tokens/v1/#ancestors-in-mro_2","text":"neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/streams/tokens/v1/#descendants","text":"neuroio.streams.tokens.v1.Impl neuroio.streams.tokens.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/streams/tokens/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/streams/tokens/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/streams/tokens/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/streams/tokens/{key}/\" else : return self . base_url + \"/v1/streams/tokens/\"","title":"get_url"},{"location":"reference/neuroio/tokens/","text":"Module neuroio.tokens None None Sub-modules neuroio.tokens.v1","title":"Index"},{"location":"reference/neuroio/tokens/#module-neuroiotokens","text":"None None","title":"Module neuroio.tokens"},{"location":"reference/neuroio/tokens/#sub-modules","text":"neuroio.tokens.v1","title":"Sub-modules"},{"location":"reference/neuroio/tokens/v1/","text":"Module neuroio.tokens.v1 None None View Source from typing import Union from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class TokensBase ( IAMBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/tokens/ { key } /\" else : return self . base_url + \"/v1/tokens/\" class Impl ( IAMBase , TokensBase ): def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { token_id_or_key } \" )) def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { token_id_or_key } \" ), data = { \"is_active\" : is_active }, ) def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = self . get_url (), params = data ) def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { token_id_or_key } \" )) class ImplAsync ( IAMBaseAsync , TokensBase ): async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { token_id_or_key } \" )) async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { token_id_or_key } \" ), data = { \"is_active\" : is_active }, ) async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = self . get_url (), params = data ) async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { token_id_or_key } \" )) Classes Impl class Impl ( settings : dict ) View Source class Impl ( IAMBase , TokensBase ): def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } with self . get_client () as client: return client . post ( url = self . get_url (), json = data ) def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client: return client . get ( url = self . get_url (), params = data ) def get ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: with self . get_client () as client: return client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data ={ \"is_active\" : is_active }, ) def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client: return client . delete ( url = self . get_url (), params = data ) def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . delete ( url = self . get_url ( f \"{token_id_or_key}\" )) Ancestors (in MRO) neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.tokens.v1.TokensBase neuroio.base.IAMBaseBase Class variables base_url Methods create def create ( self , permanent : bool = False ) -> httpx . Response View Source def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) delete def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{token_id_or_key}\" )) delete_list def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = self . get_url (), params = data ) get def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/tokens/{key}/\" else : return self . base_url + \"/v1/tokens/\" list def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) update def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data = { \"is_active\" : is_active }, ) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , TokensBase ): async def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } async with self . get_client () as client: return await client . post ( url = self . get_url (), json = data ) async def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = self . get_url (), params = data ) async def get ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) async def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: async with self . get_client () as client: return await client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data ={ \"is_active\" : is_active }, ) async def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client: return await client . delete ( url = self . get_url (), params = data ) async def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . delete ( url = self . get_url ( f \"{token_id_or_key}\" )) Ancestors (in MRO) neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.tokens.v1.TokensBase neuroio.base.IAMBaseBase Class variables base_url Methods create def create ( self , permanent : bool = False ) -> httpx . Response View Source async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) delete def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{token_id_or_key}\" )) delete_list def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = self . get_url (), params = data ) get def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/tokens/{key}/\" else : return self . base_url + \"/v1/tokens/\" list def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) update def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data = { \"is_active\" : is_active }, ) TokensBase class TokensBase ( / , * args , ** kwargs ) View Source class TokensBase ( IAMBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/tokens/{key}/\" else: return self . base_url + \"/v1/tokens/\" Ancestors (in MRO) neuroio.base.IAMBaseBase Descendants neuroio.tokens.v1.Impl neuroio.tokens.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/tokens/{key}/\" else : return self . base_url + \"/v1/tokens/\"","title":"V1"},{"location":"reference/neuroio/tokens/v1/#module-neuroiotokensv1","text":"None None View Source from typing import Union from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class TokensBase ( IAMBaseBase ): def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/tokens/ { key } /\" else : return self . base_url + \"/v1/tokens/\" class Impl ( IAMBase , TokensBase ): def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url (), json = data ) def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data ) def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \" { token_id_or_key } \" )) def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = self . get_url ( f \" { token_id_or_key } \" ), data = { \"is_active\" : is_active }, ) def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = self . get_url (), params = data ) def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \" { token_id_or_key } \" )) class ImplAsync ( IAMBaseAsync , TokensBase ): async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data ) async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data ) async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \" { token_id_or_key } \" )) async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \" { token_id_or_key } \" ), data = { \"is_active\" : is_active }, ) async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = self . get_url (), params = data ) async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \" { token_id_or_key } \" ))","title":"Module neuroio.tokens.v1"},{"location":"reference/neuroio/tokens/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/tokens/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( IAMBase , TokensBase ): def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } with self . get_client () as client: return client . post ( url = self . get_url (), json = data ) def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client: return client . get ( url = self . get_url (), params = data ) def get ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: with self . get_client () as client: return client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data ={ \"is_active\" : is_active }, ) def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client: return client . delete ( url = self . get_url (), params = data ) def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: with self . get_client () as client: return client . delete ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"Impl"},{"location":"reference/neuroio/tokens/v1/#ancestors-in-mro","text":"neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.tokens.v1.TokensBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/tokens/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/tokens/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/tokens/v1/#create","text":"def create ( self , permanent : bool = False ) -> httpx . Response View Source def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } with self . get_client () as client : return client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/tokens/v1/#delete","text":"def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . delete ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"delete"},{"location":"reference/neuroio/tokens/v1/#delete_list","text":"def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None with self . get_client () as client : return client . delete ( url = self . get_url (), params = data )","title":"delete_list"},{"location":"reference/neuroio/tokens/v1/#get","text":"def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source def get ( self , token_id_or_key : Union [ int , str ]) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"get"},{"location":"reference/neuroio/tokens/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/tokens/v1/#get_url","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/tokens/{key}/\" else : return self . base_url + \"/v1/tokens/\"","title":"get_url"},{"location":"reference/neuroio/tokens/v1/#list","text":"def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } with self . get_client () as client : return client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/tokens/v1/#update","text":"def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : with self . get_client () as client : return client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data = { \"is_active\" : is_active }, )","title":"update"},{"location":"reference/neuroio/tokens/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , TokensBase ): async def create ( self , permanent: bool = False ) -> Response: data = { \"permanent\" : permanent } async with self . get_client () as client: return await client . post ( url = self . get_url (), json = data ) async def list ( self , permanent: bool = None , limit: int = 20 , offset: int = 0 ) -> Response: data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client: return await client . get ( url = self . get_url (), params = data ) async def get ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ( f \"{token_id_or_key}\" )) async def update ( self , token_id_or_key: Union [ int , str ], is_active: bool ) -> Response: async with self . get_client () as client: return await client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data ={ \"is_active\" : is_active }, ) async def delete_list ( self , permanent: bool = None ) -> Response: data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client: return await client . delete ( url = self . get_url (), params = data ) async def delete ( self , token_id_or_key: Union [ int , str ]) -> Response: async with self . get_client () as client: return await client . delete ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"ImplAsync"},{"location":"reference/neuroio/tokens/v1/#ancestors-in-mro_1","text":"neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.tokens.v1.TokensBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/tokens/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/tokens/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/tokens/v1/#create_1","text":"def create ( self , permanent : bool = False ) -> httpx . Response View Source async def create ( self , permanent : bool = False ) -> Response : data = { \"permanent\" : permanent } async with self . get_client () as client : return await client . post ( url = self . get_url (), json = data )","title":"create"},{"location":"reference/neuroio/tokens/v1/#delete_1","text":"def delete ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def delete ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . delete ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"delete"},{"location":"reference/neuroio/tokens/v1/#delete_list_1","text":"def delete_list ( self , permanent : bool = None ) -> httpx . Response View Source async def delete_list ( self , permanent : bool = None ) -> Response : data = { \"permanent\" : permanent } if permanent is not None else None async with self . get_client () as client : return await client . delete ( url = self . get_url (), params = data )","title":"delete_list"},{"location":"reference/neuroio/tokens/v1/#get_1","text":"def get ( self , token_id_or_key : Union [ int , str ] ) -> httpx . Response View Source async def get ( self , token_id_or_key : Union [ int , str ]) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ( f \"{token_id_or_key}\" ))","title":"get"},{"location":"reference/neuroio/tokens/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/tokens/v1/#get_url_1","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/tokens/{key}/\" else : return self . base_url + \"/v1/tokens/\"","title":"get_url"},{"location":"reference/neuroio/tokens/v1/#list_1","text":"def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> httpx . Response View Source async def list ( self , permanent : bool = None , limit : int = 20 , offset : int = 0 ) -> Response : data = { \"permanent\" : permanent , \"limit\" : limit , \"offset\" : offset } async with self . get_client () as client : return await client . get ( url = self . get_url (), params = data )","title":"list"},{"location":"reference/neuroio/tokens/v1/#update_1","text":"def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> httpx . Response View Source async def update ( self , token_id_or_key : Union [ int , str ], is_active : bool ) -> Response : async with self . get_client () as client : return await client . patch ( url = self . get_url ( f \"{token_id_or_key}\" ), data = { \"is_active\" : is_active }, )","title":"update"},{"location":"reference/neuroio/tokens/v1/#tokensbase","text":"class TokensBase ( / , * args , ** kwargs ) View Source class TokensBase ( IAMBaseBase ): def get_url ( self , key: str = None ) -> str: if key: return self . base_url + f \"/v1/tokens/{key}/\" else: return self . base_url + \"/v1/tokens/\"","title":"TokensBase"},{"location":"reference/neuroio/tokens/v1/#ancestors-in-mro_2","text":"neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/tokens/v1/#descendants","text":"neuroio.tokens.v1.Impl neuroio.tokens.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/tokens/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/tokens/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/tokens/v1/#get_url_2","text":"def get_url ( self , key : str = None ) -> str View Source def get_url ( self , key : str = None ) -> str : if key : return self . base_url + f \"/v1/tokens/{key}/\" else : return self . base_url + \"/v1/tokens/\"","title":"get_url"},{"location":"reference/neuroio/utility/","text":"Module neuroio.utility None None Sub-modules neuroio.utility.v1","title":"Index"},{"location":"reference/neuroio/utility/#module-neuroioutility","text":"None None","title":"Module neuroio.utility"},{"location":"reference/neuroio/utility/#sub-modules","text":"neuroio.utility.v1","title":"Sub-modules"},{"location":"reference/neuroio/utility/v1/","text":"Module neuroio.utility.v1 None None View Source from typing.io import BinaryIO from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import EntryResult class UtilityBase ( APIBaseBase ): def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/utility/ { key } /\" class Impl ( APIBase , UtilityBase ): def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client : return client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } with self . get_client () as client : return client . post ( url = self . get_url ( \"asm\" ), files = files ) class ImplAsync ( APIBaseAsync , UtilityBase ): async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"asm\" ), files = files ) Classes Impl class Impl ( settings : dict ) View Source class Impl ( APIBase , UtilityBase ): def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client: return client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } with self . get_client () as client: return client . post ( url = self . get_url ( \"asm\" ), files = files ) Ancestors (in MRO) neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.utility.v1.UtilityBase neuroio.base.APIBaseBase Class variables base_url Methods asm def asm ( self , image : < class ' BinaryIO '> ) -> httpx . Response View Source def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } with self . get_client () as client : return client . post ( url = self . get_url ( \"asm\" ), files = files ) compare def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client : return client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/utility/{key}/\" ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , UtilityBase ): async def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client: return await client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) async def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } async with self . get_client () as client: return await client . post ( url = self . get_url ( \"asm\" ), files = files ) Ancestors (in MRO) neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.utility.v1.UtilityBase neuroio.base.APIBaseBase Class variables base_url Methods asm def asm ( self , image : < class ' BinaryIO '> ) -> httpx . Response View Source async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"asm\" ), files = files ) compare def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/utility/{key}/\" UtilityBase class UtilityBase ( / , * args , ** kwargs ) View Source class UtilityBase ( APIBaseBase ): def get_url ( self , key: str ) -> str: return self . base_url + f \"/v1/utility/{key}/\" Ancestors (in MRO) neuroio.base.APIBaseBase Descendants neuroio.utility.v1.Impl neuroio.utility.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/utility/{key}/\"","title":"V1"},{"location":"reference/neuroio/utility/v1/#module-neuroioutilityv1","text":"None None View Source from typing.io import BinaryIO from httpx import Response from neuroio.base import APIBase , APIBaseAsync , APIBaseBase from neuroio.constants import EntryResult class UtilityBase ( APIBaseBase ): def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/utility/ { key } /\" class Impl ( APIBase , UtilityBase ): def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client : return client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } with self . get_client () as client : return client . post ( url = self . get_url ( \"asm\" ), files = files ) class ImplAsync ( APIBaseAsync , UtilityBase ): async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"asm\" ), files = files )","title":"Module neuroio.utility.v1"},{"location":"reference/neuroio/utility/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/utility/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( APIBase , UtilityBase ): def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client: return client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } with self . get_client () as client: return client . post ( url = self . get_url ( \"asm\" ), files = files )","title":"Impl"},{"location":"reference/neuroio/utility/v1/#ancestors-in-mro","text":"neuroio.base.APIBase abc.ABC neuroio.base.Base neuroio.utility.v1.UtilityBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/utility/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/utility/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/utility/v1/#asm","text":"def asm ( self , image : < class ' BinaryIO '> ) -> httpx . Response View Source def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } with self . get_client () as client : return client . post ( url = self . get_url ( \"asm\" ), files = files )","title":"asm"},{"location":"reference/neuroio/utility/v1/#compare","text":"def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } with self . get_client () as client : return client . post ( url = self . get_url ( \"compare\" ), data = data , files = files )","title":"compare"},{"location":"reference/neuroio/utility/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/utility/v1/#get_url","text":"def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/utility/{key}/\"","title":"get_url"},{"location":"reference/neuroio/utility/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( APIBaseAsync , UtilityBase ): async def compare ( self , image1: BinaryIO , image2: BinaryIO , result: str = EntryResult . HA ) -> Response: files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client: return await client . post ( url = self . get_url ( \"compare\" ), data = data , files = files ) async def asm ( self , image: BinaryIO ) -> Response: files = { \"image\" : image } async with self . get_client () as client: return await client . post ( url = self . get_url ( \"asm\" ), files = files )","title":"ImplAsync"},{"location":"reference/neuroio/utility/v1/#ancestors-in-mro_1","text":"neuroio.base.APIBaseAsync abc.ABC neuroio.base.Base neuroio.utility.v1.UtilityBase neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/utility/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/utility/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/utility/v1/#asm_1","text":"def asm ( self , image : < class ' BinaryIO '> ) -> httpx . Response View Source async def asm ( self , image : BinaryIO ) -> Response : files = { \"image\" : image } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"asm\" ), files = files )","title":"asm"},{"location":"reference/neuroio/utility/v1/#compare_1","text":"def compare ( self , image1 : < class ' BinaryIO '>, image2 : < class ' BinaryIO '>, result : str = < EntryResult . HA : 'ha' > ) -> httpx . Response View Source async def compare ( self , image1 : BinaryIO , image2 : BinaryIO , result : str = EntryResult . HA ) -> Response : files = { \"image1\" : image1 , \"image2\" : image2 } data = { \"result\" : result } async with self . get_client () as client : return await client . post ( url = self . get_url ( \"compare\" ), data = data , files = files )","title":"compare"},{"location":"reference/neuroio/utility/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/utility/v1/#get_url_1","text":"def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/utility/{key}/\"","title":"get_url"},{"location":"reference/neuroio/utility/v1/#utilitybase","text":"class UtilityBase ( / , * args , ** kwargs ) View Source class UtilityBase ( APIBaseBase ): def get_url ( self , key: str ) -> str: return self . base_url + f \"/v1/utility/{key}/\"","title":"UtilityBase"},{"location":"reference/neuroio/utility/v1/#ancestors-in-mro_2","text":"neuroio.base.APIBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/utility/v1/#descendants","text":"neuroio.utility.v1.Impl neuroio.utility.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/utility/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/utility/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/utility/v1/#get_url_2","text":"def get_url ( self , key : str ) -> str View Source def get_url ( self , key : str ) -> str : return self . base_url + f \"/v1/utility/{key}/\"","title":"get_url"},{"location":"reference/neuroio/whoami/","text":"Module neuroio.whoami None None Sub-modules neuroio.whoami.v1","title":"Index"},{"location":"reference/neuroio/whoami/#module-neuroiowhoami","text":"None None","title":"Module neuroio.whoami"},{"location":"reference/neuroio/whoami/#sub-modules","text":"neuroio.whoami.v1","title":"Sub-modules"},{"location":"reference/neuroio/whoami/v1/","text":"Module neuroio.whoami.v1 None None View Source from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class WhoamiBase ( IAMBaseBase ): def get_url ( self ) -> str : return self . base_url + \"/v1/whoami/\" class Impl ( IAMBase , WhoamiBase ): def me ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ()) class ImplAsync ( IAMBaseAsync , WhoamiBase ): async def me ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ()) Classes Impl class Impl ( settings : dict ) View Source class Impl ( IAMBase , WhoamiBase ): def me ( self ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ()) Ancestors (in MRO) neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.whoami.v1.WhoamiBase neuroio.base.IAMBaseBase Class variables base_url Methods get_client def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings ) get_url def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/whoami/\" me def me ( self ) -> httpx . Response View Source def me ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ()) ImplAsync class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , WhoamiBase ): async def me ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ()) Ancestors (in MRO) neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.whoami.v1.WhoamiBase neuroio.base.IAMBaseBase Class variables base_url Methods get_client def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings ) get_url def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/whoami/\" me def me ( self ) -> httpx . Response View Source async def me ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ()) WhoamiBase class WhoamiBase ( / , * args , ** kwargs ) View Source class WhoamiBase ( IAMBaseBase ): def get_url ( self ) -> str: return self . base_url + \"/v1/whoami/\" Ancestors (in MRO) neuroio.base.IAMBaseBase Descendants neuroio.whoami.v1.Impl neuroio.whoami.v1.ImplAsync Class variables base_url Methods get_url def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/whoami/\"","title":"V1"},{"location":"reference/neuroio/whoami/v1/#module-neuroiowhoamiv1","text":"None None View Source from httpx import Response from neuroio.base import IAMBase , IAMBaseAsync , IAMBaseBase class WhoamiBase ( IAMBaseBase ): def get_url ( self ) -> str : return self . base_url + \"/v1/whoami/\" class Impl ( IAMBase , WhoamiBase ): def me ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ()) class ImplAsync ( IAMBaseAsync , WhoamiBase ): async def me ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ())","title":"Module neuroio.whoami.v1"},{"location":"reference/neuroio/whoami/v1/#classes","text":"","title":"Classes"},{"location":"reference/neuroio/whoami/v1/#impl","text":"class Impl ( settings : dict ) View Source class Impl ( IAMBase , WhoamiBase ): def me ( self ) -> Response: with self . get_client () as client: return client . get ( url = self . get_url ())","title":"Impl"},{"location":"reference/neuroio/whoami/v1/#ancestors-in-mro","text":"neuroio.base.IAMBase abc.ABC neuroio.base.Base neuroio.whoami.v1.WhoamiBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/whoami/v1/#class-variables","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/whoami/v1/#methods","text":"","title":"Methods"},{"location":"reference/neuroio/whoami/v1/#get_client","text":"def get_client ( self ) -> httpx . Client View Source def get_client ( self ) -> Client : return Client ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/whoami/v1/#get_url","text":"def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/whoami/\"","title":"get_url"},{"location":"reference/neuroio/whoami/v1/#me","text":"def me ( self ) -> httpx . Response View Source def me ( self ) -> Response : with self . get_client () as client : return client . get ( url = self . get_url ())","title":"me"},{"location":"reference/neuroio/whoami/v1/#implasync","text":"class ImplAsync ( settings : dict ) View Source class ImplAsync ( IAMBaseAsync , WhoamiBase ): async def me ( self ) -> Response: async with self . get_client () as client: return await client . get ( url = self . get_url ())","title":"ImplAsync"},{"location":"reference/neuroio/whoami/v1/#ancestors-in-mro_1","text":"neuroio.base.IAMBaseAsync abc.ABC neuroio.base.Base neuroio.whoami.v1.WhoamiBase neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/whoami/v1/#class-variables_1","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/whoami/v1/#methods_1","text":"","title":"Methods"},{"location":"reference/neuroio/whoami/v1/#get_client_1","text":"def get_client ( self ) -> httpx . AsyncClient View Source def get_client ( self ) -> AsyncClient : return AsyncClient ( ** self . settings )","title":"get_client"},{"location":"reference/neuroio/whoami/v1/#get_url_1","text":"def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/whoami/\"","title":"get_url"},{"location":"reference/neuroio/whoami/v1/#me_1","text":"def me ( self ) -> httpx . Response View Source async def me ( self ) -> Response : async with self . get_client () as client : return await client . get ( url = self . get_url ())","title":"me"},{"location":"reference/neuroio/whoami/v1/#whoamibase","text":"class WhoamiBase ( / , * args , ** kwargs ) View Source class WhoamiBase ( IAMBaseBase ): def get_url ( self ) -> str: return self . base_url + \"/v1/whoami/\"","title":"WhoamiBase"},{"location":"reference/neuroio/whoami/v1/#ancestors-in-mro_2","text":"neuroio.base.IAMBaseBase","title":"Ancestors (in MRO)"},{"location":"reference/neuroio/whoami/v1/#descendants","text":"neuroio.whoami.v1.Impl neuroio.whoami.v1.ImplAsync","title":"Descendants"},{"location":"reference/neuroio/whoami/v1/#class-variables_2","text":"base_url","title":"Class variables"},{"location":"reference/neuroio/whoami/v1/#methods_2","text":"","title":"Methods"},{"location":"reference/neuroio/whoami/v1/#get_url_2","text":"def get_url ( self ) -> str View Source def get_url ( self ) -> str : return self . base_url + \"/v1/whoami/\"","title":"get_url"}]}